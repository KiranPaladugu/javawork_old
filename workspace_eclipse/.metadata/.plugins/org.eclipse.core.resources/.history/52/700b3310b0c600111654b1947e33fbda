/**
 *
 */
package com.marconi.fusion.tmf.i36PlugIn.realignment;

import java.io.File;
import java.io.FileNotFoundException;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.ericsson.oss.sbiadapter.converter.StepByStepConverter;
import com.ericsson.oss.sbiadapter.converter.StepByStepConverter.TypeOfConversion;
import com.ericsson.oss.slc.ClassConvertionException;
import com.ericsson.oss.slc.IClassConverter;
import com.marconi.fusion.X36.X36Message;
import com.marconi.fusion.X36.X36MessageFactory;
import com.marconi.fusion.X36.X36MsgGetReportNodeConfiguration;
import com.marconi.fusion.X36.X36NeId;
import com.marconi.fusion.X36.X36NetworkElement;
import com.marconi.fusion.X36.X36SetOfNeId;
import com.marconi.fusion.X36.X36SetOfNetworkElement;
import com.marconi.fusion.base.application.Profile;
import com.marconi.fusion.base.asn1.msg.FileMsgBerReader;
import com.marconi.fusion.base.asn1.msg.Message;
import com.marconi.fusion.base.asn1.msg.MessageFactory;
import com.marconi.fusion.base.asn1.msg.io.MessageDecoder;
import com.marconi.fusion.base.logging.DumpInfo;
import com.marconi.fusion.tmf.i36PlugIn.I36PlugIn;
import com.marconi.fusion.tmf.plugIn.adapter.support.PENPDMConverter;

/**
 * This class is introduced as part of CR 375 implementation. This class is used
 * to get the required information from BER files.
 * 
 * @author tcschpr
 * @version 3.4
 * @since 3.4
 * 
 */
public class BERReader {

	static private Log log = LogFactory.getLog(BERReader.class);

	private IClassConverter stepByStepConverter;

	public BERReader(final IClassConverter converter) {
		this.stepByStepConverter = converter;

	}

	/**
	 * This method is to get NeIds from the name of BER files
	 * 
	 * @param emId
	 * @param X36SetOfNeId
	 * @return MEDnList
	 * @throws Exception
	 */
	public static X36SetOfNeId getNodeList(final String emId, final String berLoc) throws Exception {
		final X36SetOfNeId setOfNeIds = new X36SetOfNeId();
		String neID = null;
		StringTokenizer tokens = null;
		if (berLoc != null) {
			final File ber = new File(berLoc);
			final File[] berFiles = ber.listFiles();
			if (berFiles != null) {
				for (int i = 0; i < berFiles.length; i++) {
					final File berFile = berFiles[i];
					// Should not consider ber.realigned files
					if (berFile.getName().endsWith("ber")) {
						// Removing extension .ber from the file name
						final String berFileWithoutExtn = berFile.getName().substring(0, berFile.getName().lastIndexOf('.'));


						// If ber file is for NE which is in current SO-EM
						if (berFileWithoutExtn.contains(emId.replace(':', '_'))) {
							// Getting NeId from the name of ber file
							tokens = new StringTokenizer(berFileWithoutExtn.split(emId.replace(':', '_'))[1], "_");
							if (tokens.hasMoreTokens()) {
								neID = tokens.nextToken();
								if (!setOfNeIds.contains(new X36NeId(Integer.parseInt(neID)))) {
									setOfNeIds.add(Integer.parseInt(neID));


								}
							}
						}
					}
				}
			} else {
				log.error(new DumpInfo("No ber files present in the location: " + berLoc));
				throw new Exception("No ber files present in the location : " + berLoc);
			}
		}
		log.info(new DumpInfo(setOfNeIds, "Set of NEs to be realigned from BER files"));
		return setOfNeIds;
	}


	/**
	 * This method is to get X36 response messages from the BER file of
	 * corresponding NE and converts to latest X36 messages, if BER files are
	 * form older TMF release.
	 * 
	 * @param berLoc
	 * @param msgFactoryClsStr
	 * @param isLatestX36Version
	 * @param x36NeId
	 * @param emId
	 * @return List - list of X36 response messages
	 * @throws Exception
	 */
	@SuppressWarnings("unchecked")
	public List<X36Message<?>> getMessages(final String berLoc, final String msgFactoryClsStr, final boolean isLatestX36Version, final X36NeId x36NeId,
			final String emId) throws Exception {

		log.info("Ready to read X36Messages from the BER files");

		final List<X36Message<?>> x36MsgList = new ArrayList<X36Message<?>>();
		MessageFactory<Message<?>> msgFactory = null;
		final FileMsgBerReader<Message<?>> berReader = null;
		Constructor<?> berFileReaderConstructor = null;
		Object msgFactoryObj = null;
		final Object berFileReaderObject = null;
		final Message<?> msg = null;
		final X36Message<?> x36Msg = null;
		File ber = null;
		final File berFile = null;
		final StringTokenizer tokens = null;
		final int neID = 0;

		try {
			if (msgFactoryClsStr != null && !isLatestX36Version) {

				// Load the message factory class
				final Class<?> msgFactoryClass = Class.forName(msgFactoryClsStr);

				// Create an instance of X36MessageFactory
				msgFactoryObj = msgFactoryClass.newInstance();

				// Load the FileMsgBerReader class
				final Class<?> berFileReaderClass = Class.forName("com.marconi.fusion.base.asn1.msg.FileMsgBerReader");

				// Get the constructor of FileMsgBerReader
				berFileReaderConstructor = berFileReaderClass.getConstructor(File.class, MessageDecoder.class);

			} else {
				msgFactory = new X36MessageFactory();
			}
			if (berLoc != null) {
				ber = new File(berLoc);
				final File[] berFiles = ber.listFiles();
				if (berFiles != null) {
					processBerFile(berFiles,emId,x36NeId,isLatestX36Version,berFileReaderConstructor,msgFactoryObj,msgFactory,x36MsgList);
					if (x36MsgList.size() == 0) {
						log.error(String
								.format("Unable to realign NE <%s> since BER file is empty or BER file for that NE is not present in the folder",
										x36NeId.toString()));
						throw new Exception(
								String.format("Unable to realign NE <%s> since BER file is empty", x36NeId.toString()));
					} else {
						return x36MsgList;
					}
				} else {
					log.error(new DumpInfo("No ber files present in the location: " + berLoc));
					throw new Exception("No ber files present in the location : " + berLoc);
				}
			} else {
				log.error(new DumpInfo("Invalid BER location: " + berLoc));
				throw new Exception("Invalid BER location : " + berLoc);
			}
		} catch (final ClassNotFoundException e) {
			log.error(new DumpInfo("Unable to locate the class : " + msgFactoryClsStr, e));
			throw e;
		} catch (final InstantiationException e) {
			log.error(new DumpInfo("Unable to instantiate the class : " + msgFactoryClsStr, e));
			throw e;
		} catch (final FileNotFoundException e) {
			log.error(new DumpInfo("Unable to locate the BER file : " + berFile.getName(), e));
			throw e;
		} catch (final Exception e) {
			log.error(new DumpInfo("Unable to read messages from BER file", e));
			throw e;
		}
	}

	/**
	 * Processes BERFile information
	 * @param berFile
	 * @param emId
	 * @param x36NeId
	 * @param isLatestX36Version
	 * @param berFileReaderConstructor
	 * @param msgFactoryObj
	 * @param msgFactory
	 * @param x36MsgList
	 * @throws Exception
	 */
	private void processBerFile(final File[] berFiles, final String emId, final X36NeId x36NeId, final boolean isLatestX36Version,
			final Constructor<?> berFileReaderConstructor, final Object msgFactoryObj, final MessageFactory<Message<?>> msgFactory,
			final List<X36Message<?>> x36MsgList) throws Exception {
		StringTokenizer tokens = null;
		int neID = 0;
		for (int i = 0; i < berFiles.length; i++) {
			//Reinitialization of neId to zero. TR HO49420 & TR HO49407
			neID = 0;
			final File berFile = berFiles[i];
			// Should not consider ber.realigned files
			if (berFile.getName().endsWith("ber")) {
				// Removing extension .ber from the file name
				final String berFileWithoutExtn = berFile.getName().substring(0, berFile.getName().lastIndexOf('.'));
				// If ber file is for NE which is in current SO-EM
				if (berFileWithoutExtn.contains(emId.replace(':', '_'))) {
					tokens = new StringTokenizer(berFileWithoutExtn.split(emId.replace(':', '_'))[1], "_");
					if (tokens.hasMoreTokens()) {
						neID = Integer.parseInt(tokens.nextToken());
					}
				}
				// If it is current realigning NE's ber file
				if (neID == x36NeId.getValue()) {
					createBerForNeId(isLatestX36Version, berFileReaderConstructor, msgFactoryObj, berFile, msgFactory, x36MsgList);
				}
			}
		}
	}

	/**
	 * Creates BER file for the given NeId
	 * 
	 * @param isLatestX36Version
	 * @param berFileReaderConstructor
	 * @param msgFactoryObj
	 * @param berFile
	 * @param msgFactory
	 * @param x36MsgList
	 * @throws Exception
	 */
	@SuppressWarnings("unchecked")
	private void createBerForNeId(final boolean isLatestX36Version, final Constructor<?> berFileReaderConstructor, final Object msgFactoryObj,
			final File berFile, final MessageFactory<Message<?>> msgFactory, final List<X36Message<?>> x36MsgList) throws Exception {
		FileMsgBerReader<Message<?>> berReader = null;
		Message<?> msg = null;
		if (!isLatestX36Version) {
			// Build the message decoder class string
			final String messageDecoderClassStr = "com.marconi.fusion.base.asn1.msg.io.MessageDecoder";

			// Load the message decoder class
			final Class<?> messageDecoderClass = Class.forName(messageDecoderClassStr);

			// Get the constructor
			final Constructor<?> messageDecoderConstructor = messageDecoderClass.getConstructor(MessageFactory.class);

			final Object messageDecoderObject = messageDecoderConstructor.newInstance(msgFactoryObj);

			// Create instance of FileMsgBerReader
			final Object berFileReaderObject = berFileReaderConstructor.newInstance(berFile, messageDecoderObject);
			berReader = (FileMsgBerReader<Message<?>>) berFileReaderObject;


		} else {
			berReader = new FileMsgBerReader<Message<?>>(berFile, msgFactory);
		}
		// Read X36 messages from the ber file
		while ((msg = berReader.readBER()) != null) {
			// If the version of X36 message present in the ber file is not latest, convert it to latest
			// X36
			if (stepByStepConverter != null && !isLatestX36Version) {
				try {
					log.info(String.format("Converting <%s> which is read from the BER file", msg.getClass().getName()));
					msg = (Message<?>) stepByStepConverter.convert(msg, null);
				} catch (final ClassConvertionException c) {
					log.error(new DumpInfo(
							"Unable to convert the class : " + msg.getClass().getName() + " to the latest version", c));
				}
			}
			final X36Message<?> x36Msg = (X36Message<?>) msg;
			x36MsgList.add(x36Msg);
		}
		if (berReader != null) {
			berReader.close();
		}
	}

	public X36SetOfNetworkElement getNetworkElements(final String emId, final String berLoc, final Profile profile,
			final X36SetOfNeId neIDs) throws Exception {

		if (stepByStepConverter == null) {
			assignStepbyStepConverter(profile, emId, neIDs.get(0));

		}
		final X36SetOfNetworkElement nes = new X36SetOfNetworkElement();
		final File berDir = new File(berLoc);
		final File[] berFiles = berDir.listFiles();
		final StringBuffer berPrefix = new StringBuffer();
		berPrefix.append(emId + "_" + neIDs.get(0).getValue());
		final int x36Index = checkForCurrentX36Version(berFiles, berPrefix, profile);
		final int latestX36Index = Integer.parseInt(profile.getProperty(I36PlugIn.PluginProperty.latestX36Index, "0"));
		boolean isLatestVersion = true;
		final String syntaxSeperator = profile.getProperty(I36PlugIn.PluginProperty.x36SyntaxSeparator, "_");
		String msgFactoryClsStr = null;
		if (x36Index != latestX36Index) {
			isLatestVersion = false;
			msgFactoryClsStr = "com.marconi.fusion.X36" + syntaxSeperator + (x36Index - latestX36Index) + ".X36MessageFactory";
		}
		for (final X36NeId ne : neIDs) {

			try {
				nes.add(getNetworkElement(berLoc, msgFactoryClsStr, isLatestVersion, ne, emId));
			} catch (final Exception e) {
				log.error(String.format("Cannot get NetworkElement Info for Neid %d in Em: %s", ne.getValue(), emId));
				continue;
			}

		}

		return nes;
	}

	private X36MsgGetReportNodeConfiguration getNodeConfig(final File[] berFiles, final String emId, final X36NeId x36NeId,
			final boolean isLatestX36Version, final Constructor<?> berFileReaderConstructor, final Object msgFactoryObj,
			final MessageFactory<Message<?>> msgFactory) throws Exception {
		StringTokenizer tokens = null;
		X36MsgGetReportNodeConfiguration nodeConf = null;
		int neID = 0;
		for (int i = 0; i < berFiles.length; i++) {
			// Reinitialization of neId to zero. TR HO49420 & TR HO49407
			neID = 0;
			final File berFile = berFiles[i];
			// Should not consider ber.realigned files
			if (berFile.getName().endsWith("ber")) {
				// Removing extension .ber from the file name
				final String berFileWithoutExtn = berFile.getName().substring(0, berFile.getName().lastIndexOf('.'));
				// If ber file is for NE which is in current SO-EM
				if (berFileWithoutExtn.contains(emId.replace(':', '_'))) {
					tokens = new StringTokenizer(berFileWithoutExtn.split(emId.replace(':', '_'))[1], "_");
					if (tokens.hasMoreTokens()) {
						neID = Integer.parseInt(tokens.nextToken());
					}
				}
				// If it is current realigning NE's ber file
				if (neID == x36NeId.getValue()) {
					nodeConf = getNodeConfig(isLatestX36Version, berFileReaderConstructor, msgFactoryObj, berFile, msgFactory);
					break;
				}
			}
		}
		return nodeConf;
	}

	private void assignStepbyStepConverter(final Profile profile, final String emId, final X36NeId neId) throws Exception {

		final int latestX36Index = Integer.parseInt(profile.getProperty(I36PlugIn.PluginProperty.latestX36Index, "0"));
		final String berLoc = profile.getProperty(I36PlugIn.PluginProperty.realignmentBerHome);
		final StringBuffer emId_neId = new StringBuffer(emId.replace(':', '_'));
		emId_neId.append("_" + neId.getValue());
		int currentX36Index = 0;

		if (berLoc != null) {
			final File ber = new File(berLoc);
			final File[] berFiles = ber.listFiles();
			if (berFiles != null) {
				currentX36Index = checkForCurrentX36Version(berFiles, emId_neId, profile);
			}
		}
		final String syntaxSeperator = profile.getProperty(I36PlugIn.PluginProperty.x36SyntaxSeparator, "_");

		if (currentX36Index != latestX36Index) {
			this.stepByStepConverter = new StepByStepConverter(latestX36Index, currentX36Index, syntaxSeperator,
					TypeOfConversion.X36, profile.getProperty(PENPDMConverter.ROOT_DIR));

		}

	}

	/**
	 * Check for CurrentX36Version is made to check whether it is latest Version
	 * .
	 * 
	 * @param berFiles
	 * @param emId_neId
	 * @return int
	 */
	private int checkForCurrentX36Version(final File[] berFiles, final StringBuffer emId_neId, final Profile profile) {
		int currentX36Index = 0;

		for (int i = 0; i < berFiles.length; i++) {
			// Should not consider ber.realigned files
			if (berFiles[i].getName().endsWith("ber")) {
				// Removing extension .ber from the file name
				final String berFileWithoutExtn = berFiles[i].getName().substring(0, berFiles[i].getName().lastIndexOf('.'));
				// If it is current realigning NE's (which is present in current SO-EM)ber file
				final String emId = new String(emId_neId);
				// .replace(':', '_')
				if (berFileWithoutExtn.contains(emId.replace(':', '_'))) {
					// Getting the string other than EmID_NeID from the ber file name
					final StringBuffer x36Version = new StringBuffer(berFileWithoutExtn).delete(0, emId_neId.toString().length());
					// X36 version is present in the ber file name if that string is not empty
					if (!x36Version.toString().equals("") && x36Version.length() > 6) {

						log.info("Version of X36 in the BER file is " + x36Version.substring(1, 5));

						currentX36Index = Integer.parseInt(profile.getProperty("PlugIn.X36Index." + x36Version.substring(1, 5),
								"0"));
						break;
					}
					// If X36 version is not present in the ber file name, then read the property SORelease to
					// determine the version of X36
					else {
						final String berFileTMFRelease = profile.getProperty(I36PlugIn.PluginProperty.SORelease, "3_2");
						final String berFileX36Version = profile.getProperty("PlugIn.ber.x36." + berFileTMFRelease);
						if (berFileX36Version != null) {

							log.info("TMF release from which BER file is taken is " + berFileTMFRelease);
							log.info("Version of X36 in the BER file is " + berFileX36Version);

							currentX36Index = Integer.parseInt(profile.getProperty("PlugIn.X36Index." + berFileX36Version, "1"));
						}
					}
				}
			}
		}
		return currentX36Index;
	}

	private X36NetworkElement getNetworkElement(final String berLoc, final String msgFactoryClsStr,
			final boolean isLatestX36Version, final X36NeId x36NeId, final String emId) throws Exception {
		final FileMsgBerReader<Message<?>> berReader = null;
		X36NetworkElement ele = null;

		/*
		 * if (!isLatestX36Version) { // Build the message decoder class string
		 * final String messageDecoderClassStr =
		 * "com.marconi.fusion.base.asn1.msg.io.MessageDecoder";
		 * 
		 * // Load the message decoder class final Class<?> messageDecoderClass
		 * = Class .forName(messageDecoderClassStr);
		 * 
		 * // Get the constructor final Constructor<?> messageDecoderConstructor
		 * = messageDecoderClass .getConstructor(MessageFactory.class);
		 * 
		 * final Object messageDecoderObject = messageDecoderConstructor
		 * .newInstance(msgFactoryObj);
		 * 
		 * // Create instance of FileMsgBerReader final Object
		 * berFileReaderObject = berFileReaderConstructor .newInstance(berFile,
		 * messageDecoderObject); berReader = (FileMsgBerReader<Message<?>>)
		 * berFileReaderObject;
		 * 
		 * } else { berReader = new FileMsgBerReader<Message<?>>(berFile,
		 * msgFactory); }
		 * 
		 * Message<?> msg = null; while ((msg = berReader.readBER()) != null) {
		 * // If the version of X36 message present in the ber file is not //
		 * latest, convert it to latest // X36 if (stepByStepConverter != null
		 * && !isLatestX36Version) { try { log.info(String.format(
		 * "Converting <%s> which is read from the BER file",
		 * msg.getClass().getName())); msg = (Message<?>)
		 * stepByStepConverter.convert(msg, null); } catch (final
		 * ClassConvertionException c) { log.error(new
		 * DumpInfo("Unable to convert the class : " + msg.getClass().getName()
		 * + " to the latest version", c)); } } final X36Message<?> x36Msg =
		 * (X36Message<?>) msg; if (x36Msg instanceof
		 * X36MsgGetReportNodeConfiguration) { final
		 * X36MsgGetReportNodeConfiguration config =
		 * (X36MsgGetReportNodeConfiguration) x36Msg; ele =
		 * config.getBody().getNetworkElement(); } }
		 */

		log.info("Ready to read X36Messages from the BER files");

		MessageFactory<Message<?>> msgFactory = null;
		Constructor<?> berFileReaderConstructor = null;
		Object msgFactoryObj = null;
		File ber = null;
		try {
			if (msgFactoryClsStr != null && !isLatestX36Version) {

				// Load the message factory class
				final Class<?> msgFactoryClass = Class.forName(msgFactoryClsStr);

				// Create an instance of X36MessageFactory
				msgFactoryObj = msgFactoryClass.newInstance();

				// Load the FileMsgBerReader class
				final Class<?> berFileReaderClass = Class.forName("com.marconi.fusion.base.asn1.msg.FileMsgBerReader");

				// Get the constructor of FileMsgBerReader
				berFileReaderConstructor = berFileReaderClass.getConstructor(File.class, MessageDecoder.class);

			} else {
				msgFactory = new X36MessageFactory();
			}
			if (berLoc != null) {
				ber = new File(berLoc);
				final File[] berFiles = ber.listFiles();
				if (berFiles != null) {
					final X36MsgGetReportNodeConfiguration nodConfig = getNodeConfig(berFiles, emId, x36NeId, isLatestX36Version,
							berFileReaderConstructor, msgFactoryObj, msgFactory);

					if (nodConfig == null) {
						log.error(String.format("Unable to get the NEtwrokElement for Ne %d in the EM: %s ", x36NeId.getValue(),
								emId));

					} else {
						ele = nodConfig.getBody().getNetworkElement();
					}
				} else {
					log.error(new DumpInfo("No ber files present in the location: " + berLoc));
					throw new Exception("No ber files present in the location : " + berLoc);
				}
			} else {
				log.error(new DumpInfo("Invalid BER location: " + berLoc));
				throw new Exception("Invalid BER location : " + berLoc);
			}
		} catch (final ClassNotFoundException e) {
			log.error(new DumpInfo("Unable to locate the class : " + msgFactoryClsStr, e));
			throw e;
		} catch (final InstantiationException e) {
			log.error(new DumpInfo("Unable to instantiate the class : " + msgFactoryClsStr, e));
			throw e;
		} catch (final FileNotFoundException e) {
			log.error(new DumpInfo("Unable to locate the BER file : " + e.getLocalizedMessage()));
			throw e;
		} catch (final Exception e) {
			log.error(new DumpInfo("Unable to read messages from BER file", e));
			throw e;
		}

		return ele;
	}

	private X36MsgGetReportNodeConfiguration getNodeConfig(final boolean isLatestX36Version,
			final Constructor<?> berFileReaderConstructor, final Object msgFactoryObj, final File berFile,
			final MessageFactory<Message<?>> msgFactory) throws Exception {
		FileMsgBerReader<Message<?>> berReader = null;
		X36MsgGetReportNodeConfiguration nodeConfig = null;
		Message<?> msg = null;
		if (!isLatestX36Version) {
			// Build the message decoder class string
			final String messageDecoderClassStr = "com.marconi.fusion.base.asn1.msg.io.MessageDecoder";

			// Load the message decoder class
			final Class<?> messageDecoderClass = Class.forName(messageDecoderClassStr);

			// Get the constructor
			final Constructor<?> messageDecoderConstructor = messageDecoderClass.getConstructor(MessageFactory.class);

			final Object messageDecoderObject = messageDecoderConstructor.newInstance(msgFactoryObj);

			// Create instance of FileMsgBerReader
			final Object berFileReaderObject = berFileReaderConstructor.newInstance(berFile, messageDecoderObject);
			berReader = (FileMsgBerReader<Message<?>>) berFileReaderObject;

		} else {
			berReader = new FileMsgBerReader<Message<?>>(berFile, msgFactory);
		}
		// Read X36 messages from the ber file
		while ((msg = berReader.readBER()) != null) {
			// If the version of X36 message present in the ber file is not latest, convert it to latest
			// X36
			if (stepByStepConverter != null && !isLatestX36Version) {
				try {
					log.info(String.format("Converting <%s> which is read from the BER file", msg.getClass().getName()));
					msg = (Message<?>) stepByStepConverter.convert(msg, null);
				} catch (final ClassConvertionException c) {
					log.error(new DumpInfo(
							"Unable to convert the class : " + msg.getClass().getName() + " to the latest version", c));
				}
			}
			final X36Message<?> x36Msg = (X36Message<?>) msg;
			if (x36Msg instanceof X36MsgGetReportNodeConfiguration) {
				nodeConfig = (X36MsgGetReportNodeConfiguration) x36Msg;
				break;
			}
		}
		return nodeConfig;
	}
}

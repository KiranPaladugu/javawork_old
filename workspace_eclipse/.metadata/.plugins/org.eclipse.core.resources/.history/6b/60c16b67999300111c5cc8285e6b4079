package com.marconi.fusion.tmf.i36PlugIn.performance;
/*package com.marconi.fusion.tmf.i38PlugIn;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang.mutable.MutableBoolean;
import org.apache.commons.lang.time.StopWatch;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.marconi.fusion.base.asn1.StringType;
import com.marconi.fusion.base.logging.DumpInfo;
import com.marconi.fusion.base.util.FileUtils;
import com.marconi.fusion.tmf.i38PlugIn.sbi.EmInfo;
import com.marconi.fusion.tmf.i38PlugIn.sbi.EmManager;
import com.marconi.fusion.tmf.plugIn.IEventConsumer;
import com.marconi.fusion.tmf.plugIn.IEventListener;
import com.marconi.fusion.tmf.plugIn.IPerformanceManagement;
import com.marconi.fusion.tmf.plugIn.PlugInException;
import com.marconi.fusion.tmf.plugIn.PlugInExceptionHandler;
import com.marconi.fusion.tmf.plugIn.types.Destination;
import com.marconi.fusion.tmf.plugIn.types.Event;
import com.marconi.fusion.tmf.plugIn.types.EventList;
import com.marconi.fusion.tmf.plugIn.types.FileTransferStatus;
import com.marconi.fusion.tmf.plugIn.types.FileTransferStatusEvent;
import com.marconi.fusion.tmf.plugIn.types.PMParameterNameList;
import com.marconi.fusion.tmf.plugIn.types.PMTPSelectList;
import com.marconi.fusion.tmf.plugIn.types.Time;
import com.marconi.fusion.tmf.tmfFramework.FrameworkProperties;
import com.marconi.fusion.tmf.utilities.Utilities;

public class HistoryDataManager implements IEventListener, Runnable {
	private static final Log LOG = LogFactory.getLog(HistoryDataManager.class);

	static private AtomicInteger uniqueId = new AtomicInteger(0);
	static private final String EORCHARS = "\r\n";
	static private final String FILE_HEADER = "file:";

	I38PlugIn plugin = null;
	//	int sessionId = -1;
	Semaphore semaphore = null;
	int identifier = 0;
	Hashtable<String, FileTransferStatusEvent> fileNames = new Hashtable<String, FileTransferStatusEvent>();
	private Thread runner = null;
	private String destination = "";
	private String userName = "";
	private String password = "";
	private String pmmFileName = "";
	private boolean forceUpload = false;
	private Map<Integer, PMTPSelectList> resources = null;
	private PMParameterNameList pmParameters = null;
	private Time                startTime = null;
	private Time                endTime = null;

	public HistoryDataManager(final I38PlugIn plugin) {
		this.plugin     = plugin;
		//		this.sessionId  = sessionId;
		this.identifier = uniqueId.getAndIncrement();
	}

	public void getHistoryPMData(
			final Destination         destination,
			final StringType          userName,
			final StringType          password,
			final Map<Integer, PMTPSelectList> resources,
			final PMParameterNameList pmParameters,
			final Time                startTime,
			final Time                endTime,
			final boolean             fUpload) throws PlugInException {

		this.destination = destination.getValue();
		this.userName = userName.getValue();
		this.password = password.getValue();

		this.resources = resources;
		this.pmParameters = pmParameters;

		this.startTime = startTime;
		this.endTime = endTime;
		this.forceUpload = fUpload;

		runner = new Thread(this, getClass().getSimpleName() + "-" + identifier);
		runner.setDaemon(true);

		runner.start();
	}


	public void onEvent(final Event event) {

		 * deve essere del tipo FileTransferStatusEvent

		if (!event.isFileTransferStatus()) {
			return;
		}

		final FileTransferStatusEvent ftse = event.getFileTransferStatus();
		if (ftse.getTransferStatus().isFt_in_progress()) {
			return;
		}

		final String fileName = ftse.getFileName().getValue();

		if (fileNames.containsKey(fileName)) {

			 * se c'e' allora e' roba mia
			 * rilascio il semaforo

			fileNames.put(fileName, ftse);
			semaphore.release();
		}
	}


	public void onEvents(final EventList eventList) {
		for (final Event item : eventList) {
			onEvent(item);
		}
	}

	 (non-Javadoc)
	 * @see java.lang.Runnable#run()


	public void run() {
		if (plugin == null) {
			LOG.error("Unable to do work if plugin is null");
			sendNegativeNotification("Internal error");
			return;
		}

		final String wd = plugin.getProfile().getProperty(FrameworkProperties.DirectoryNames.PMM_DIR, ".");
		final File ff = new File(wd);
		if (!ff.exists()) {
			ff.mkdirs();
		}

		boolean success = false;
		//sbi.getCmdPipe().registerPipeConsumer(this);
		LOG.debug(String.format("Collecting information for <%s>: START...", destination));
		try {
			doWork();
			sendPositiveNotification();
			success = true;
		} catch (final PlugInException e) {
			LOG.error(new DumpInfo("Unable to complete retrivelHistoryData", e));
			sendNegativeNotification(e.getMessage());

		} catch (final Exception e) {
			LOG.error(new DumpInfo("Generic exception in retrieval history data", e));
			sendNegativeNotification("Internal error");
		} finally {
			LOG.debug(String.format("Collecting information for <%s>: DONE with %s.",
					destination,
					(success) ? "SUCCESS": "FAILURE"));
		}
	}

	public void doWork() throws PlugInException {
		if (resources.size() == 0) {
			return;
		}

		final StopWatch watch = new StopWatch();
		watch.start();

		final int permits = resources.size() - 1;
		semaphore = new Semaphore(-permits);

		final String wDir = plugin.getProfile().getProperty(FrameworkProperties.DirectoryNames.PMM_DIR, ".");
		//EmManager pluginMgr = plugin.getSBI().getEmManager();
		final EmManager pluginMgr = plugin.getSBIClient().getEmManager();

		final List<EventConsumerPipe> consumers = new ArrayList<EventConsumerPipe>();
		int index = 0;
		for (final Integer emId : resources.keySet()) {
			final PMTPSelectList selectList = resources.get(emId);

			try {
				//EmPlugIn emPlugin = pluginMgr.getPlugIn(emId);
				final EmInfo emPlugin = pluginMgr.getEmInfo(emId);
				//	        	IEventConsumer eventConsumer = emPlugin.getPlugIn().getEventConsumer();
				final IEventConsumer eventConsumer = pluginMgr.getPlugIn(emId).getEventConsumer();
				if (eventConsumer instanceof EventConsumerPipe) {
					final EventConsumerPipe pipe = (EventConsumerPipe) eventConsumer;

					pipe.addListener(this);
					consumers.add(pipe);
				} else {
					LOG.error("Unable to prform getHistoryPMData on EM <" + emId + ">");
					semaphore.release();
					continue;
				}

				final String fileName = FILE_HEADER + wDir + "/" + emPlugin.getEMName() + "." + identifier + "." + index++;

				final Destination newDestination = new Destination(fileName);

				final IPerformanceManagement mgr = pluginMgr.getPerformanceManagementMgr(emId);

				LOG.debug(String.format("Launch getHistory for destination <%s> on EM <%s>",
						newDestination.getValue(), emPlugin.getEMName()));

				mgr.getHistoryPMData(
						newDestination,
						new StringType(userName),
						new StringType(password),
						selectList,
						pmParameters,
						startTime,
						endTime,
						forceUpload);

				fileNames.put(fileName, new FileTransferStatusEvent());
			} catch (final Exception ex) {
				LOG.error(new DumpInfo("Unable to get historyData from em <" + emId + ">", ex));
				semaphore.release();
			}
		}
		try {
			semaphore.acquire();
		} catch (final InterruptedException e) {
			LOG.warn("Get historyData interrupted");
			throw PlugInExceptionHandler.internalError(e.getMessage());
		}

		final StringBuilder buffer = new StringBuilder();

		if (LOG.isDebugEnabled()) {
			buffer.append("REPORT for getHistoryData(");
			buffer.append(getClass().getSimpleName()).append("#"+identifier+")\n\n");
			buffer.append("Reported PMM in file ").append(destination).append("\n");
			buffer.append("from:\n");
		}


		pmmFileName = wDir + "/" + plugin.getName() + "." + identifier;
		final String ext = FilenameUtils.getExtension(destination);
		if (ext.length() > 0) {
			pmmFileName += "." + ext;
		}

		final MutableBoolean compressed = new MutableBoolean();
		try {
			final OutputStream output = Utilities.getOutputStream(pmmFileName, false, plugin.getProfile(), compressed);
			//        	String firstLine = plugin.getProfile().getProperty(FrameworkProperties.Global.PMM_FILE_FIRST_LINE);
			//        	if (firstLine != null)
			//        		processFile(output, firstLine, false);
			//        	else
			//        		log.warn(String.format("Property <%s> not found: resulting file will be without first line.", FrameworkProperties.Global.PMM_FILE_FIRST_LINE));


			 * quando sono qui allora ho ricevuto tutte le notifiche
			 * nella tabella ho i risultati che mi permettono di stampre un report

			boolean skipFirstLine = false;
			int failure = 0;
			for (final String target : fileNames.keySet()) {
				final String fileName = new String(target.substring(FILE_HEADER.length()));

				final FileTransferStatusEvent ftse = fileNames.get(target);

				if (LOG.isDebugEnabled()) {
					buffer.append("file ").append(fileName);
				}

				if ((ftse == null) || ftse.getTransferStatus().isFt_failed()) {
					failure++;
					if (LOG.isDebugEnabled()) {
						buffer.append(" NOT retrieved (");
						buffer.append(ftse.getFailureReason().getValue() + ")\n");
					}
					continue;
				}
				if (LOG.isDebugEnabled()) {
					buffer.append(" successfully retrieved");
				}

				try {
					processFile(output, fileName, skipFirstLine);
					skipFirstLine = true;
					if (LOG.isDebugEnabled()) {
						buffer.append(" and processed\n");
					}
				} catch (final Exception e) {
					failure++;
					//					ftse.gettransferStatus().setft_failed();
					//					ftse.getfailureReason().set(e.getMessage());
					if (LOG.isDebugEnabled()) {
						buffer.append(" but NOT processed (");
						buffer.append(e.getMessage() + ")\n");
					}
				}
			}

			output.close();

			if (failure < fileNames.size()) {
				try {
					Utilities.sendData(destination, userName, password, pmmFileName, compressed.booleanValue());
				} catch (final Exception e) {
					LOG.error(new DumpInfo(String.format("Unable to send data to <%s>", destination), e));
					throw PlugInExceptionHandler.internalError(e.getMessage());
				}
			} else {
				final String cause = String.format("Failed %d/%d request: global request fails", failure, failure);
				throw PlugInExceptionHandler.internalError(cause);
			}
		} catch (final Exception e) {
			LOG.error(new DumpInfo("Failed due to...", e));
			final String cause = String.format("Failed due to <%s>", e.getMessage());
			throw PlugInExceptionHandler.internalError(cause);

		} finally {
			for (final EventConsumerPipe pipe : consumers) {
				pipe.removeListener(this);
			}
			clean();
		}
		watch.stop();
		buffer.append("\nExcecution time: " + watch.toString());

		if (LOG.isDebugEnabled()) {
			LOG.debug(buffer.toString());
		}
	}

	private void clean() {
		boolean flag = plugin.getProfile().getBoolProperty(I38Profile.Key.PMM_DELETE_FILE_AFTER_SEND, true);
		if (flag) {
			if (!FileUtils.delete(pmmFileName)) {
				LOG.warn(String.format("Unable to delete file <%s>", pmmFileName));
			}
		}

		flag = plugin.getProfile().getBoolProperty(I38Profile.Key.PMM_DELETE_TEMPORARY_FILES, true);

		if (flag) {
			for (String fileName : fileNames.keySet()) {
				fileName = new String(fileName.substring(FILE_HEADER.length()));
				final File ff = new File(fileName);
				if (!ff.delete()) {
					LOG.warn(String.format("Unable to delete file <%s>", fileName));
				}
			}
		}

	}

	private void processFile(final OutputStream output, final String source, final boolean skipFirstLine)  throws Exception {
		boolean skipFirstLine1 =  skipFirstLine;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(source);
			final InputStreamReader isr = new InputStreamReader(fis);
			final LineNumberReader lnr = new LineNumberReader(isr);

			String line = null;
			while ((line = lnr.readLine()) != null) {
				//				int ln = lnr.getLineNumber();
				if (skipFirstLine1 && (lnr.getLineNumber() == 1)) {
					skipFirstLine1 = false;
					continue;
				}

				output.write(line.getBytes());
				output.write(EORCHARS.getBytes());
			}
		} finally {
			if (fis != null) {
				fis.close();
			}
		}

	}

	private void sendPositiveNotification() {
		final FileTransferStatusEvent ftse = new FileTransferStatusEvent();

		ftse.setFileName(destination);
		ftse.setPercentComplete(100);
		ftse.setTransferStatus(FileTransferStatus.ft_completed);

		final Event evt = new Event();
		evt.setFileTransferStatus(ftse);

		plugin.getEventConsumer().pushEvent(evt);
	}

	private void sendNegativeNotification(final String cause) {
		final FileTransferStatusEvent ftse = new FileTransferStatusEvent();

		ftse.setFileName(destination);
		ftse.setPercentComplete(0);
		ftse.setTransferStatus(FileTransferStatus.ft_failed);
		ftse.setFailureReason(cause);

		final Event evt = new Event();
		evt.setFileTransferStatus(ftse);

		plugin.getEventConsumer().pushEvent(evt);
	}
}
*/
/**
 * File: I38Database.java
 */
package com.marconi.fusion.tmf.i38PlugIn.db2;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.commons.lang.time.DurationFormatUtils;
import org.apache.commons.lang.time.StopWatch;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.marconi.fusion.X38.X38CircuitName;
import com.marconi.fusion.X38.X38EMId;
import com.marconi.fusion.X38.X38Layer;
import com.marconi.fusion.X38.X38LinkName;
import com.marconi.fusion.X38.X38NEPattern;
import com.marconi.fusion.X38.X38PathName;
import com.marconi.fusion.X38.X38SNId;
import com.marconi.fusion.X38.X38SNName;
import com.marconi.fusion.X38.X38TTPName;
import com.marconi.fusion.base.application.WrongInitializationException;
import com.marconi.fusion.base.logging.DumpInfo;
import com.marconi.fusion.base.util.Utility;
import com.marconi.fusion.tmf.additionalInformation.AdditionalInfoUtils;
import com.marconi.fusion.tmf.additionalInformation.DBAdditionalInfoUtilities;
import com.marconi.fusion.tmf.additionalInformation.LinkInformation;
import com.marconi.fusion.tmf.additionalInformation.SetOfSncInformation;
import com.marconi.fusion.tmf.agnosticInfo.AIOchId;
import com.marconi.fusion.tmf.db.DBAlarmEvent;
import com.marconi.fusion.tmf.db.DBCall;
import com.marconi.fusion.tmf.db.DBConnection;
import com.marconi.fusion.tmf.db.DBConnectionTerminationPoint;
import com.marconi.fusion.tmf.db.DBCrossConnectableTp;
import com.marconi.fusion.tmf.db.DBCrossConnection;
import com.marconi.fusion.tmf.db.DBCtp;
import com.marconi.fusion.tmf.db.DBEms;
import com.marconi.fusion.tmf.db.DBFtp;
import com.marconi.fusion.tmf.db.DBIterator;
import com.marconi.fusion.tmf.db.DBLinkableTp;
import com.marconi.fusion.tmf.db.DBManagedElement;
import com.marconi.fusion.tmf.db.DBMultiLayerSNPP;
import com.marconi.fusion.tmf.db.DBMultiLayerSNPPLink;
import com.marconi.fusion.tmf.db.DBObject;
import com.marconi.fusion.tmf.db.DBPortTp;
import com.marconi.fusion.tmf.db.DBPtp;
import com.marconi.fusion.tmf.db.DBRouteDescriptor;
import com.marconi.fusion.tmf.db.DBSnc;
import com.marconi.fusion.tmf.db.DBSncConnectableTp;
import com.marconi.fusion.tmf.db.DBSubnetwork;
import com.marconi.fusion.tmf.db.DBTopologicalLink;
import com.marconi.fusion.tmf.db.DBTp;
import com.marconi.fusion.tmf.db.Database;
import com.marconi.fusion.tmf.db.Predicate;
import com.marconi.fusion.tmf.db.Session;
import com.marconi.fusion.tmf.i36PlugIn.AbstractBase;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.ClientSNCData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.RouteDescriptorSupport;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.SNCUtils;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.SetOfClientSNCData;
import com.marconi.fusion.tmf.i38PlugIn.converter2.Converter;
import com.marconi.fusion.tmf.i38PlugIn.ctp.CtpManager;
import com.marconi.fusion.tmf.i38PlugIn.sbi.I38SBIUtils;
import com.marconi.fusion.tmf.i38PlugIn.sbi.X38SBIClient;
import com.marconi.fusion.tmf.iterator.Iterator;
import com.marconi.fusion.tmf.naming.Naming;
import com.marconi.fusion.tmf.plugIn.PlugInException;
import com.marconi.fusion.tmf.plugIn.PlugInExceptionHandler;
import com.marconi.fusion.tmf.plugIn.types.AlarmOrTCAId;
import com.marconi.fusion.tmf.plugIn.types.CallDn;
import com.marconi.fusion.tmf.plugIn.types.CrossConnect;
import com.marconi.fusion.tmf.plugIn.types.EMS;
import com.marconi.fusion.tmf.plugIn.types.EMSDn;
import com.marconi.fusion.tmf.plugIn.types.LinkDn;
import com.marconi.fusion.tmf.plugIn.types.MEDn;
import com.marconi.fusion.tmf.plugIn.types.MEId;
import com.marconi.fusion.tmf.plugIn.types.MLSNPPDn;
import com.marconi.fusion.tmf.plugIn.types.MLSNPPLinkDn;
import com.marconi.fusion.tmf.plugIn.types.ManagedElement;
import com.marconi.fusion.tmf.plugIn.types.MultiLayerSubnetwork;
import com.marconi.fusion.tmf.plugIn.types.PerceivedSeverityList;
import com.marconi.fusion.tmf.plugIn.types.PointDn;
import com.marconi.fusion.tmf.plugIn.types.PointDnList;
import com.marconi.fusion.tmf.plugIn.types.Route;
import com.marconi.fusion.tmf.plugIn.types.RouteDescriptor;
import com.marconi.fusion.tmf.plugIn.types.SNCDn;
import com.marconi.fusion.tmf.plugIn.types.SNCDnList;
import com.marconi.fusion.tmf.plugIn.types.SNDn;
import com.marconi.fusion.tmf.plugIn.types.SubnetworkConnection;
import com.marconi.fusion.tmf.plugIn.types.TPDn;
import com.marconi.fusion.tmf.plugIn.types.TerminationPoint;
import com.marconi.fusion.tmf.plugIn.types.TopologicalLink;
import com.marconi.fusion.tmf.plugIn.types.Topology;
import com.marconi.fusion.tmf.predicate.LinkAlarmPredicate;
import com.marconi.fusion.tmf.predicate.SNCAlarmPredicate;
import com.marconi.fusion.tmf.tmfFramework.EmsInformation;
import com.marconi.fusion.tmf.tmfFramework.TmfNameUtilities;
import com.marconi.fusion.tmf.tmfFramework.db.DBAutoClosingItr;
import com.marconi.fusion.tmf.tmfFramework.db.DBDumper;
import com.marconi.fusion.tmf.tmfFramework.db.DatabaseSupport;
import com.marconi.fusion.tmf.tmfFramework.db.NotificatorsManager;
import com.marconi.fusion.tmf.tmfFramework.db.filter.NotPredicate;
import com.marconi.fusion.tmf.tmfFramework.db.filter.SeverityListPredicate;
import com.marconi.fusion.tmf.tmfFramework.db.processor.Processor;
import com.marconi.fusion.tmf.utils.CrossConnectionHelper;
import com.marconi.fusion.tmf.utils.TpUtils;

/**
 * @author mercurio
 *
 */
public class I38Database extends AbstractBase {
	private static final Log LOG = LogFactory.getLog(I38Database.class);

	private static final String DATABASE_MANAGER_PROPS = "DatabaseManager.properties";
	public static final String  DATABASE_ERROR_STRING  = "Database Error.";

	// private I38SBI sbi = null;
	private X38SBIClient sbi = null;
	private Database tmfDatabase = null;
	private I38DatabaseManager manager = null;
	private IndexManager indexes = null;

	protected boolean notificationEnabled = true;

	private MECache meCache = null;

	public DBDumper getDumper() {
		return new DBDumper(name(), tmfDatabase);
	}

	public Database getDatabase() {
		return tmfDatabase;
	}

	public IndexManager getIndexes() {
		return indexes;
	}

	public boolean isNotificationEnabled() {
		return notificationEnabled;
	}

	public void setNotificationEnabled(final boolean notificationEnabled) {
		this.notificationEnabled = notificationEnabled;
	}

	public void dump() {
		manager.dump();
	}

	@Override
	public String name() {
		return AbstractBase.makeName("X38-DATABASE", sbi.name());
	}

	// public I38Database(final Database tmfDatabase, final I38SBI sbi) {
	public I38Database(final Database tmfDatabase, final X38SBIClient sbi) {
		//super(AbstractBase.makeName("X38-DATABASE", sbi.name()));
		this.sbi = sbi;
		this.tmfDatabase = tmfDatabase;
	}

	public void init() throws WrongInitializationException {
		LOG.info(format("Initialize X38 Database..."));

		if (tmfDatabase == null) {
			LOG.error(format("Invalid Database."));
			throw new WrongInitializationException("Invalid Database.");
		}

		try {
			LOG.info(format("Initialize DatabaseManager..."));
			final Properties databaseProperties = Utility.getProperties(I38DatabaseManager.class.getResource(DATABASE_MANAGER_PROPS));
			manager = new I38DatabaseManager(tmfDatabase, databaseProperties, sbi);
			indexes = new IndexManager(manager);
			//manager.setEventManager(sbi.getEventManager());

			LOG.info(format("Initialize base objects..."));
			initDBObject();

			LOG.info(format("X38 Database initialization completed."));
		} catch (final Exception ex) {
			LOG.error(format(ex));
			throw new WrongInitializationException("Database initialization error.");
		}
	}

	public void shutdown() {
		LOG.info(format("Shutdown X38 Database..."));
	}

	public Session beginSession(final boolean update) throws PlugInException {
		if (manager == null) {
			LOG.error(format("Invalid DatabaseManager."));
			throw PlugInExceptionHandler.internalError("Invalid DatabaseManager.");
		}

		if (manager.getSession() != null) {
			LOG.error(format("Session already opened."));
			throw PlugInExceptionHandler.internalError("Database Error.");
		}

		try {
			final Session session = manager.beginSession(update);
			NotificatorsManager.getNotificator().setNotificationEnabled(notificationEnabled);
			return session;
		} catch (final Exception ex) {
			LOG.error(format(ex));
			throw PlugInExceptionHandler.internalError(DATABASE_ERROR_STRING);
		}
	}

	public void commitSession() {
		final Session session = manager.getSession();
		synchronized(session)// Fix for HN79439
		{
			if (session == null) {
				return;
			}
			try {
				// Fix for HN79439
				if (session != null && !session.isTerminated()) {
					session.commit();
				}
			} catch (final Exception ex) {
				LOG.error(format(ex));
			} finally {
				// Fix for HN79439
				if (session != null && !session.isTerminated()) {
					session.terminate();
				}
			}
		}

	}

	public void checkpointSession() {
		final Session session = manager.getSession();
		if (session == null) {
			return;
		}
		try {
			session.checkpoint();
		} catch (final Exception ex) {
			LOG.error(format(ex));
			session.terminate();
		}
	}

	public void terminateSession() {
		final Session session = manager.getSession();
		if (session == null) {
			return;
		}
		try {
			session.abort();
		} catch (final Exception ex) {
			LOG.error(format(ex));
		} finally {
			session.terminate();
		}
	}

	public Session getSession() {
		return tmfDatabase.getSession();
	}

	public boolean isValidSession() {
		return manager.getSession() != null;
	}

	public void buildMECache() throws Exception {
		if (meCache != null) {
			//throw new Exception("MECache already loaded.");
			LOG.warn("MECache already loaded.");
		}
		meCache = new MECache();

		final StopWatch watch = new StopWatch();
		watch.start();

		LOG.info(format("#### Building ManagedElement cache..."));

		try {
			sbi.getDatabase().beginSession(false);
			final List<MEHolder> holders = getManagedElements();
			for (final MEHolder holder : holders) {
				MEData data = holder.getData();
				if (data != null) {
					meCache.put(holder.getSyntax().getName(), data.getEMId(), data.getX38SNName());
				}
			}
		} finally {
			sbi.getDatabase().terminateSession();
		}

		watch.stop();
		LOG.info(format("#### ManagedElement cache loaded in %s", DurationFormatUtils.formatDurationHMS(watch.getTime())));
		meCache.dump();
	}

	public MECache getMECache(){
		return meCache;
	}

	public DBEms getDBEms() throws Exception {
		return manager.getEMS(new EMSDn());
	}

	public DBSubnetwork getDBSubnetwork(final SNDn dn) throws Exception {
		return manager.getSubnetwork(dn);
	}

	/**
	 * Ritorna un iteratore che si chiude alla chiusura (commit o abort) della sessione.
	 */
	private Iterator<DBSubnetwork> getDBSubnetworks() throws Exception {
		final DBEms dbEms = manager.getEMS(new EMSDn());
		if (dbEms == null) {
			return null;
		}
		final Iterator<DBSubnetwork> itr = new DBAutoClosingItr<DBSubnetwork>(dbEms.getSubnetworks().iterator(), getSession());
		return itr;
	}

	public DBSubnetwork[] getDBSubnetworkList() throws Exception {
		final List<DBSubnetwork> v = new ArrayList<DBSubnetwork>();
		for (final Iterator<DBSubnetwork> itr = getDBSubnetworks(); itr.hasNext(); ) {
			v.add(itr.next());
		}
		final DBSubnetwork[] out = new DBSubnetwork[v.size()];
		return v.toArray(out);
	}

	public DBManagedElement create(final DBSubnetwork sn, final ManagedElement item, final MEData data) throws Exception {
		final DBManagedElement out = manager.createManagedElement(item);
		//Associated DBManagedElements to Subnetwork
		sn.getMEs().add(out);
		if (out != null) {
			if(out.getAdditionalInformation(MEData.NAME)!=null) {
				out.setAdditionalInformation(data);
			} else {
				out.addAdditionalInformation(data);
			}

			for (final X38Layer layer : MEData.getManagedLayers()) {
				final X38SNId snId = data.getX38SNId(layer);
				if (snId != null) {
					indexes.set(snId, out);
				}
			}
		}
		return out;
	}

	/**
	 * This method associates routeDescriptor with DBConnection
	 * 
	 * @param dbConn
	 * @param support
	 * @return DBRouteDescriptor
	 * @throws Exception
	 */
	public DBRouteDescriptor create(final DBConnection dbConn, final RouteDescriptorSupport support) throws Exception {
		// Constructed RouteDescriptor object using RouteDescriptorSupport
		final RouteDescriptor routeDescriptor = new RouteDescriptor();
		routeDescriptor.set(support);
		final DBRouteDescriptor out = manager.createRouteDescriptor(routeDescriptor);
		for (final DBCrossConnection dbCC : support.getDBCrossConnections()) {
			out.getCrossConnections().add(dbCC);
		}
		out.getSnc().set(dbConn);
		return out;
	}

	public DBRouteDescriptor create(final DBSnc dbSnc, final RouteDescriptorSupport support) throws Exception {
		// Constructed RouteDescriptor object using RouteDescriptorSupport
		final RouteDescriptor routeDescriptor = new RouteDescriptor();
		routeDescriptor.set(support);
		final DBRouteDescriptor out = manager.createRouteDescriptor(routeDescriptor);
		for (final DBCrossConnection dbCC : support.getDBCrossConnections()) {
			out.getCrossConnections().add(dbCC);
		}
		out.getSnc().set(dbSnc);
		return out;
	}

	public void set(final DBManagedElement dbManagedElement, final ManagedElement item) {
		manager.set(dbManagedElement, item);
	}

	public void delete(final DBManagedElement item) throws Exception {
		final MEDn dn = item.getDn();
		manager.delete(item);
		uncache(dn);
	}

	public void delete(final MEDn dn) throws Exception {
		manager.delete(dn);
		uncache(dn);
	}

	/**
	 * Move to create
	 */
	@Deprecated
	public void cache(final MEDn dn, final MEData data) {
		if (meCache != null) {
			meCache.put(dn, data.getEMId(), data.getX38SNName());
		}
	}

	private void uncache(final MEDn dn) {
		if (meCache != null) {
			meCache.remove(dn);
		}
	}

	public void update(final X38SNName oldName, final X38SNName newName) {
		if (meCache != null) {
			try {
				//    			meCache.dump();
				//    			log.debug(String.format("##UPDATE [%s] -> [%s]", format(oldName), format(newName)));
				meCache.update(oldName, newName);
				//    			meCache.dump();
			} catch (final Exception ex) {
				LOG.error(format(ex));
			}
		}
	}

	public int getEMId(final MEId meId) throws PlugInException {
		try {
			beginSession(false);
			final MEHolder holder = getManagedElement(meId);
			if (holder != null) {
				return holder.getData().getEMId();
			}
		} catch (final Exception ex) {
			LOG.error(format(ex));
			throw PlugInExceptionHandler.internalError(DATABASE_ERROR_STRING);
		} finally {
			terminateSession();
		}
		return -1;
	}

	@Deprecated
	public void processManagedElement(final Predicate<MEHolder> predicate, final Processor<MEHolder> processor) throws Exception {
		final DBSubnetwork[] dbSubnetworks = getAllSubnetworks();

		for (final DBSubnetwork dbSubnetwork : dbSubnetworks) {
			final DBManagedElement[] dbMEs = getAllManagedElements(dbSubnetwork);

			for (final DBManagedElement dbManagedElement : dbMEs) {
				final MEHolder holder = new MEHolder(dbManagedElement);
				if (predicate.match(holder)) {
					processor.process(holder);
				}
			}
		}
	}

	public DBManagedElement getDBManagedElement(final MEDn meDn) throws Exception {
		return manager.getManagedElement(meDn);
	}

	/*
	 * public List<MEHolder> getManagedElements() throws Exception {
	 * List<MEHolder> out = new ArrayList<MEHolder>();
	 * 
	 * for (Iterator<DBSubnetwork> itr = getDBSubnetworks(); itr.hasNext(); ) {
	 * DBSubnetwork dbSubnetwork = itr.next(); Iterator<DBManagedElement> itrMEs
	 * = new
	 * DBAutoClosingItr<DBManagedElement>(dbSubnetwork.getMEs().iterator(),
	 * getSession()); while (itrMEs.hasNext()) { DBManagedElement dbME =
	 * itrMEs.next(); out.add(new MEHolder(dbME)); } }
	 * 
	 * return out; }
	 */
	public List<MEHolder> getManagedElements() throws Exception {
		final List<MEHolder> out = new ArrayList<MEHolder>();
		for (final Iterator<DBSubnetwork> itr = getDBSubnetworks(); itr.hasNext();) {
			final DBObject dbObject = itr.next();
			if (dbObject instanceof DBSubnetwork) {
				final DBSubnetwork dbSubnetwork = (DBSubnetwork) dbObject;
				final Iterator<DBManagedElement> itrMEs = new DBAutoClosingItr<DBManagedElement>(dbSubnetwork.getMEs().iterator(),
						getSession());
				while (itrMEs.hasNext()) {
					final DBObject dbME = itrMEs.next();
					if (dbME instanceof DBManagedElement) {
						out.add(new MEHolder((DBManagedElement) dbME));
					}
				}
			}
		}
		return out;
	}

	public List<MEHolder> getManagedElements(final SNDn snDn) throws Exception {
		final List<MEHolder> out = new ArrayList<MEHolder>();

		final DBSubnetwork dbSubnetwork = manager.getSubnetwork(snDn);
		final Iterator<DBManagedElement> itr = new DBAutoClosingItr<DBManagedElement>(dbSubnetwork.getMEs().iterator(), getSession());
		while (itr.hasNext()) {
			out.add(new MEHolder(itr.next()));
		}

		return out;
	}

	public MEHolder getManagedElement(final MEDn meDn) throws Exception {
		final DBManagedElement item = manager.getManagedElement(meDn);
		if (item == null) {
			return null;
		}
		return new MEHolder(item);
	}

	public MEHolder getManagedElement(final MEId meId) throws Exception {
		final MEDn meDn = new MEDn();
		meDn.setMe(meId);
		return getManagedElement(meDn);
	}

	public MEHolder getManagedElement(final TPDn tpDn) throws Exception {
		final MEDn meDn = new MEDn();
		meDn.setMe(tpDn.getMe());
		return getManagedElement(meDn);
	}

	public MEHolder findManagedElement(final X38SNName snName) throws Exception {
		if (meCache != null) {
			final MEDn dn = meCache.get(snName);

			if (dn == null) {
				return null;
			}
			return getManagedElement(dn);
		}
		return findManagedElement(new MatchSNName(snName));
	}


	public List<MEHolder> findManagedElements(final X38EMId emId) throws Exception {
		if (meCache != null) {
			final List<MEHolder> out = new ArrayList<MEHolder>();

			final List<MEDn> list = meCache.get(emId.getValue());
			for (final MEDn dn : list) {
				final MEHolder holder = getManagedElement(dn);
				if (holder == null) {
					LOG.error(format("Cannot find Managed Element in DB:", dn));
				} else {
					out.add(holder);
				}
			}
			return out;
		}
		return findManagedElements(new MatchEMId(emId.getValue()));
	}

	public List<MEHolder> findManagedElements(final X38NEPattern pattern) throws Exception {
		if (meCache != null) {
			if (!pattern.isPresentLongNEName()) {
				LOG.error(format("Invalid NEPattern:", pattern));
				throw new Exception("Invalid NEPattern.");
			}
			//			if (pattern.isPresentshortNEName()) {
			//				log.error(format("Invalid NEPattern:", pattern));
			//				throw new Exception("Invalid NEPattern.");
			//			}
			if (!pattern.isPresentNeSuffix()) {
				LOG.error(format("Invalid NEPattern:", pattern));
				throw new Exception("Invalid NEPattern.");
			}

			final List<MEHolder> out = new ArrayList<MEHolder>();

			final List<MEDn> list = meCache.get(pattern.getLongNEName().getValue(), pattern.getNeSuffix().getValue());
			for (final MEDn dn : list) {
				final MEHolder holder = getManagedElement(dn);
				if (holder == null) {
					LOG.error(format("Cannot find Managed Element in DB:", dn));
				} else {
					out.add(holder);
				}
			}
			return out;
		}
		return findManagedElements(new MatchNEPattern(pattern));
	}

	@Deprecated
	public List<MEHolder> findManagedElements(final Predicate<MEHolder> predicate) throws Exception {
		final List<MEHolder> out = new ArrayList<MEHolder>();

		final DBSubnetwork[] dbSubnetworks = getAllSubnetworks();
		for (final DBSubnetwork dbSubnetwork : dbSubnetworks) {
			final DBManagedElement[] dbMEs = dbSubnetwork.getMEs().toArray();

			for (final DBManagedElement dbManagedElement : dbMEs) {
				final MEHolder holder = new MEHolder(dbManagedElement);
				if (predicate.match(holder)) {
					out.add(holder);
				}
			}
		}
		return out;
	}

	@Deprecated
	private MEHolder findManagedElement(final Predicate<MEHolder> predicate) throws Exception {
		final DBSubnetwork[] dbSubnetworks = getAllSubnetworks();
		for (final DBSubnetwork dbSubnetwork : dbSubnetworks) {
			final DBManagedElement[] dbMEs = dbSubnetwork.getMEs().toArray();

			for (final DBManagedElement dbManagedElement : dbMEs) {
				final MEHolder holder = new MEHolder(dbManagedElement);
				if (predicate.match(holder)) {
					return holder;
				}
			}
		}
		return null;
	}

	public DBPtp create(final TerminationPoint item) throws Exception {
		return manager.createPTP(item);
	}

	public void set(final DBPtp ptp, final TerminationPoint item) throws Exception {
		manager.set(ptp, item);
	}

	public void set(final DBPortTp ptp, final TerminationPoint item) throws Exception {
		manager.set(ptp, item);
	}

	public void delete(final DBPtp ptp) throws Exception {
		manager.delete(ptp);
	}

	public DBPtp getDBPtp(final TPDn ptpDn) throws Exception {
		return manager.getPTP(ptpDn);
	}

	public PTPHolder getPtp(final TPDn ptpOrFtpDn) throws Exception {
		DBPortTp ptp = null;
		if (ptpOrFtpDn.getTp().isPtp()) {
			ptp = getDBPtp(ptpOrFtpDn);
		} else if (ptpOrFtpDn.getTp().isFtp()) {
			ptp = getDBFtp(ptpOrFtpDn);
		}
		if (ptp == null) {
			return null;
		}
		return new PTPHolder(ptp);
	}

	public DBPortTp findDBPtp(final MEDn meDn, final X38TTPName ttpName) throws Exception {
		final DBManagedElement me = manager.getManagedElement(meDn);
		if (me == null) {
			return null;
		}

		final Iterator<DBPortTp> itr = new DBAutoClosingItr<DBPortTp>(me.getPTPs().iterator(), getSession());

		while (itr.hasNext()) {
			final DBPortTp dbPtp = itr.next();
			//PTPData data = PTPData.get(dbPtp.getAdditionalInformations());
			final PTPData data = PTPData.get(dbPtp);
			if (data == null) {
				if (LOG.isDebugEnabled()) {
					LOG.debug(format("PTP without Data: " + dbPtp.getIdentifier().toString()));
				}
			} else {
				if (data.match(ttpName)) {
					return dbPtp;
				}
			}
		}
		return null;
	}

	public DBPortTp findLikeDBPtp(final MEDn meDn, final X38TTPName ttpName) throws Exception {
		final DBManagedElement me = manager.getManagedElement(meDn);
		if (me == null) {
			return null;
		}

		final String name = ttpName.getValue();

		final DBIterator<DBPortTp> itr = me.getPTPs().iterator();
		try {
			while (itr.hasNext()) {
				final DBPortTp dbPtp = itr.next();
				final PTPData data = PTPData.get(dbPtp);
				if (data == null) {
					if (LOG.isDebugEnabled()) {
						LOG.debug(format("PTP without Data: <%s>", Naming.makeValue(dbPtp.getDn())));
					}
				} else {
					if (data.getTTPName().startsWith(name)) {
						return dbPtp;
					} else if (name.startsWith(data.getTTPName())) {
						return dbPtp;
					}
				}
			}
		} finally {
			itr.close();
		}

		return null;
	}

	public DBFtp getDBFtp(final TPDn ftpDn) throws Exception {
		return manager.getFTP(ftpDn);
	}

	public DBTp getDBTP(final TPDn dn) throws Exception {
		return manager.getTP(dn);
	}

	public DBTopologicalLink getDBTopologicalLink(final LinkDn dn) throws Exception {
		return manager.getTopologicalLink(dn);
	}

	/**
	 * This method is used to retreive MLSNPP Object from DB.
	 * 
	 * @param mlsnppDn
	 * @return DBMultiLayerSNPP
	 * @throws Exception
	 */
	public DBMultiLayerSNPP getDBMLSNPP(final MLSNPPDn mlsnppDn) throws Exception {
		return manager.getObject(DBMultiLayerSNPP.class, mlsnppDn);
	}

	/**
	 * This method fetches Call object from DB .
	 * 
	 * @param callDn
	 * @return DBCall
	 * @throws Exception
	 */
	public DBCall getDBCall(final CallDn callDn) throws Exception {
		return manager.getObject(DBCall.class, callDn);
	}

	/**
	 * This method is used to retreive MLSNPPLink object from DB .
	 * 
	 * @param mlsnppLinkDn
	 * @return DBMultiLayerSNPPLink
	 * @throws Exception
	 */
	public DBMultiLayerSNPPLink getDBMLSNPPLink(final MLSNPPLinkDn mlsnppLinkDn) throws Exception {
		return manager.getObject(DBMultiLayerSNPPLink.class, mlsnppLinkDn);
	}

	public LinkHolder getTopologicalLink(final LinkDn dn) throws Exception {
		final DBTopologicalLink item = getDBTopologicalLink(dn);
		if (item == null) {
			return null;
		}
		return new LinkHolder(item);
	}

	public DBTopologicalLink create(final DBSubnetwork dbSubnetwork, final TopologicalLink item) throws Exception {
		if (LOG.isDebugEnabled()) {
			LOG.debug(format(">> CREATE LINK:", item.getName()));
		}
		final DBTopologicalLink tl = manager.createTopologicalLink(item);
		// Add the topological link to the subnetwork
		dbSubnetwork.getTopologicalLinks().add(tl);
		return tl;
	}

	public void delete(final DBTopologicalLink dbTopologicalLink) throws Exception {

		final DBLinkableTp aEnd = dbTopologicalLink.getAEnd().get();
		if (aEnd != null) {
			setEdgePoint(aEnd, true);
		} else {
			LOG.error(format("TopologicalLink without AEnd:", dbTopologicalLink.getDn()));
		}

		final DBLinkableTp zEnd = dbTopologicalLink.getZEnd().get();
		if (zEnd != null) {
			setEdgePoint(zEnd, true);
		} else {
			LOG.error(format("TopologicalLink without ZEnd:", dbTopologicalLink.getDn()));
		}

		final List<DBSnc> associateSncs = findAssociatedClientSncs(dbTopologicalLink);

		if (associateSncs.size() > 0) {
			final I38SBIUtils sbiUtils = new I38SBIUtils(sbi);
			for (final DBSnc associateSnc : associateSncs) {
				if (!sbiUtils.exists(new SNCHolder(associateSnc))) {
					sbi.getDatabase().delete(associateSnc, true);
				} else {
					LOG
					.warn(format(String
							.format(
									"Client SNC <%s> still exists even after the Server Link <%s> is deleted",
									associateSnc.getNativeEMSName()
									.getValue(),
									dbTopologicalLink
									.getNativeEMSName()
									.getValue())));
				}
			}
		}

		dbTopologicalLink.getSubnetwork().get().getTopologicalLinks().remove(dbTopologicalLink);
		manager.delete(dbTopologicalLink);
	}

	private List<DBSnc> findAssociatedClientSncs(final DBTopologicalLink link) throws Exception {

		final List<DBSnc> associatedDBSncs = new ArrayList<DBSnc>();

		final SetOfClientSNCData associatedSncs = (SetOfClientSNCData) link.getAdditionalInformation(SetOfClientSNCData.NAME);

		if (associatedSncs != null) {

			for (final ClientSNCData clientSnc : associatedSncs.getClientSncs()) {
				final SNCHolder sncHolder = getSnc(clientSnc.getPathName());
				if (sncHolder != null) {
					associatedDBSncs.add(sncHolder.getDBObject());
				} else {
					LOG.error(format(String.format("Could not find the SNC <%s> in db which is associated to link <%s> ", link
							.getInformation()
							.getNativeEMSName()
							.getValue(), clientSnc
							.getPathName())));
				}
			}

		}

		if (LOG.isDebugEnabled() && associatedDBSncs.size() > 0) {
			final StringBuilder sb = new StringBuilder(String.format("Associated SNC for link '%s'", link.getInformation()
					.getNativeEMSName().getValue()));
			for (final DBSnc snc : associatedDBSncs) {
				sb.append(String.format("\n  nativeEMSName: '%s' snc: '%s'", snc.getInformation().getNativeEMSName().getValue(),
						Naming.makeValue(snc.getDn())));
			}
			LOG.debug(sb.toString());
		}

		return associatedDBSncs;
	}

	/*
	 * public void deleteCircuitGroup(final DBTopologicalLink dbTopologicalLink)
	 * throws Exception { final DBLinkableTp aEnd =
	 * dbTopologicalLink.getAEnd().get(); if (aEnd != null) { setEdgePoint(aEnd,
	 * true); } else { LOG.error(format("TopologicalLink without AEnd:",
	 * dbTopologicalLink.getDn())); }
	 * 
	 * final DBLinkableTp zEnd = dbTopologicalLink.getZEnd().get(); if (zEnd !=
	 * null) { setEdgePoint(zEnd, true); } else {
	 * LOG.error(format("TopologicalLink without ZEnd:",
	 * dbTopologicalLink.getDn())); }
	 * 
	 * final SetOfSncInformation associatedSncs =
	 * (SetOfSncInformation)dbTopologicalLink
	 * .getAdditionalInformation(SetOfSncInformation.NAME); if (associatedSncs
	 * != null) { final SNCDnList sncDnList = associatedSncs.getSyntax(); for
	 * (final SNCDn sncDn : sncDnList) { final DBSnc dbSnc =
	 * getSnc(sncDn).getDBObject(); deleteLocalSNCs(dbSnc); } }
	 * manager.delete(dbTopologicalLink); }
	 */

	public void deleteCircuitGroup(final DBTopologicalLink dbTopologicalLink) throws Exception {
		final DBLinkableTp aEnd = dbTopologicalLink.getAEnd().get();
		if (aEnd != null) {
			setEdgePoint(aEnd, true);
		} else {
			LOG.error(format("TopologicalLink without AEnd:", dbTopologicalLink.getDn()));
		}

		final DBLinkableTp zEnd = dbTopologicalLink.getZEnd().get();
		if (zEnd != null) {
			setEdgePoint(zEnd, true);
		} else {
			LOG.error(format("TopologicalLink without ZEnd:", dbTopologicalLink.getDn()));
		}

		final SetOfSncInformation associatedSncs = (SetOfSncInformation) dbTopologicalLink
				.getAdditionalInformation(SetOfSncInformation.NAME);
		if (associatedSncs != null) {
			final SNCDnList sncDnList = associatedSncs.getSyntax();
			// fix for TR HP16859 and HP10301
			for (final SNCDn sncDn : sncDnList) {
				final SNCHolder sncHolder = getSnc(sncDn);
				if (sncHolder != null) {
					final DBSnc dbSnc = sncHolder.getDBObject();
					delete(dbSnc, true);
				} else {
					LOG.error(format("Couldn't find local SNC :", TmfNameUtilities.toString(sncDn)));
				}
			}
		}
		manager.delete(dbTopologicalLink);
	}

	public DBTopologicalLink findDBTopologicalLink(final String nativeEMSName) throws Exception {
		final StopWatch stopWatch = new StopWatch();
		stopWatch.start();

		// first of all try using indexes
		final X38LinkName lnName = new X38LinkName(nativeEMSName);
		DBTopologicalLink dbTopologicalLink = indexes.get(lnName);

		if (dbTopologicalLink == null) {
			// using the old method
			final SNDn snDn = sbi.getSNDn();
			final DBSubnetwork dbSubnetwork = getDBSubnetwork(snDn);
			if (dbSubnetwork == null) {
				LOG.error(format("Cannot find Subnetwork:", snDn));
				throw new Exception("Cannot find Subnetwork.");
			}

			final DBIterator<DBTopologicalLink> dbLinks = dbSubnetwork.getTopologicalLinks().iterator();
			try {
				while (dbLinks.hasNext()) {
					dbTopologicalLink = dbLinks.next();
					if (dbTopologicalLink.getInformation().getNativeEMSName().getValue().compareTo(nativeEMSName) == 0) {
						break;
					}
					dbTopologicalLink = null;
				}
			} finally {
				dbLinks.close();
			}
		}

		stopWatch.stop();
		if (LOG.isDebugEnabled()) {
			LOG.debug(format(String.format("TopologicalLink %sfound in %s", dbTopologicalLink == null ? "not " : "",
					DurationFormatUtils.formatDurationHMS(stopWatch.getTime()))));
		}

		return dbTopologicalLink;
	}

	public LinkHolder findTopologicalLink(final String nativeEMSName) throws Exception {
		final DBTopologicalLink item = findDBTopologicalLink(nativeEMSName);
		if (item == null) {
			return null;
		}
		return new LinkHolder(item);
	}

	public DBCtp getDBCtp(final TPDn dn) throws Exception {
		return manager.getCTP(dn);
	}

	public CTPHolder getCtp(final TPDn dn) throws Exception {
		final DBCtp item = getDBCtp(dn);
		if (item == null) {
			return null;
		}
		return new CTPHolder(item);
	}

	public Iterator<DBConnectionTerminationPoint> getPotentialDBCtps(final TPDn dn) throws Exception {
		//return manager.getPotentialCTPs(convert(dn));
		final DBPtp dbPtp = getDBPtp(dn);
		if (dbPtp == null) {
			return null;
		}
		return dbPtp.getCTPs().iterator();
	}

	/**
	 * @deprecated: deve restituire un iteratore.
	 */
	@Deprecated
	public DBCtp[] getInUseDBCtps(final TPDn dn) throws Exception {
		//return manager.getContainedInUseTPs(convert(dn));

		//		DBCtp []elements = getPotentialDBCtps(dn);
		//		List<DBCtp> v = new ArrayList<DBCtp>();
		//		for (DBCtp item : elements)
		//			if (item.isInUse())
		//				v.add(item);
		//		elements = v.toArray(new DBCtp[v.size()]);
		//		return elements;
		final DBPtp dbPtp = getDBPtp(dn);
		if (dbPtp == null) {
			return null;
		}

		final List<DBConnectionTerminationPoint> v = new ArrayList<DBConnectionTerminationPoint>();
		final DBIterator<DBConnectionTerminationPoint> itr = dbPtp.getCTPs().iterator();
		while(itr.hasNext()){
			final DBConnectionTerminationPoint item = itr.next();
			if (isInUse(item)) {
				v.add(item);
			}
		}
		itr.close();
		final DBCtp []elements = v.toArray(new DBCtp[v.size()]);
		return elements;
	}

	/**
	 * Determines whether the given TP is in use or not
	 * 
	 * @param tpObj
	 *            - TP for which the in use state is to be determined
	 * @return TRUE if the TP is in use else FALSE
	 */
	public boolean isInUse(final DBTp tpObj) {
		boolean isInuse = true;
		final TerminationPoint tp = tpObj.getInformation();
		if (tp.getTpMappingMode().isTm_terminated_and_available_for_mapping()) {
			isInuse = true;
		} else if (tp.getConnectionState().isTpcs_na()) {
			isInuse = false;
		} else if (tp.getConnectionState().isTpcs_not_connected()) {
			isInuse = false;
		}
		return isInuse;
	}

	/*
	 * private boolean inUse(DBConnectionTerminationPoint dbCtp){ dbCtp.get }
	 */
	/*
	 * public DBCrossConnection getDBCrossConnection(CCDn dn) { return manager.getCrossConnection(dn); }
	 */

	public DBCrossConnection create(final DBManagedElement me, final CrossConnect info) {
		final DBCrossConnection cc=manager.createCrossConnection(info);
		me.getCrossConnections().add(cc);
		return cc;
	}

	public void delete(final DBCrossConnection dbCC) throws Exception{
		//		dbCC.clearAEnds();
		//    	dbCC.clearZEnds();
		// To fix the TR HK96858
		final CrossConnect cc = new CrossConnect(dbCC.getInformation());
		CrossConnectionHelper.resetDBCrossConnectionIndex(this.tmfDatabase, dbCC.getMe().get(), dbCC);
		manager.delete(dbCC);
		// Update the connection state for every TP involved in the cross connection
		final PointDnList aEndList = cc.getAEndNameList();
		for (final PointDn aEnd : aEndList) {
			updateConnectionState(aEnd.getTpDn());
		}
		final PointDnList zEndList = cc.getZEndNameList();
		for (final PointDn zEnd : zEndList) {
			updateConnectionState(zEnd.getTpDn());
		}
	}

	public void updateConnectionState(final TPDn tpDn) {
		final DBTp dbTp = manager.getTP(tpDn);
		if (dbTp != null) {
			if (dbTp instanceof DBCrossConnectableTp) {
				TpUtils.updateConnectionState((DBCrossConnectableTp<?, ?>) dbTp);
			}
		} else if (LOG.isDebugEnabled())  {
			LOG.debug(new DumpInfo(tpDn,"Cannot find TP involved in XConn, it might have been deleted during port realignment :"));
		}
	}

	public DBSnc create(final SubnetworkConnection item) throws Exception {
		return manager.createSNC(item);
	}

	//HK96858 - fix given for merge problem
	private void delete(final DBSnc dbSnc, final Collection<DBSncConnectableTp<?,?>> connTpList) throws Exception {

		updateCircuitGroupInfo(dbSnc);

		dbSnc.getAEnds().clear();
		dbSnc.getZEnds().clear();

		for (final DBSncConnectableTp<?,?> connTp : connTpList) {
			TpUtils.updateConnectionState((DBCrossConnectableTp<?, ?>) connTp);
		}

		manager.delete(dbSnc);
	}

	private void updateCircuitGroupInfo(final DBSnc dbSnc) {
		final LinkInformation linkInformation = (LinkInformation)dbSnc.getAdditionalInformation(LinkInformation.NAME);
		if (linkInformation != null) {
			final DBTopologicalLink dbLink = manager.getTopologicalLink(linkInformation.getSyntax());
			final SetOfSncInformation associatedSncs = (SetOfSncInformation)dbLink.getAdditionalInformation(SetOfSncInformation.NAME);
			final SNCDnList sncDnList = associatedSncs.getSyntax();
			sncDnList.remove(dbSnc.getDn());
			// TR HL79696
			if (dbLink.getAdditionalInformation(SetOfSncInformation.NAME) != null) {
				dbLink.setAdditionalInformation(new SetOfSncInformation(sncDnList));
			} else {
				dbLink.addAdditionalInformation(new SetOfSncInformation(sncDnList));
			}
			checkpointSession();
			if (sncDnList.isEmpty()) {
				try {
					delete(dbLink);
				} catch (final Exception ex) {
					LOG.warn(format("Cannot delete CircuitGroup:", name));
				}
			}
		}
	}

	public void delete(final DBSnc dbSnc, final boolean deleteCC) throws Exception {
		//HK96858 - fix given for merge problem
		final Collection<DBSncConnectableTp<?, ?>> connTpList = SNCUtils.getTpRoute(dbSnc);
		if (deleteCC) {
			deleteCCs(dbSnc);
		}
		delete(dbSnc, connTpList);
	}

	private void deleteCCs(final DBSnc dbSnc) {
		if (LOG.isDebugEnabled()) {
			LOG.debug(format("Deleting CCs for:", dbSnc.getInformation()));
		}
		if (dbSnc.getRouteDescriptors().size() < 1) {
			LOG.warn(("No route descriptors found for dbSnc : "+TmfNameUtilities.toString(dbSnc.getDn())));
			return;
		}

		final DBIterator<DBRouteDescriptor> dbRDItr = dbSnc.getRouteDescriptors().iterator();
		while (dbRDItr.hasNext()) {
			deleteCCs(dbRDItr.next().getRouteXCs(), null);
		}
		dbRDItr.close();
	}

	public void delete(final DBConnection dbConn, final boolean deleteCC) throws Exception {
		// no need to reset connection state of TP's used in WSON as it is not applicable

		// delete CC's involving in the connection
		if (deleteCC) {
			deleteCCs(dbConn);
		}

		dbConn.getAEndPointsData().clear();
		dbConn.getZEndPointsData().clear();

		// associated route descriptors also get deleted, so no need to delete them explicitly
		manager.delete(dbConn);
	}

	private void deleteCCs(final DBConnection dbConn) {
		LOG.debug(format("Deleting CCs for:", dbConn.getInformation()));
		if (dbConn.getRouteDescriptors().size() < 1) {
			LOG.warn(("No route descriptors found for dbSnc : " + TmfNameUtilities.toString(dbConn.getDn())));
			return;
		}

		final DBIterator<DBRouteDescriptor> dbRDItr = dbConn.getRouteDescriptors().iterator();

		while (dbRDItr.hasNext()) {

			final DBRouteDescriptor dbRd = dbRDItr.next();

			// build CCName <--> DBMe map, to be used for deleting CCs later
			final Map<String, DBManagedElement> ccDBMeMap = new HashMap<String, DBManagedElement>();

			final DBIterator<DBCrossConnection> dbRDCCItr = dbRd.getCrossConnections().iterator();
			while (dbRDCCItr.hasNext()) {
				final DBCrossConnection dbCC = dbRDCCItr.next();
				final String ccName = CrossConnectionHelper.makeCCName(dbCC.getInformation());
				ccDBMeMap.put(ccName, dbCC.getMe().get());
			}
			dbRDCCItr.close();

			deleteCCs(dbRd.getRouteXCs(), ccDBMeMap);
		}
		dbRDItr.close();
	}

	/**
	 * 
	 * @param route
	 * @param ccDBMeMap
	 *            is introduced for WSON, as CC ends are SNPDn in WSON case and
	 *            we cannot get ME using SNPDn. This should be passed as null in
	 *            non WSON case.
	 */
	private void deleteCCs(final Route route, final Map<String, DBManagedElement> ccDBMeMap) {

		final java.util.Iterator<CrossConnect>  routeCCItr = route.iterator();
		while(routeCCItr.hasNext()) {
			final CrossConnect cc = routeCCItr.next();
			try {

				DBManagedElement dbMe = null;

				if (ccDBMeMap != null) {
					dbMe = ccDBMeMap.get(CrossConnectionHelper.makeCCName(cc));
				} else {
					dbMe = sbi.getDatabase().getManagedElement(cc.getAEndNameList().get(0).getTpDn().getMe()).getDBObject();
				}

				final String xConnName=CrossConnectionHelper.makeCCName(cc);
				final DBCrossConnection dbCC = CrossConnectionHelper.getDBCrossConnection(sbi.getDatabase().getDatabase(), dbMe, xConnName);
				if (dbCC == null) {
					LOG.error(format(String.format("Found null DBCrossConnection '%s'.",xConnName)));
					continue;
				}
				// TR HK96858
				if (dbCC.getInformation().getActive().getValue()) { // CC is active
					if (dbCC.getInformation().getDirection().isCd_bi() || dbCC.getRouteDescriptors().size() == 1) { // CC is not broadcast
						dbCC.getInformation().getActive().set(false);	// Deactivate and delete the CC
					} else if (dbCC.getRouteDescriptors().size() == 2) { // If the CC is broadcast (or) unidirectional protected
						final DBRouteDescriptor firstDBRD=dbCC.getRouteDescriptors().get(0);
						//firstDBRD.setUpdated(true);
						final DBRouteDescriptor secondDBRD=dbCC.getRouteDescriptors().get(1);
						//secondDBRD.setUpdated(true);
						if (!(firstDBRD.getInformation().getIntended().getValue() && secondDBRD.getInformation().getIntended().getValue())) { // If
							// both
							// the
							// routes
							// are
							// not
							// intended
							dbCC.getInformation().getActive().set(false); // CC is not broadcast and can be deactivated and deleted
						} else {
							continue; // CC is unidirectional and having two route descriptors which are intended. means broadcast.
						}
					} else { // CC is broadcast (No.of.Route Descriptors are more than 2)
						continue;
					}
				}
				// Fix for TR HO88408
				// Delete only xconn which do not have Fixed = True
				if (!(AdditionalInfoUtils.exists(cc.getAdditionalInfo(), "Fixed", "True"))) {
					LOG.debug(format("Deleting CC:", dbCC.getInformation()));
					sbi.getDatabase().delete(dbCC);
				}

			} catch (final Exception ex) {
				LOG.error(format(ex));
			}
		}
	}

	/*
	 * private void deleteCCs(final DBSnc dbSnc) {
	 * LOG.debug(format("Deleting CCs for:", dbSnc.getInformation()));
	 * if(dbSnc.getRouteDescriptors().size()<1) {
	 * LOG.warn(("No route descriptors found for dbSnc : "
	 * +TmfNameUtilities.toString(dbSnc.getDn()))); return; }
	 * 
	 * final java.util.Iterator<CrossConnect> intendedRouteItr =
	 * dbSnc.getRouteDescriptors().get(0).getRouteXCs().iterator();
	 * while(intendedRouteItr.hasNext()) { final CrossConnect cc =
	 * intendedRouteItr.next(); try { final DBManagedElement
	 * dbMe=sbi.getDatabase
	 * ().getManagedElement(cc.getAEndNameList().get(0).getTpDn
	 * ().getMe()).getDBObject(); final String
	 * xConnName=CrossConnectionHelper.makeCCName(cc); final DBCrossConnection
	 * dbCC = CrossConnectionHelper.getDBCrossConnection(dbMe,xConnName); if
	 * (dbCC == null) {
	 * LOG.error(format(String.format("Found null DBCrossConnection '%s'."
	 * ,xConnName))); continue; } // TR HK96858 if
	 * (dbCC.getInformation().getActive().getValue()) { // CC is active if
	 * (dbCC.getInformation().getDirection().isCd_bi() ||
	 * dbCC.getRouteDescriptors().size() == 1) { // CC is not broadcast
	 * dbCC.getInformation().getActive().set(false); // Deactivate and delete
	 * the CC } else if (dbCC.getRouteDescriptors().size() == 2) { // If the CC
	 * is broadcast (or) unidirectional protected final DBRouteDescriptor
	 * firstDBRD=dbCC.getRouteDescriptors().get(0);
	 * //firstDBRD.setUpdated(true); final DBRouteDescriptor
	 * secondDBRD=dbCC.getRouteDescriptors().get(1);
	 * //secondDBRD.setUpdated(true); if
	 * (!(firstDBRD.getInformation().getIntended().getValue() &&
	 * secondDBRD.getInformation().getIntended().getValue())) { // If both the
	 * routes are not intended dbCC.getInformation().getActive().set(false); //
	 * CC is not broadcast and can be deactivated and deleted } else { continue;
	 * // CC is unidirectional and having two route descriptors which are
	 * intended. means broadcast. } } else { // CC is broadcast (No.of.Route
	 * Descriptors are more than 2) continue; } }
	 * LOG.debug(format("Deleting CC:", dbCC.getInformation()));
	 * sbi.getDatabase().delete(dbCC); } catch (final Exception ex) {
	 * LOG.error(format(ex)); }
	 * 
	 * } if (dbSnc.getRouteDescriptors().size() < 2) { return; }
	 * 
	 * final java.util.Iterator<CrossConnect> backupRouteItr =
	 * dbSnc.getRouteDescriptors().get(1).getRouteXCs().iterator();
	 * while(backupRouteItr.hasNext()) { final CrossConnect cc =
	 * backupRouteItr.next(); try { final DBManagedElement
	 * dbMe=sbi.getDatabase()
	 * .getManagedElement(cc.getAEndNameList().get(0).getTpDn
	 * ().getMe()).getDBObject(); final String
	 * xConnName=CrossConnectionHelper.makeCCName(cc); final DBCrossConnection
	 * dbCC = CrossConnectionHelper.getDBCrossConnection(dbMe,xConnName); if
	 * (dbCC == null) {
	 * LOG.error(format(String.format("Found null DBCrossConnection '%s'."
	 * ,xConnName))); continue; } // TR HK96858 if
	 * (dbCC.getInformation().getActive().getValue()) { // CC is active if
	 * (dbCC.getInformation().getDirection().isCd_bi() ||
	 * dbCC.getRouteDescriptors().size() == 1) { // CC is not broadcast
	 * dbCC.getInformation().getActive().set(false); // Deactivate and delete
	 * the CC } else if (dbCC.getRouteDescriptors().size() == 2) { // If the CC
	 * is broadcast (or) unidirectional protected final DBRouteDescriptor
	 * firstDBRD=dbCC.getRouteDescriptors().get(0);
	 * //firstDBRD.setUpdated(true); final DBRouteDescriptor
	 * secondDBRD=dbCC.getRouteDescriptors().get(1);
	 * //secondDBRD.setUpdated(true); if
	 * (!(firstDBRD.getInformation().getIntended().getValue() &&
	 * secondDBRD.getInformation().getIntended().getValue())) { // If both the
	 * routes are not intended dbCC.getInformation().getActive().set(false); //
	 * CC is not broadcast and can be deactivated and deleted } else { continue;
	 * // CC is unidirectional and having two route descriptors which are
	 * intended. means broadcast. } } else { // CC is broadcast (No.of.Route
	 * Descriptors are more than 2) continue; } }
	 * LOG.debug(format("Deleting CC:", dbCC.getInformation()));
	 * sbi.getDatabase().delete(dbCC); } catch (final Exception ex) {
	 * LOG.error(format(ex)); } }
	 * 
	 * }
	 */
	public void delete(final DBRouteDescriptor dbRouteDescriptor) throws Exception {
		dbRouteDescriptor.getSnc().clear();
		dbRouteDescriptor.getCrossConnections().clear();
		manager.delete(dbRouteDescriptor);
	}

	public DBSnc getDBSnc(final SNCDn sncDn) throws Exception {
		return manager.getSNC(sncDn);
	}

	public SNCHolder getSnc(final SNCDn sncDn) throws Exception {
		final DBSnc snc = manager.getSNC(sncDn);
		if (snc == null) {
			return null;
		}
		return new SNCHolder(snc);
	}

	/*
	 * public void delete(DBSnc dbSnc, boolean deleteCC) throws Exception { if
	 * (deleteCC) { deleteCCs(dbSnc); } delete(dbSnc); }
	 * 
	 * private void deleteCCs(DBSnc dbSnc) {
	 * log.debug(format("Deleting CCs for:", dbSnc.getInformation())); for
	 * (java.util.Iterator<CCDn> itr =
	 * dbSnc.getInformation().getIntendedRoute().iterator(); itr.hasNext(); ) {
	 * CCDn ccDn = itr.next(); try { DBCrossConnection cc =
	 * sbi.getDatabase().getDBCrossConnection(ccDn); if (cc == null) {
	 * log.error(format(String.format("Found null DBCrossConnection '%s'.",
	 * Naming.makeValue(ccDn)), ccDn)); continue; }
	 * 
	 * if (!cc.getInformation().getActive().getValue()) {
	 * log.debug(format("Deleting CC:", cc.getInformation())); if
	 * (cc.getRouteDescriptors().size() == 1) { sbi.getDatabase().delete(cc); }
	 * } } catch (Exception ex) { log.error(format(ex)); } } for
	 * (java.util.Iterator<CCDn> itr =
	 * dbSnc.getInformation().getBackupRoute().iterator(); itr.hasNext(); ) {
	 * CCDn ccDn = itr.next(); try { DBCrossConnection cc =
	 * sbi.getDatabase().getDBCrossConnection(ccDn); if (cc == null) {
	 * log.error(format(String.format("Found null DBCrossConnection '%s'.",
	 * Naming.makeValue(ccDn)), ccDn)); continue; }
	 * 
	 * if (!cc.getInformation().getActive().getValue()) {
	 * log.debug(format("Deleting CC:", cc.getInformation())); if
	 * (cc.getRouteDescriptors().size() == 1) { sbi.getDatabase().delete(cc); }
	 * } } catch (Exception ex) { log.error(format(ex)); } } }
	 */

	@Deprecated
	public DBSnc findDBSnc(final SNDn snDn, final String nativeEMSName) throws Exception {
		final DBSubnetwork dbSubnetwork = getDBSubnetwork(snDn);
		if (dbSubnetwork == null) {
			LOG.error(format("Cannot find Subnetwork:", snDn));
			throw new Exception("Cannot find Subnetwork.");
		}

		final DBIterator<DBSnc> dbSncs = dbSubnetwork.getSNCs().iterator();
		try {
			while (dbSncs.hasNext()) {
				final DBSnc dbSnc = dbSncs.next();
				if (dbSnc != null) {
					if (dbSnc.getInformation().getNativeEMSName().getValue().compareTo(nativeEMSName) == 0) {
						return dbSnc;
					}
				} else {
					LOG.error(format("Found NULL DBSnc!!!"));
				}
			}
		} finally {
			dbSncs.close();
		}

		return null;
	}

	public DBSnc getDBSnc(final String nativeEMSName) throws Exception {
		DBSnc out = null;

		// search for circuit
		final X38CircuitName circuitName = new X38CircuitName(nativeEMSName);
		out = getIndexes().get(circuitName);
		if (out != null) {
			return out;
		}

		// search for path
		final X38PathName pathName = new X38PathName(nativeEMSName);
		out = getIndexes().get(pathName);
		if (out != null) {
			return out;
		}

		return findDBSnc(nativeEMSName);
	}

	public SNCHolder getSnc(final String nativeEMSName) throws Exception {
		final DBSnc dbSnc = getDBSnc(nativeEMSName);

		if (dbSnc != null) {
			return new SNCHolder(dbSnc);
		}

		return null;
	}

	@Deprecated
	public DBSnc findDBSnc(final String nativeEMSName) throws Exception {
		final DBSubnetwork[] sns = getAllSubnetworks();

		for (final DBSubnetwork sn : sns) {
			final DBSnc snc = findDBSnc(sn.getDn(), nativeEMSName);
			if (snc != null) {
				return snc;
			}
		}

		return null;
	}

	/*
	 * public DBSnc getSnc(String nativeEMSName) throws Exception { X38CircuitName cctName = new X38CircuitName(nativeEMSName); DBSnc dbSnc
	 * = indexes.get(cctName); if (dbSnc == null) { X38PathName pathName = new X38PathName(nativeEMSName); dbSnc = indexes.get(pathName); }
	 * return dbSnc; }
	 */

	public DBAlarmEvent<?,?> getAlarmEvent(final AlarmOrTCAId identifier) {
		return manager.getAlarmEvent(identifier);
	}

	public Iterator<DBAlarmEvent<?,?>> getAllEMSSystemActiveAlarms(final EMSDn dn, final PerceivedSeverityList excludeSeverityList)
			throws Exception {
		final Predicate<DBAlarmEvent<?,?>> predicate = new NotPredicate<DBAlarmEvent<?,?>>(new SeverityListPredicate(excludeSeverityList));
		return DatabaseSupport.getAllEMSSystemActiveAlarms(manager, new EMSDn(), predicate);
	}

	public Iterator<DBAlarmEvent<?,?>> getAllEMSSystemActiveAlarms(final EMSDn emsDn, final SNCDn sncDn) {
		final Predicate<DBAlarmEvent<?,?>> predicate = new SNCAlarmPredicate(sncDn);
		return DatabaseSupport.getAllEMSSystemActiveAlarms(manager, emsDn, predicate);
	}

	/**
	 * This method retrieves all the active alarms for a given link.
	 * 
	 * @param emsDn
	 * @param linkDn
	 * @return
	 */
	public Iterator<DBAlarmEvent<?,?>> getAllEMSSystemActiveAlarms(final EMSDn emsDn, final LinkDn linkDn) {
		final Predicate<DBAlarmEvent<?,?>> predicate = new LinkAlarmPredicate(linkDn);
		return DatabaseSupport.getAllEMSSystemActiveAlarms(manager, emsDn, predicate);
	}

	public void dumpManagedElements() {
		final StringBuffer buf = new StringBuffer("Managed Elements in DB:");

		final DBSubnetwork[] dbSubnetworks = getAllSubnetworks();
		for (final DBSubnetwork dbSubnetwork : dbSubnetworks) {
			final DBManagedElement[] dbMEs = getAllManagedElements(dbSubnetwork);
			buf.append(String.format("\n-Subnetwork '%s' [%d]", Naming.makeValue(dbSubnetwork.getDn()), dbMEs.length));

			for (final DBManagedElement dbManagedElement : dbMEs) {
				final ManagedElement me = dbManagedElement.getInformation();
				//				MEData data = null;
				//				if (dbManagedElement.getAdditionalInformations() != null) {
				//					data = MEData.get(dbManagedElement.getAdditionalInformations());
				//				}
				final MEData data = MEData.get(dbManagedElement);
				buf.append(String.format("\n  '%s' [%s]", Naming.makeValue(me.getName()), data == null ? "null" : data.toString()));
			}
		}

		LOG.info(format(buf.toString()));
	}

	public void dumpManagedElement(final MEDn meDn) {
		final StringBuilder buf = new StringBuilder("=== DATABASE DUMP ===");
		try {
			buf.append(String.format("\nManaged Element %s", Naming.makeValue(meDn)));

			final DBManagedElement dbME = getDBManagedElement(meDn);
			if (dbME == null) {
				buf.append("\n ** NOT FOUND **");
			} else {
				final DBIterator<DBPortTp> itr = dbME.getPTPs().iterator();
				while( itr.hasNext()) {
					final DBPortTp dbPtp = itr.next();

					buf.append(String.format("\n - %s", Naming.makeValue(dbPtp.getDn())));

					final PTPData data = PTPData.get(dbPtp);
					if (data == null) {
						buf.append("\n   ** INVALID DATA **");
					}
					buf.append(String.format("\n - %s", data.toString()));
				}
				itr.close();
			}

			LOG.info(format(buf.toString()));
		} catch (final Throwable ex) {
			LOG.error(format(ex));
		}
	}

	@Deprecated
	protected void delete(final DBObject[] objs) {
		manager.delete(objs);
	}

	private DBSubnetwork[] getAllSubnetworks() {
		final DBEms dbEms = manager.getEMS(new EMSDn());
		final DBIterator<DBSubnetwork> itr = dbEms.getSubnetworks().iterator();
		final List<DBSubnetwork> list = new ArrayList<DBSubnetwork>();
		while (itr.hasNext()) {
			final Object obj = itr.next();
			if(obj instanceof DBSubnetwork){
				list.add((DBSubnetwork)obj);
			}else{
				LOG.info("The DB holds "+obj.getClass()+" instead of DBSubnetwork object in the subnetworks list.");
			}
		}
		itr.close();
		final DBSubnetwork[] out = list.toArray(new DBSubnetwork[list.size()]);
		if (out.length == 0) {
			LOG.error(format("Invalid association Ems->Subnetworks"));
		}
		return out;
	}

	private DBManagedElement[] getAllManagedElements(final DBSubnetwork subnetwork) {
		final DBIterator<DBManagedElement> meIt = subnetwork.getMEs().iterator();
		final List<DBManagedElement> list = new ArrayList<DBManagedElement>();

		while (meIt.hasNext()) {
			final DBManagedElement me = meIt.next();
			list.add(me);
		}

		meIt.close();

		final DBManagedElement[] out = list.toArray(new DBManagedElement[list.size()]);
		return out;
	}

	public AIOchId getOchId(final TPDn tpDn) {
		AIOchId out = null;
		if (isValidSession()) {
			final AIOchId ochId = DBAdditionalInfoUtilities.getOchId(manager.getTP(tpDn));
			if (ochId != null) {
				out = ochId;
			}

		} else {
			try {
				beginSession(false);
				final AIOchId ochId = DBAdditionalInfoUtilities.getOchId(manager.getTP(tpDn));
				if (ochId != null) {
					out = ochId;
				}
			} catch (final Exception ex) {
				LOG.error(format(ex));
			} finally {
				terminateSession();
			}
		}
		return out;
	}

	private void initDBObject()	{
		final EMSDn emsDn = new EMSDn();
		final SNDn snDn = sbi.getSNDn();

		Session session = null;
		try {
			session = manager.beginSession(true);

			DBEms dbEms = manager.getEMS(emsDn);
			if (dbEms == null) {
				LOG.info(format("Creating new EMS..."));

				final EMS ems = createEms(emsDn);
				dbEms = manager.createEMS(ems);

				// indexes.init();
			}
			// TODO :
			indexes.init();
			DBSubnetwork dbSubnetwork = manager.getSubnetwork(snDn);
			if (dbSubnetwork == null) {
				LOG.info(format("Creating new root Subnetwork '%s'...", Naming.makeValue(snDn)));

				final MultiLayerSubnetwork subnetwork = createMultiLayerSubnetwork(snDn);
				dbSubnetwork = manager.createSubnetwork(subnetwork);

			}

			session.commit();
		} catch (final Exception ex) {
			LOG.error(format("Session Rollback.", ex));
			session.abort();
		} finally {
			if (session != null) {
				session.terminate();
			}
		}
	}

	private EMS createEms(final EMSDn emsDn) {
		final String emsVendor  = EmsInformation.getVendor(sbi.getProfile());
		final String emsVersion = EmsInformation.getEmsVersion(sbi.getProfile());
		final String emsType    = EmsInformation.getType(sbi.getProfile());

		final EMS ems = new EMS();

		ems.setName(emsDn);
		ems.setUserLabel(new String(sbi.getEMSName()));
		ems.setNativeEMSName(new String(sbi.getEMSName()));
		ems.setOwner(emsVendor);
		ems.setEmsVersion(emsVersion);
		ems.setType(emsType);
		//        ems.setadditionalInfo(new NVSList());

		return ems;
	}

	private MultiLayerSubnetwork createMultiLayerSubnetwork(final SNDn snDn) {
		final MultiLayerSubnetwork sn = new  MultiLayerSubnetwork();

		sn.setName(snDn);
		sn.setUserLabel(Naming.makeValue(snDn.getSn()));
		sn.setNativeEMSName(Naming.makeValue(snDn.getSn()));
		sn.setOwner(String.valueOf(""));
		sn.setSubnetworkType(new Topology(Topology.topo_mesh));
		//sn.setsupportedRates(Converter.getInstance().getSubnetworkRates());
		sn.setSupportedRates(Converter.getDefault().getSubnetworkRates().getSupportedRates());
		//        sn.setadditionalInfo(new NVSList());

		return sn;
	}

	public void setEdgePoint(final DBLinkableTp ptp, final boolean edgePoint) {
		final TerminationPoint tp = ptp.getInformation();
		if (tp == null) {
			LOG.error(format("######## FOUND TP WITHOUT SYNTAX"));
			return;
		}
		final boolean oldValue = tp.getEdgePoint().getValue();
		if (edgePoint != oldValue) {
			tp.setEdgePoint(edgePoint);
			ptp.setInformation(tp);

			final CtpManager mgr = new CtpManager(sbi, name());
			mgr.updateCtp(ptp, false);
		}
	}

	@Deprecated
	private class MatchSNName implements Predicate<MEHolder> {
		private final X38SNName value;

		MatchSNName(final X38SNName value) {
			this.value = value;
		}

		@Override
		public boolean match(final MEHolder item) {
			try {
				return item.getData().match(value);
			} catch (final Exception ex) {
				LOG.error(format(ex));
				return false;
			}
		}
	}

	@Deprecated
	private class MatchEMId implements Predicate<MEHolder> {
		private int value = -1;

		public MatchEMId(final int value) {
			this.value = value;
		}

		@Override
		public boolean match(final MEHolder item) {
			try {
				return item.getData().getEMId() == value;
			} catch (final Exception ex) {
				LOG.error(format(ex));
				return false;
			}
		}
	}

	private class MatchNEPattern implements Predicate<MEHolder> {
		private X38NEPattern value = null;

		public MatchNEPattern(final X38NEPattern value) {
			this.value = value;
		}

		@Override
		public boolean match(final MEHolder item) {
			try {
				return item.getData().match(value);
			} catch (final Exception ex) {
				LOG.error(format(ex));
				return false;
			}
		}
	}

	public void clearSncAndLink(final SNDn snDn) {
		clearSnc(snDn);
		clearLink(snDn);
	}

	private void clearSnc(final SNDn snDn) {
		try {
			final Session session = beginSession(true);

			final DBSubnetwork dbSubnetwork = getDBSubnetwork(snDn);
			if (dbSubnetwork == null) {
				throw new Exception("Cannot find subnetwork.");
			}

			final DBAutoClosingItr<DBSnc> sncsIt = new DBAutoClosingItr<DBSnc>(dbSubnetwork.getSNCs().iterator(), session);

			for (; sncsIt.hasNext();) {
				final DBSnc snc = sncsIt.next();
				delete(snc, true);
			}

			commitSession();
		} catch (final Exception ex) {
			LOG.error(format(ex));
		} finally {
			terminateSession();
		}
	}

	private void clearLink(final SNDn snDn) {
		try {
			final Session session = beginSession(true);

			final DBSubnetwork dbSubnetwork = getDBSubnetwork(snDn);
			if (dbSubnetwork == null) {
				throw new Exception("Cannot find subnetwork.");
			}

			final DBAutoClosingItr<DBTopologicalLink> linksIt = new DBAutoClosingItr<DBTopologicalLink>(dbSubnetwork.getTopologicalLinks()
					.iterator(), session);

			for (; linksIt.hasNext();) {
				final DBTopologicalLink link = linksIt.next();
				delete(link);
			}

			commitSession();
		} catch (final Exception ex) {
			LOG.error(format(ex));
		} finally {
			terminateSession();
		}
	}
}

/**
 * File: Realigner.java
 */
package com.marconi.fusion.tmf.i38PlugIn.sbi.realigner;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.marconi.fusion.X38.X38Allocation;
import com.marconi.fusion.X38.X38AllocationState;
import com.marconi.fusion.X38.X38EMs;
import com.marconi.fusion.X38.X38LinkType;
import com.marconi.fusion.X38.X38NEName;
import com.marconi.fusion.X38.X38NEPattern;
import com.marconi.fusion.X38.X38SNName;
import com.marconi.fusion.X38.X38SetOfEMs;
import com.marconi.fusion.X38.X38SignalType;
import com.marconi.fusion.X38.X38VCGId;
import com.marconi.fusion.base.logging.DumpInfo;
import com.marconi.fusion.tmf.db.DBCtp;
import com.marconi.fusion.tmf.db.DBSnc;
import com.marconi.fusion.tmf.i38PlugIn.AbstractUser;
import com.marconi.fusion.tmf.i38PlugIn.I38Profile;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.ClientSNCData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.ServerLinkData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.ServerSNCData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.SetOfClientSNCData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.SetOfServerLinkData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.SetOfServerSNCData;
import com.marconi.fusion.tmf.i38PlugIn.converter2.I38Naming;
import com.marconi.fusion.tmf.i38PlugIn.db2.LinkHolder;
import com.marconi.fusion.tmf.i38PlugIn.db2.MEHolder;
import com.marconi.fusion.tmf.i38PlugIn.db2.SNCHolder;
import com.marconi.fusion.tmf.i38PlugIn.sbi.EmInfo;
import com.marconi.fusion.tmf.i38PlugIn.sbi.X38SBIClient;
import com.marconi.fusion.tmf.i38PlugIn.sbi.realigner.CircuitGroupCollector.GroupEndPoint;
import com.marconi.fusion.tmf.information.MEInformation;
import com.marconi.fusion.tmf.plugIn.PlugInExceptionHandler;
import com.marconi.fusion.tmf.plugIn.types.MEDn;
import com.marconi.fusion.tmf.plugIn.types.MEDnList;
import com.marconi.fusion.tmf.plugIn.types.MEId;
import com.marconi.fusion.tmf.plugIn.types.ProtectionEffort;
import com.marconi.fusion.tmf.plugIn.types.SNCDn;
import com.marconi.fusion.tmf.plugIn.types.SNDn;
import com.marconi.fusion.tmf.plugIn.types.SubnetworkConnection;
import com.marconi.fusion.tmf.plugIn.types.TopologicalLink;
import com.marconi.fusion.tmf.realignmentHandler.rh.ConnectionInfo;
import com.marconi.fusion.tmf.sbi.nm.SBIException;
import com.marconi.fusion.tmf.tmfFramework.repository.LayerRateManager;

/**
 * @author mercurio
 *
 */
public class Realigner extends AbstractUser {
	private static Log log = LogFactory.getLog(Realigner.class);

	private static AtomicBoolean realigning = new AtomicBoolean(false);

	private static AtomicBoolean meRealigning = new AtomicBoolean(false);

	private Profile profile = null;
	private final LinkConnCache linkConnCache = new LinkConnCache();
	private String controlPlaneManagement = null;
	List<ConnectionInfo> nmList = new ArrayList<ConnectionInfo>();

	List<MEDn> oldNeList = new ArrayList<MEDn>();
	public static final String MEDNLIST_PROPERTY = "MEDnList";

	protected Profile getProfile() {
		return profile;
	}

	protected LinkConnCache getLinkConnCache() {
		return linkConnCache;
	}

	public Realigner(final X38SBIClient sbi,
			final List<ConnectionInfo> nmList) {
		super(sbi);
		this.sbi = sbi;
		this.nmList = new ArrayList<ConnectionInfo>(nmList);
		// this.emList = emList;
		profile = Profile.getDefault();
	}

	public Realigner(final X38SBIClient sbi, final String name) {
		super(sbi, name);
		profile = Profile.getDefault();
	}

	/**
	 * This method retrieves EMList and NEList from the IPT-NMS Circuit return
	 *
	 * Map<EmInfo, List<MEDn>>
	 */
	public Map<EmInfo, List<MEDn>> preRealign() throws Exception {
		final List<MEDn> neList = new ArrayList<MEDn>();
		final Map<EmInfo, List<MEDn>> map = new HashMap<EmInfo, List<MEDn>>();
		int emId = 0;
		ConnectionInfo nmProperty = null;
		List<MERealigner.MEInfo> meInfo;
		Iterator<MERealigner.MEInfo> meInfoItr;
		if (realigning.getAndSet(true)) {
			log.error("A realignment is already active.");
			throw new Exception("A realignment is already active.");
		}
		try {
			final MERealigner meRealigner = new MERealigner(sbi, name(), Profile.getDefault());
			final Iterator<ConnectionInfo> nmListItr = nmList.iterator();
			sbi.getDatabase().buildMECache();
			while (nmListItr.hasNext()) {
				nmProperty = nmListItr.next();
				// which stores all EM list,configure to NM
				setEmInfos(nmProperty, map);

				meInfo = meRealigner.realign(nmProperty.getHost());
				meInfoItr = meInfo.iterator();
				while (meInfoItr.hasNext()) {
					final MERealigner.MEInfo info = meInfoItr.next();
					// final int neId = info.data.getNEId();

					final MEDn meDn = I38Naming.toMEDn(sbi.getNMName(), info.data.getEMId(), info.snQueryResult);
					neList.add(meDn);

					MEInformation.getMeDn2Id().set(meDn, info.data.getNeIdInEM());

					emId = info.data.getEMId();

					final Set<EmInfo> emInfoLst = map.keySet();
					final Iterator<EmInfo> emInfoItr = emInfoLst.iterator();
					while (emInfoItr.hasNext()) {
						final EmInfo emInfo = emInfoItr.next();
						if (emInfo.getEMId() == emId) {
							map.get(emInfo).add(meDn);
							break;
						}
					}
				}

			}
			//sbi.getDatabase().buildMECache();
		} catch (final Exception ex) {
			log.error(new DumpInfo("Unable to perform realignment", ex));
			throw ex;
		} finally {
			realigning.set(false);
		}
		return map;
	}

	/**
	 * Retrieves Set of EMs on IPT-NMS Circuit
	 *
	 * @param nmProperty
	 * @param map
	 */
	private void setEmInfos(final ConnectionInfo nmProperty, final Map<EmInfo, List<MEDn>> map) {
		try {
			final X38SetOfEMs setOfEMs = sbi.getMessageHandler().getEMList(
					nmProperty.getHost());
			for (final X38EMs em : setOfEMs) {
				final EmInfo info = new EmInfo(em, sbi.getMessageHandler()
						.getEMInfo(em.getEmId(), nmProperty.getHost()));
				map.put(info, new ArrayList<MEDn>());
				sbi.getEmInfoList().add(info);
			}
		} catch (final SBIException excep) {
			log.error(new DumpInfo("Unable to EM Details", excep));
		}
	}

	public void postRealign()
	throws Exception {
		if (realigning.getAndSet(true)) {
			log.error("A realignment is already active.");
			throw new Exception("A realignment is already active.");
		}

		try {
			final Iterator<ConnectionInfo> nmListItr = nmList.iterator();
			while (nmListItr.hasNext()) {

				// Iterate Over the NMList and perform realign
				final ConnectionInfo connectionInfo = nmListItr.next();
				final String hostName = connectionInfo.getHost();

				final PTPRealigner ptp = new PTPRealigner(sbi, name(), Profile.getDefault());
				ptp.realign(hostName);

				final LinkRealigner link = new LinkRealigner(sbi, name(), this);
				link.realign();

				final SNCStats sncStats = new SNCStats();

				final CctRealigner cctRealigner = new CctRealigner(sbi, name(), this);
				cctRealigner.setStats(sncStats);
				cctRealigner.realign(hostName);

				final PathRealigner pathRealigner = new PathRealigner(sbi, name(), this);
				pathRealigner.setStats(sncStats);
				pathRealigner.realign(hostName);

				final CircuitGroupRealigner circuitGroupRealigner = new CircuitGroupRealigner(sbi, name(), this);
				circuitGroupRealigner.setStats(sncStats);
				circuitGroupRealigner.realign(hostName);

				processWSON(hostName);
				sncStats.dump(log);

				linkConnCache.clear();
			}
		} catch (final Exception ex) {
			log.error(new DumpInfo("Unable to perform realignment", ex));
			throw ex;
		} finally {
			realigning.set(false);
		}
	}
	public void processWSON(final String hostName) throws Exception {
		log.debug("Processing WSON...");
		try {
			controlPlaneManagement = sbi.getPlugIn().getProfile().getProperty(I38Profile.Key.CONTROLPLANE, "no");
			if (controlPlaneManagement.equalsIgnoreCase("yes")) {
				log.debug("MLRA Realignment process started ");
				final MLRARealigner routingAreaRealigner = new MLRARealigner(sbi);
				routingAreaRealigner.realign(hostName);

				final LinkClusterRealigner linkClusterRealigner = new LinkClusterRealigner(sbi, name(), this, hostName);
				linkClusterRealigner.realign();

				final WSONPathRealigner wsonPathRealigner = new WSONPathRealigner(sbi, name, this, hostName);
				wsonPathRealigner.realign();

				// Deletes DBSnc with TPs which are allocated to control plane.
				wsonPathRealigner.deleteCtrlPlaneDBSnc();
			}
		} catch (final Exception ex) {
			log.error(new DumpInfo("Unable to perform realignment", ex));
			throw ex;
		}

	}

	public void createMe(final X38NEPattern pattern, final String hostName,
			final String emHostName)
	throws Exception {
		final MEDnList oldMEDnList = sbi.getPlugIn().getMeDnList();
		final MEDnList newMEDnList = new MEDnList(oldMEDnList);

		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		log.debug(format("*** Creating Managed Element whit NEPattern:", pattern));
		final MERealigner meRealigner = new MERealigner(sbi, name(), Profile.getDefault());
		final MERealigner.Data data = meRealigner.create(pattern, hostName);

		MEInformation.getMeDn2Id().set(data.me.getName(), data.neIdInEM);

		if (!newMEDnList.contains(data.me.getName())) {
			newMEDnList.add(data.me.getName());
		}

		sbi.getPlugIn().notify(newMEDnList, oldMEDnList, "NEList");
		log.info(" Sent  NEList notification to RH ");
		// update new MEDn in map_emInfo_meDN in I38Plugin
		final Map<EmInfo, List<MEDn>> map_emInfo_meDn = sbi.getPlugIn()
		.getMap_emInfo_meDN();
		final Iterator<EmInfo> emInfoItr = map_emInfo_meDn.keySet().iterator();
		while (emInfoItr.hasNext()) {
			final EmInfo emInfo = emInfoItr.next();
			if (emInfo.getEMName().equals(emHostName)) {
				map_emInfo_meDn.get(emInfo).add(data.me.getName());
				break;
			}
		}
	}



	public void deleteMe(final X38NEPattern pattern)
	throws Exception {

		final MEDnList oldMEDnList = sbi.getPlugIn().getMeDnList();
		final MEDnList newMEDnList = new MEDnList(oldMEDnList);

		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		String emHostName = "";
		try {
			sbi.getDatabase().beginSession(false);
			final List<MEHolder> infos = sbi.getDatabase().findManagedElements(
					pattern);

			if (infos.size() == 0) {
				log.error(format("Cannot find ManagedElement:", pattern));
				throw new Exception("Cannot find ManagedElement.");
			}

			if (infos.size() > 1) {
				log.error(format(String.format("Found %d ManagedElements for:",
						infos.size()), pattern));
				throw new Exception("Cannot find ManagedElement.");
			}

			final MEHolder holder = infos.get(0);
			emHostName = sbi.getEmHostName(holder.getSyntax()
					.getName());
		} catch (final Exception e) {
			log.error(" Could not get DBManagedElement " + e);
		} finally {
			sbi.getDatabase().terminateSession();
		}
		final MERealigner meRealigner = new MERealigner(sbi, name(), Profile.getDefault());
		final MERealigner.Data data = meRealigner.delete(pattern);
		final MEDn meDn = data.me.getName();
		newMEDnList.remove(meDn);


		sbi.getPlugIn().notify(newMEDnList, oldMEDnList, "NEList");
		log.info(" Sent  NEList notification to RH ");
		// update new MEDn in map_emInfo_meDN in I38Plugin
		final Map<EmInfo, List<MEDn>> map_emInfo_meDn = sbi.getPlugIn()
		.getMap_emInfo_meDN();
		final Iterator<EmInfo> emInfoItr = map_emInfo_meDn.keySet().iterator();
		while (emInfoItr.hasNext()) {
			final EmInfo emInfo = emInfoItr.next();
			if (emInfo.getEMName().equals(emHostName)) {
				map_emInfo_meDn.get(emInfo).remove(meDn);
				break;
			}
		}

	}


	public void updateMe(final MEDn meDn, final X38SNName snName) throws Exception {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		final MERealigner meRealigner = new MERealigner(sbi, name(), Profile.getDefault());
		meRealigner.update(meDn, snName);
	}

	public void realignMe(final MEDn meDn) throws Exception {
		if (meRealigning.getAndSet(true)) {
			log.error("A managed element realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("A managed element realignment is already active.");
		}
		try {
			log.info(format("*** Realign ManagedElement :", meDn));
			innerRealignME(meDn);
		} catch (final Exception ex) {
			throw ex;
		} finally {
			meRealigning.set(false);
		}
	}

	private void innerRealignME(final MEDn meDn) throws Exception {
		try {
			sbi.getDatabase().beginSession(true);

			final MEHolder me = sbi.getDatabase().getManagedElement(meDn);
			if (me == null) {
				log.error(format("Cannot find ME:", meDn));
				throw new Exception("Cannot realign ManagedElement.");
			}
			me.getSyntax().setEmsInSyncState(false);

			sbi.getDatabase().commitSession();
		} catch (final Exception ex) {
			log.error(format(ex));
		} finally {
			sbi.getDatabase().terminateSession();
		}

		final MERealigner meRealigner = new MERealigner(sbi, name(), profile);
		meRealigner.update(meDn);

		final PTPRealigner ptp = new PTPRealigner(sbi, name(), Profile.getDefault());
		ptp.realign(meDn);

		try {
			sbi.getDatabase().beginSession(true);

			final MEHolder me = sbi.getDatabase().getManagedElement(meDn);
			if (me == null) {
				// log.error(format("Cannot find ME:", event.getInfo()));
				throw new Exception("Cannot update ManagedElement.");
			}
			// me.getSyntax().setEmsInSyncState(event.isCompleted());
			me.getSyntax().setEmsInSyncState(true);
			me.update();

			sbi.getDatabase().commitSession();
		} catch (final Exception ex) {
			log.error(format(ex));
		} finally {
			sbi.getDatabase().terminateSession();
		}
		// }

		final LinkRealigner linkRealigner = new LinkRealigner(sbi, name(), this);
		linkRealigner.realign(meDn);

		final SNCStats sncStats = new SNCStats();

		final CctRealigner cctRealigner = new CctRealigner(sbi, name(), this);
		cctRealigner.setStats(sncStats);
		cctRealigner.realign(meDn);

		final PathRealigner pathRealigner = new PathRealigner(sbi, name(), this);
		pathRealigner.setStats(sncStats);
		pathRealigner.realign(meDn);

		final CircuitGroupRealigner circuitGroupRealigner = new CircuitGroupRealigner(sbi, name(), this);
		circuitGroupRealigner.setStats(sncStats);
		circuitGroupRealigner.realign(meDn);

		sncStats.dump(log);

		// notify Realignment End Event
		sbi.getPlugIn().notifyRH(null, null, "RealignmentEnd");
		sbi.startAlarms(sbi.getHostName());

	}

	// public void realignMELinks(MEDn meDn) throws Exception {
	// if (realigning.get()) {
	// log.error("A realignment is already active.");
	// throw new Exception("A realignment is already active.");
	// }
	//
	// LinkRealigner linkRealigner = new LinkRealigner(sbi, name(), this);
	// linkRealigner.realign(meDn);
	// }

	public TopologicalLink createLink(final String linkName,
			final String userLabel, final String hostName) throws Exception {

		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		final LinkRealigner realigner = new LinkRealigner(sbi, name(), this);
		final TopologicalLink out = realigner.update(linkName, userLabel);

		final List<PathData> clientsData = getAssociatedClientPathsAndCircuits(out);

		if (clientsData != null && clientsData.size() > 0) {
			for (final PathData client : clientsData) {
				if (client.isPath()) {
					final PathRealigner pathRealigner = new PathRealigner(sbi, name(), this);
					pathRealigner.create(null, client.getPathName(), null,
							hostName);
				} else {
					final CctRealigner cctRealigner = new CctRealigner(sbi, name(), this);
					cctRealigner.create(null, client.getPathName(), null,
							hostName);
				}
			}
		}

		return out;

	}

	private List<PathData> getAssociatedClientPathsAndCircuits(final TopologicalLink serverLink) {

		final List<PathData> clientsPathData = new ArrayList<PathData>();

		// When ManagedElement is not present in DB for the link reported,link will not created
		if (serverLink == null) {
			return clientsPathData;
		}

		try {

			sbi.getDatabase().beginSession(false);

			final LinkHolder linkHolder = sbi.getDatabase().findTopologicalLink(serverLink.getNativeEMSName().getValue());

			if (linkHolder != null) {

				final SetOfClientSNCData clientsData = (SetOfClientSNCData) linkHolder.getDBObject().getAdditionalInformation(
						SetOfClientSNCData.NAME);

				if (clientsData != null) {

					final List<ClientSNCData> clientSncs = clientsData
					.getClientSncs();

					for (final ClientSNCData clientData : clientSncs) {
						clientsPathData.add(new PathData(clientData));
					}

					if (log.isDebugEnabled() && clientSncs.size() > 0) {
						final StringBuilder sb = new StringBuilder(
								String
								.format(
										"Client SNCs associated to server Link : <%s> ",
										serverLink.getNativeEMSName()
										.getValue()));
						for (final ClientSNCData client : clientSncs) {
							sb.append("\n" + client.getPathName());
						}
						log.debug(format(sb.toString()));
					}
				}

			} else {
				log.error(format(String.format(
						"TopologicalLink <%s> is not found in db. Cannot retrieve associated client paths and circuits", serverLink
						.getNativeEMSName().getValue())));
			}

		} catch (final Exception ex) {
			log.error(format(String.format("Exception while trying to retrieve client paths and circuits for link <%s> :", serverLink
					.getNativeEMSName().getValue()), ex));
		} finally {
			sbi.getDatabase().terminateSession();
		}

		return clientsPathData;

	}

	public void updateLink(final String linkName, final String hostName)
	throws Exception {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		final LinkRealigner realigner = new LinkRealigner(sbi, name(), this);
		realigner.update(linkName, "");

		updateCircuitGroup(linkName, hostName);
	}

	public SubnetworkConnection createCircuit(final String circuitName, final String userLabel, final String owner,
			final ProtectionEffort protectionEffort, final String hostName)
	throws Exception {

		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw new Exception("A realignment is already active.");
		}

		final CctRealigner cctRealigner = new CctRealigner(sbi, name(), this);
		cctRealigner.setUserLabel(userLabel);
		cctRealigner.setOwner(owner);

		final SubnetworkConnection circuit = cctRealigner.create(null,
				circuitName, protectionEffort, hostName);

		try {
			this.realignServerLinksAssociatedToClientSnc(circuitName, hostName);
		} catch (final Exception ex) {
			log.error(format(ex));
		}

		return circuit;
	}

	// public SubnetworkConnection innerCreateCircuit(String circuitName, String userLabel, String owner, ProtectionEffort protectionEffort)
	// throws Exception {
	// // SNCRealigner realigner = new SNCRealigner(sbi, name(), this);
	// // return realigner.createCircuit(circuitName);
	// CctRealigner cctRealigner = new CctRealigner(sbi, name(), this);
	// cctRealigner.setUserLabel(userLabel);
	// cctRealigner.setOwner(owner);
	// return cctRealigner.create(circuitName, protectionEffort);
	// }

	public SubnetworkConnection updateCircuit(final String circuitName,
			final ProtectionEffort protectionEffort, final String hostName)
	throws Exception {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		if (circuitName == null || circuitName.equals("")) {
			return null;
		}
		final CctRealigner cctRealigner = new CctRealigner(sbi, name(), this);
		final SubnetworkConnection circuit = cctRealigner.update(null, null,
				circuitName, protectionEffort, hostName);

		return circuit;
	}

	private List<PathData> getServerDataList(final String nativeEmsName) {

		List<PathData> serverDataList = null;

		try {
			sbi.getDatabase().beginSession(false);

			final SNCHolder sncHolder = sbi.getDatabase().getSnc(nativeEmsName);

			if (sncHolder != null) {

				final X38SignalType signalType = sncHolder.getData()
				.getSignalType();

				if (log.isDebugEnabled()) {
					log.debug(format(String.format(
							"Signaltype of SNC <%s> is : ", nativeEmsName),
							signalType));
				}

				if (!(signalType.isOdu1() || signalType.isOdu2() || signalType
						.isOdu3())) {
					log
					.debug("Signal type is not oduK. So no need to realign the server paths");
					return null;
				}

				final SetOfServerSNCData serversData = (SetOfServerSNCData) sncHolder.getDBObject().getAdditionalInformation(
						SetOfServerSNCData.NAME);

				if (serversData != null) {

					final List<ServerSNCData> serverSncs = serversData.getServerSncs();

					serverDataList = new ArrayList<PathData>();

					for (final ServerSNCData serverData : serverSncs) {
						serverDataList.add(new PathData(serverData));
					}

					if (log.isDebugEnabled() && serverSncs.size() > 0) {
						final StringBuilder sb = new StringBuilder(
								String
								.format(
										"Server SNCs associated to client SNC : <%s> ",
										nativeEmsName));
						for (final ServerSNCData serverSnc : serverSncs) {
							sb.append("\n" + serverSnc.getPathName());
						}
						log.debug(format(sb.toString()));
					}

				}

			} else {
				log.error(format(String.format("SNC <%s> is not found in db. Cannot retrieve server SNCs related to it", nativeEmsName)));
			}

		} catch (final Exception ex) {
			log.error(format(String.format("Exception while trying to get server SNC list for client SNC <%s>", nativeEmsName), ex));
		} finally {
			sbi.getDatabase().terminateSession();
		}

		return serverDataList;
	}

	private List<PathData> getClientDataList(final String nativeEmsName) {

		List<PathData> clientDataList = null;

		try {
			sbi.getDatabase().beginSession(false);

			final SNCHolder sncHolder = sbi.getDatabase().getSnc(nativeEmsName);

			if (sncHolder != null) {

				final X38SignalType signalType = sncHolder.getData()
				.getSignalType();

				if (log.isDebugEnabled()) {
					log.debug(format(String.format(
							"Signaltype of SNC <%s> is : ", nativeEmsName),
							signalType));
				}

				if (!signalType.isOch()) {
					log
					.debug("Signal type is not och. So no need to realign the clients paths of it");
					return null;
				}

				final SetOfClientSNCData clientsData = (SetOfClientSNCData) sncHolder.getDBObject().getAdditionalInformation(
						SetOfClientSNCData.NAME);

				if (clientsData != null) {

					clientDataList = new ArrayList<PathData>();

					final List<ClientSNCData> clientSncs = clientsData
					.getClientSncs();

					for (final ClientSNCData clientData : clientSncs) {
						clientDataList.add(new PathData(clientData));
					}

					if (log.isDebugEnabled() && clientSncs.size() > 0) {
						final StringBuilder sb = new StringBuilder(
								String
								.format(
										"Client SNCs associated to server SNC : <%s> ",
										nativeEmsName));

						for (final ClientSNCData clientSnc : clientSncs) {
							sb.append("\n" + clientSnc.getPathName());
						}
						log.debug(format(sb.toString()));
					}

				}

			} else {
				log.error(format(String.format("SNC <%s> is not found in db. Cannot retrieve client SNCs related to it", nativeEmsName)));
			}

		} catch (final Exception ex) {
			log.error(format(String.format("Exception while trying to get client SNC list for client SNC <%s>", nativeEmsName), ex));
		} finally {
			sbi.getDatabase().terminateSession();
		}

		return clientDataList;
	}

	public SubnetworkConnection createPath(final String pathName, final String userLabel, final String owner,
			final ProtectionEffort protectionEffort, final String hostName)
	throws Exception {

		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		final PathRealigner pathRealigner = new PathRealigner(sbi, name(), this);
		pathRealigner.setUserLabel(userLabel);
		pathRealigner.setOwner(owner);

		final SubnetworkConnection path = pathRealigner.create(null, pathName,
				protectionEffort, hostName);

		// Realign the OTM/OTS link when an OCH path is created (This is needed
		// to update the link ids at OTU layer for OTM link for trail
		// trace operations)
		if (path != null
				&& path.getRate().equals(
						LayerRateManager.getLayerRate("LR_Optical_Channel"))) {
			try {
				this.realignServerLinksAssociatedToClientSnc(pathName, hostName);
			} catch (final Exception ex) {
				log.error(format(ex));
			}
		}


		return path;
	}

	public void realignServerLinksAssociatedToClientSnc(
			final String clientSncNativeEmsName, final String hostName) {
		final SetOfServerLinkData serverLinkData = getServerLinksAssociatedToClientSnc(clientSncNativeEmsName);
		realignServerLinksAssociatedToClientSnc(serverLinkData,
				clientSncNativeEmsName, hostName);
	}

	public void realignServerLinksAssociatedToClientSnc(
			final SetOfServerLinkData serverLinkData,
			final String clientSncNativeEmsName, final String hostName) {
		if (serverLinkData != null) {
			final List<ServerLinkData> serversLinkList = serverLinkData
			.getServerLinks();
			if (serversLinkList.size() > 0) {
				if (log.isDebugEnabled()) {
					final StringBuilder sb = new StringBuilder(String.format(
							"Server Link associated to client SNC : <%s> ",
							clientSncNativeEmsName));
					for (final ServerLinkData server : serversLinkList) {
						sb.append("\n" + server.getLinkName());
					}
					log.debug(format(sb.toString()));
				}
				for (final ServerLinkData serverLink : serversLinkList) {
					try {
						this.updateLink(serverLink.getLinkName(), hostName);
					} catch (final Exception ex) {
						log.error(format(ex));
					}
				}
			} else {
				final String errorReason = String.format(
						"SetOfServerLinkData of client SNC <%s> is empty",
						clientSncNativeEmsName);
				log.warn(format(errorReason));

			}
		}
	}

	public SetOfServerLinkData getServerLinksAssociatedToClientSnc(final String clientSncNativeEmsName) {

		try {
			sbi.getDatabase().beginSession(false);
			final SNCHolder clientSncHolder = sbi.getDatabase().getSnc(clientSncNativeEmsName);
			if (clientSncHolder != null) {
				final DBSnc clientSnc = clientSncHolder.getDBObject();
				if (clientSnc != null) {
					return (SetOfServerLinkData) clientSnc.getAdditionalInformation(SetOfServerLinkData.NAME);
				}
			} else {
				final String errorReason = String.format("Could not find the client SNC <%s> in the database", clientSncNativeEmsName);
				log.warn(format(errorReason));
			}
		} catch (final Exception ex) {
			log.error(format(ex));
		} finally {
			sbi.getDatabase().terminateSession();
		}

		return null;
	}

	// private SubnetworkConnection innerCreatePath(String pathName, String userLabel, String owner, ProtectionEffort protectionEffort)
	// throws Exception {
	// // SNCRealigner realigner = new SNCRealigner(sbi, name(), this);
	// // return realigner.createPath(pathName);
	// PathRealigner pathRealigner = new PathRealigner(sbi, name(), this);
	// pathRealigner.setUserLabel(userLabel);
	// pathRealigner.setOwner(owner);
	// return pathRealigner.create(pathName, protectionEffort);
	// }

	public SubnetworkConnection updatePath(final String pathName,
			final ProtectionEffort protectionEffort, final String hostName)
	throws Exception {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		if (pathName == null || pathName.equals("")) {
			return null;
		}

		final List<PathData> serverDataList = getServerDataList(pathName);
		final List<PathData> clientDataList = getClientDataList(pathName);
		final PathRealigner pathRealigner = new PathRealigner(sbi, name(), this);
		final SubnetworkConnection path = pathRealigner.update(serverDataList,
				clientDataList, pathName, protectionEffort, hostName);

		try {
			realignServerLinksAssociatedToClientSnc(pathName, hostName);
		} catch (final Exception ex) {
			log.error(format(ex));
		}

		return path;
	}

	/**
	 * Activation/Enable/Realignment/Modification/Reroute for Async Events of
	 * WSonPath
	 *
	 * @param pathName
	 * @throws Exception
	 *
	 */
	public void updateWsonPath(final String pathName, final String pathId) throws Exception {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}
		if (pathName != null) {
			final WSONPathRealigner wsonPathRealigner = new WSONPathRealigner(
					sbi, name(), this, sbi.getPlugIn().getNmList().get(0)
					.getHost());
			wsonPathRealigner.update(pathName, pathId);
		}
	}

	/**
	 * Deactivate/Disable/Disassociation for Async Events of WSonPath
	 *
	 * @param pathName
	 * @param sncDn
	 */
	public void deleteWsonPath(final String pathName, final String pathId) {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}
		final WSONPathRealigner wsonPathRealigner = new WSONPathRealigner(sbi,
				name(), this, sbi.getPlugIn().getNmList().get(0).getHost());
		try {
			wsonPathRealigner.delete(pathName, pathId);
		} catch (final Exception e) {
			log.error(new DumpInfo("Exception While deleting Path", e));
		}
	}

	public TopologicalLink createCircuitGroup(final String pathName,
			final String hostName) throws Exception {
		final CircuitGroupRealigner realigner = new CircuitGroupRealigner(sbi, name(), this);
		return realigner.create(pathName, hostName);
	}

	public SubnetworkConnection updateCircuitGroup(final String pathName,
			final SNCDn sncDn, final String hostName/* , String userLabel */)
	throws Exception {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		final CircuitGroupRealigner realigner = new CircuitGroupRealigner(sbi, name(), this);
		return realigner.update(pathName, sncDn, hostName/* , userLabel */);
	}

	public SubnetworkConnection updateCircuitGroup(final String pathName,
			final String hostName) throws Exception {
		return updateCircuitGroup(pathName, null, hostName/* , null */);
	}

	public TopologicalLink deleteCircuitGroup(final String pathName) throws Exception {
		final CircuitGroupRealigner realigner = new CircuitGroupRealigner(sbi, name(), this);
		return realigner.delete(pathName);
	}

	/**
	 * An update session must be open.
	 */
	public SubnetworkConnection createLocalSnc(final DBCtp vcgEnd, final DBCtp backplaneEnd, final X38VCGId vcgId,
			final SubnetworkConnection path) throws Exception {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		final GroupEndPoint endPoint = new GroupEndPoint();
		endPoint.ctp = vcgEnd;
		endPoint.vcgId = vcgId;
		endPoint.allocation = new X38Allocation();
		endPoint.allocation.setSource(X38AllocationState.UNALLOCATED);
		endPoint.allocation.setSink(X38AllocationState.UNALLOCATED);

		final CircuitGroupRealigner pathRealigner = new CircuitGroupRealigner(sbi, name(), this);
		return pathRealigner.createLocalSNC(vcgEnd, backplaneEnd, vcgId, path);
	}

	public void realignSubnetwork(final SNDn snDn, final String hostName)
	throws Exception {
		try {
			if (sbi.getProfile().getBoolProperty(I38Profile.Key.SBI_SYNCH_ME, false)) {
				final MERealigner realigner = new MERealigner(sbi, name(), getProfile());
				realigner.realign(hostName);
			}

			if (sbi.getProfile().getBoolProperty(I38Profile.Key.SBI_REALIGN_ME_NOT_INSYNC, false)) {
				realignMENotInSync(snDn);
			}

			if (sbi.getProfile().getBoolProperty(I38Profile.Key.SBI_FORCE_LINK_AND_SNC_REALIGNMENT, false)) {
				realignLinkAndSNC(snDn, hostName);
			}
		} catch (final Exception ex) {
			log.error(new DumpInfo("Unable to perform Subnetwork realignment", ex));
			throw ex;
		}
	}

	public void realignMENotInSync(final SNDn snDn) {
		log.info(format("###\n### REALIGN ME NOT IN SYNC\n###"));
		final MEDnList list = new MEDnList();
		try {
			sbi.getDatabase().beginSession(false);
			final List<MEHolder> holders = sbi.getDatabase().getManagedElements(snDn);
			for (final MEHolder holder : holders) {
				if (!holder.getSyntax().getEmsInSyncState().getValue()) {
					list.add(holder.getSyntax().getName());
				}
			}
		} catch (final Throwable ex) {
			log.error(format(ex));
			return;
		} finally {
			sbi.getDatabase().terminateSession();
		}

		for (final Iterator<MEDn> itr = list.iterator(); itr.hasNext();) {
			final MEDn meDn = itr.next();

			log.info(format("Realign not InSync ManagedElement: %s", meDn.getMe().getValue()));
			try {
				realignMe(meDn);
			} catch (final Throwable ex) {
				log.error(format(ex));
			}
		}
	}

	public void synchME(final SNDn snDn, final String hostName) {
		log.info(format("###\n### SYNCHRONIZE ME\n###"));
		final MERealigner realigner = new MERealigner(sbi, name(), getProfile());
		try {
			realigner.realign(hostName);
		} catch (final Exception ex) {
			log.error(format("Unable to Synchronize ME:", ex));
		}
	}

	public void realignLinkAndSNC(final SNDn snDn, final String hostName)
	throws Exception {
		log.info(format("###\n### REALIGN LINK AND SNC\n###"));

		if (realigning.getAndSet(true)) {
			log.error("A realignment is already active.");
			return;
		}

		try {
			final LinkRealigner linkRealigner = new LinkRealigner(sbi, name(), this);
			linkRealigner.realign();

			final SNCStats sncStats = new SNCStats();



			final CctRealigner cctRealigner = new CctRealigner(sbi, name(), this);
			cctRealigner.setStats(sncStats);
			cctRealigner.realign(hostName);

			final PathRealigner pathRealigner = new PathRealigner(sbi, name(), this);
			pathRealigner.setStats(sncStats);
			pathRealigner.realign(hostName);

			final CircuitGroupRealigner circuitGroupRealigner = new CircuitGroupRealigner(sbi, name(), this);
			circuitGroupRealigner.setStats(sncStats);
			circuitGroupRealigner.realign(hostName);

			controlPlaneManagement = sbi.getPlugIn().getProfile().getProperty(I38Profile.Key.CONTROLPLANE, "no");
			if (controlPlaneManagement.equalsIgnoreCase("yes")) {
				final MLRARealigner routingAreaRealigner = new MLRARealigner(sbi);
				routingAreaRealigner.realign(hostName);

				final LinkClusterRealigner lcRealigner = new LinkClusterRealigner(
						sbi, name(), this, sbi.getPlugIn().getNmList().get(0)
						.getHost());
				lcRealigner.realign();

				final WSONPathRealigner wsonPathRealigner = new WSONPathRealigner(
						sbi, name, this, sbi.getPlugIn().getNmList().get(0)
						.getHost());
				wsonPathRealigner.realign();

			}

			sncStats.dump(log);
			linkRealigner.dump();
		} catch (final Exception ex) {
			log.error(new DumpInfo("Unable to perform Link and SNC realignment", ex));
		} finally {
			realigning.set(false);
		}
	}

	/**
	 * This method is called when creation or updation of MLRA event is received
	 *
	 * @param lsrName
	 *            - name of the MLRA
	 * @throws Exception
	 */
	public void createOrUpdateLSR(final String routerId,
			final X38NEName supportingName, final String hostName)
	throws Exception {
		log.debug("Creatring or updating LSR " + routerId);
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		final MLRARealigner mlraRealigner = new MLRARealigner(sbi);
		mlraRealigner.createOrUpdateLSR(routerId, supportingName, hostName);

	}

	/**
	 * This method is called when deletion of MLRA event is received
	 *
	 * @param mlraName
	 *            - name of the MLRA
	 * @throws Exception
	 */
	public void deleteLSR(final String mlraName, final X38NEName supportingName) throws Exception {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		final MLRARealigner mlraRealigner = new MLRARealigner(sbi);
		mlraRealigner.deleteLSR(mlraName, supportingName);

	}

	/**
	 * This method is called when creation or updation of MLSNPP link event is
	 * received
	 *
	 * @param linkClusterName
	 *            - name of the Link Cluster
	 * @throws Exception
	 */
	public void createOrUpdateLinkCluster(final String resourceName) throws Exception {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		final LinkClusterRealigner linkClusterRealigner = new LinkClusterRealigner(
				sbi, name(), this, sbi.getPlugIn().getNmList().get(0).getHost());
		linkClusterRealigner.createOrUpdateLinkCluster(resourceName);

	}

	/**
	 * This method is called when deletion MLSNPP link event is received
	 *
	 * @param linkClusterName
	 *            - name of the Link Cluster
	 * @throws Exception
	 */
	public void deleteLinkCluster(final String linkClusterName) throws Exception {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		final LinkClusterRealigner linkClusterRealigner = new LinkClusterRealigner(
				sbi, name(), this, sbi.getPlugIn().getNmList().get(0).getHost());
		linkClusterRealigner.deleteLinkCluster(linkClusterName);

	}

	/**
	 * This method is called when creation or updation of MLSNPP event is
	 * received
	 *
	 * @param mlsnppLink
	 *            - name of the Link Cluster
	 * @throws Exception
	 */

	public void createOrUpdateLinkComponent(final String linkCmpName) {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		LinkClusterRealigner linkClusterRealigner;
		try {
			linkClusterRealigner = new LinkClusterRealigner(sbi, name(), this,
					sbi.getPlugIn().getNmList().get(0).getHost());
			linkClusterRealigner.createOrUpdateLinkComponent(linkCmpName);

			final WSONPathRealigner wsonPathRealigner = new WSONPathRealigner(
					sbi, name, this, sbi.getPlugIn().getNmList().get(0)
					.getHost());
			wsonPathRealigner.deleteCtrlPlaneDBSnc();
		} catch (final SBIException excp) {
			log.error(new DumpInfo(excp, "Unable to process Async Event"));
		}
	}

	/**
	 * This method is called when deletion MLSNPP event is received
	 *
	 * @param mlsnppLink
	 *            - name of the Link Cluster
	 * @throws Exception
	 */
	public void deleteLinkComponent(final String linkComponentName) {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}

		LinkClusterRealigner linkClusterRealigner;
		try {
			linkClusterRealigner = new LinkClusterRealigner(sbi, name(), this,
					sbi.getPlugIn().getNmList().get(0).getHost());
			linkClusterRealigner.deleteLinkComponent(linkComponentName);
		} catch (final SBIException excp) {
			log.error(new DumpInfo(excp, "Unable to process WSON Event failed "));
		}

	}

	public void createPathAndCct(final HashSet<MEId> meIdsToBeUpdated) throws Exception {

		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}
		for (final MEId meId : meIdsToBeUpdated) {
			final MEDn meDn = new MEDn();
			meDn.setMe(meId);

			final CctRealigner cctRealigner = new CctRealigner(sbi, name(), this);
			cctRealigner.realign(meDn);

			final PathRealigner pathRealigner = new PathRealigner(sbi, name(), this);
			pathRealigner.realign(meDn);
		}

	}

	/**
	 * Deletes Sncs from DB which have Control plane resources .
	 */
	public void deleteSncsWithCtrlResources() {
		if (realigning.get()) {
			log.error("A realignment is already active.");
			throw PlugInExceptionHandler.unableToComply("operation temporary unavailable: a realignment is already active.");
		}
		final WSONPathRealigner wsonPathRealigner = new WSONPathRealigner(sbi,
				name(), this, sbi.getPlugIn().getNmList().get(0).getHost());
		wsonPathRealigner.deleteCtrlPlaneDBSnc();
	}

	public static class ServerLinkOrSnc {

		// true - if it SNC , false if link
		private final boolean isSnc;

		// If Link
		private X38LinkType linkType;
		private int linkId = -1;

		// If Snc
		private int pathId = -1;
		private X38SignalType signalType;
		private final String linkOrSncName;

		public ServerLinkOrSnc(final int linkId, final String linkOrSncName, final X38LinkType linkType) {
			this.linkType = linkType;
			this.linkId = linkId;
			this.linkOrSncName = linkOrSncName;
			this.isSnc = false;
		}

		public ServerLinkOrSnc(final int pathId, final String linkOrSncName, final X38SignalType signalType) {
			this.pathId = pathId;
			this.signalType = signalType;
			this.linkOrSncName = linkOrSncName;
			this.isSnc = true;
		}

		public boolean isSnc() {
			return isSnc;
		}

		public X38SignalType getSignalType() {
			return signalType;
		}

		public String getLinkOrSnCName() {
			return linkOrSncName;
		}

		public X38LinkType getLinkType() {
			return linkType;
		}

		public int getLinkId() {
			return linkId;
		}

		public int getPathId() {
			return pathId;
		}

		public void setPathId(final int pathId) {
			this.pathId = pathId;
		}

		public void setLinkId(final int linkId) {
			this.linkId = linkId;
		}

		public void setLinkType(final X38LinkType linkType) {
			this.linkType = linkType;
		}

		public void setSignalType(final X38SignalType signalType) {
			this.signalType = signalType;
		}
	}

}

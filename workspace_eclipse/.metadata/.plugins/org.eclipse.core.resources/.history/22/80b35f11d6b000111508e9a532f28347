package com.marconi.fusion.tmf.i36PlugIn.sbi;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.Semaphore;

import org.apache.commons.lang.time.StopWatch;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.marconi.fusion.I36.I36;
import com.marconi.fusion.X36.X36AlarmResource;
import com.marconi.fusion.X36.X36AlarmResourceDetails;
import com.marconi.fusion.X36.X36CardId;
import com.marconi.fusion.X36.X36Compliance;
import com.marconi.fusion.X36.X36EventDetail;
import com.marconi.fusion.X36.X36EventDetailReport;
import com.marconi.fusion.X36.X36GetDeprovisioning;
import com.marconi.fusion.X36.X36GetReportAlarmResourcesDisabled;
import com.marconi.fusion.X36.X36MsgClient;
import com.marconi.fusion.X36.X36MsgClientException;
import com.marconi.fusion.X36.X36MsgGetAlarmResourcesDisabled;
import com.marconi.fusion.X36.X36MsgGetDeprovisioning;
import com.marconi.fusion.X36.X36MsgGetReportAlarmResourcesDisabled;
import com.marconi.fusion.X36.X36MsgSetAlarmReporting;
import com.marconi.fusion.X36.X36MsgSetReportAlarmReporting;
import com.marconi.fusion.X36.X36MsgUserInterfaceManagement;
import com.marconi.fusion.X36.X36NeId;
import com.marconi.fusion.X36.X36NetworkElement;
import com.marconi.fusion.X36.X36NodePossibleConfiguration;
import com.marconi.fusion.X36.X36PortIdentification;
import com.marconi.fusion.X36.X36ReportGetVersion;
import com.marconi.fusion.X36.X36SBIHostName;
import com.marconi.fusion.X36.X36SetAlarmReporting;
import com.marconi.fusion.X36.X36SetOfAlarmResourceDetails;
import com.marconi.fusion.X36.X36SetOfNeId;
import com.marconi.fusion.X36.X36SetOfNetworkElement;
import com.marconi.fusion.X36.X36SetReportAlarmReporting;
import com.marconi.fusion.X36.X36ShelfId;
import com.marconi.fusion.X36.X36SlotId;
import com.marconi.fusion.base.application.BaseApplication;
import com.marconi.fusion.base.application.Profile;
import com.marconi.fusion.base.application.TimerHandlerSupport.TimerId;
import com.marconi.fusion.base.application.TimerListener;
import com.marconi.fusion.base.application.WrongInitializationException;
import com.marconi.fusion.base.logging.DumpInfo;
import com.marconi.fusion.base.util.ActionDelayer;
import com.marconi.fusion.base.util.Utility;
import com.marconi.fusion.tmf.SBI.SBI;
import com.marconi.fusion.tmf.SBI.SBIKey;
import com.marconi.fusion.tmf.SBIContainer.SBIContainer;
import com.marconi.fusion.tmf.additionalInformation.AdditionalInfoUtils;
import com.marconi.fusion.tmf.additionalInformation.BshrConfiguration;
import com.marconi.fusion.tmf.additionalInformation.EmSystemProfile;
import com.marconi.fusion.tmf.additionalInformation.EquipmentProtectionInfo;
import com.marconi.fusion.tmf.additionalInformation.MSPProtectionInfo;
import com.marconi.fusion.tmf.additionalInformation.ManagedSystemProfile;
import com.marconi.fusion.tmf.additionalInformation.ProprietaryAdditionalInfo;
import com.marconi.fusion.tmf.db.DBCrossConnection;
import com.marconi.fusion.tmf.db.DBEms;
import com.marconi.fusion.tmf.db.DBEquipment;
import com.marconi.fusion.tmf.db.DBEquipmentHolder;
import com.marconi.fusion.tmf.db.DBEquipmentOrHolder;
import com.marconi.fusion.tmf.db.DBException;
import com.marconi.fusion.tmf.db.DBFlowDomain;
import com.marconi.fusion.tmf.db.DBIterator;
import com.marconi.fusion.tmf.db.DBList;
import com.marconi.fusion.tmf.db.DBManagedElement;
import com.marconi.fusion.tmf.db.DBManyRelationship;
import com.marconi.fusion.tmf.db.DBMatrixFlowDomain;
import com.marconi.fusion.tmf.db.DBObject;
import com.marconi.fusion.tmf.db.DBProtectionGroup;
import com.marconi.fusion.tmf.db.DBSubnetwork;
import com.marconi.fusion.tmf.db.Session;
import com.marconi.fusion.tmf.i36PlugIn.AlarmProvisioningReporter;
import com.marconi.fusion.tmf.i36PlugIn.ConnectionsCountHelper;
import com.marconi.fusion.tmf.i36PlugIn.EmDetails;
import com.marconi.fusion.tmf.i36PlugIn.EventCollector;
import com.marconi.fusion.tmf.i36PlugIn.I36DatabaseManager;
import com.marconi.fusion.tmf.i36PlugIn.I36MessageHandler;
import com.marconi.fusion.tmf.i36PlugIn.I36Naming;
import com.marconi.fusion.tmf.i36PlugIn.I36PlugIn;
import com.marconi.fusion.tmf.i36PlugIn.I36PlugIn.PluginProperty;
import com.marconi.fusion.tmf.i36PlugIn.IndexesMaker;
import com.marconi.fusion.tmf.i36PlugIn.MECache;
import com.marconi.fusion.tmf.i36PlugIn.MEDeletionJob;
import com.marconi.fusion.tmf.i36PlugIn.MEIdAndHost;
import com.marconi.fusion.tmf.i36PlugIn.MEInfos;
import com.marconi.fusion.tmf.i36PlugIn.MEInfos.MEState;
import com.marconi.fusion.tmf.i36PlugIn.NeHelper;
import com.marconi.fusion.tmf.i36PlugIn.NodePossibleConfigurationReporter;
import com.marconi.fusion.tmf.i36PlugIn.PluginUtility;
import com.marconi.fusion.tmf.i36PlugIn.SBIClientI;
import com.marconi.fusion.tmf.i36PlugIn.converter.MEConverter;
import com.marconi.fusion.tmf.i36PlugIn.converter.PhysicalConverter;
import com.marconi.fusion.tmf.i36PlugIn.eventHandler.EventHandler;
import com.marconi.fusion.tmf.i36PlugIn.eventHandler.IEventHandler;
import com.marconi.fusion.tmf.i36PlugIn.eventHandler.StandAloneEventHandler;
import com.marconi.fusion.tmf.i36PlugIn.inventory.InventorySupport;
import com.marconi.fusion.tmf.i36PlugIn.keys.KeysMaker;
import com.marconi.fusion.tmf.i36PlugIn.protection.ProtectionSwitchRaiser;
import com.marconi.fusion.tmf.i36PlugIn.realignment.BERReader;
import com.marconi.fusion.tmf.i36PlugIn.realignment.BeginRealignmentEvent;
import com.marconi.fusion.tmf.i36PlugIn.realignment.EndRealignmentEvent;
import com.marconi.fusion.tmf.i36PlugIn.realignment.PendingSNCImportUtility;
import com.marconi.fusion.tmf.i36PlugIn.realignment.ProtectionSynchManager;
import com.marconi.fusion.tmf.i36PlugIn.realignment.RealignmentEvent;
import com.marconi.fusion.tmf.i36PlugIn.realignment.RealignmentEventListener;
import com.marconi.fusion.tmf.i36PlugIn.realignment.RealignmentManager;
import com.marconi.fusion.tmf.i36PlugIn.realignment.TCAPPImportUtility;
import com.marconi.fusion.tmf.i36PlugIn.realignment.TLImportUtility;
import com.marconi.fusion.tmf.information.MEInformation;
import com.marconi.fusion.tmf.information.MEInformation.MEDn2Id;
import com.marconi.fusion.tmf.plugIn.IEventConsumer;
import com.marconi.fusion.tmf.plugIn.PlugInException;
import com.marconi.fusion.tmf.plugIn.PlugInExceptionHandler;
import com.marconi.fusion.tmf.plugIn.PluginEventDispatcher;
import com.marconi.fusion.tmf.plugIn.events.MERealignmentEnd;
import com.marconi.fusion.tmf.plugIn.events.MERealignmentStart;
import com.marconi.fusion.tmf.plugIn.types.AdditionalInfo;
import com.marconi.fusion.tmf.plugIn.types.EMSDn;
import com.marconi.fusion.tmf.plugIn.types.Equipment;
import com.marconi.fusion.tmf.plugIn.types.EquipmentDn;
import com.marconi.fusion.tmf.plugIn.types.EquipmentHolder;
import com.marconi.fusion.tmf.plugIn.types.EquipmentOrHolder;
import com.marconi.fusion.tmf.plugIn.types.EquipmentOrHolderDn;
import com.marconi.fusion.tmf.plugIn.types.HolderDn;
import com.marconi.fusion.tmf.plugIn.types.HolderId;
import com.marconi.fusion.tmf.plugIn.types.MEDn;
import com.marconi.fusion.tmf.plugIn.types.MEDnList;
import com.marconi.fusion.tmf.plugIn.types.MEId;
import com.marconi.fusion.tmf.plugIn.types.ManagedElement;
import com.marconi.fusion.tmf.plugIn.types.ManagedElementList;
import com.marconi.fusion.tmf.plugIn.types.OperationalState;
import com.marconi.fusion.tmf.plugIn.types.ProtectionGroupType;
import com.marconi.fusion.tmf.plugIn.types.TPDn;
import com.marconi.fusion.tmf.plugIn.types.TPDnList;
import com.marconi.fusion.tmf.realignmentHandler.rh.ConnectionInfo;
import com.marconi.fusion.tmf.sbi.em.EmSBIPluginProperty;
import com.marconi.fusion.tmf.sbi.em.SBIInitializationException;
import com.marconi.fusion.tmf.sbi.em.SBIManager;
import com.marconi.fusion.tmf.sbi.em.X36SBI;
import com.marconi.fusion.tmf.tmfFramework.TmfNameUtilities;
import com.marconi.fusion.tmf.tmfFramework.TmfUtilities2;
import com.marconi.fusion.tmf.utils.ConnectionsCount;
import com.marconi.fusion.tmf.utils.ListCursor;
import com.marconi.fusion.tmf.utils.NumberGenerator;

/**
 * <p>
 * Title: SBIClient.java
 * </p>
 * <p>
 * Description: <br/>
 * This class is to provide a set of functionalities to those who are using the
 * TMFI36Plugin SBI.
 * </p>
 *
 * <p>
 * Copyright: Copyright (c) 2008
 * </p>
 * <p>
 * Company: Ericsson
 * </p>
 *
 * @author Luca Vassalli & Chaitanya Indukuri
 * @version 1.5
 * @since 1.5
 */
@SuppressWarnings("deprecation")
public class SBIClient implements SBIClientI, PropertyChangeListener, TimerListener, RealignmentEventListener {

	private static final Log LOG = LogFactory.getLog(SBIClient.class);

	private I36PlugIn plugIn = null;
	private final Object dbManagerLock = new Object();
	private I36DatabaseManager dbManager = null;
	private I36Naming naming = null;
	private IndexesMaker indexesMaker = null;
	private KeysMaker keysMaker = null;
	private EventCollector eventCollector = null;
	private final MEInfos meInfos = new MEInfos();
	private boolean forcedNEIDList = false;
	private RealignmentManager realignmentManager = null;
	private ProtectionSynchManager protectionSynchManager = null;
	private ActionDelayer actionDelayer = null;
	private I36MessageHandler messageHandler = null;
	private InventorySupport inventorySupport = null;
	private final Semaphore startSemaphore = new Semaphore(0);
	private Semaphore provisioningSemaphore;
	private TimerId startTimerId = null;
	private ProtectionSwitchRaiser protectionSwitchRaiser = null;
	private IEventHandler eventHandler = null;
	private boolean starting = true;
	private final Map<MEDn, MEDeletionJob> deletionJobMap = new HashMap<MEDn, MEDeletionJob>();
	protected long meDeletionDelay = 1L;
	public String host = null;
	private SBIKey sbiKey = null;
	SBIManager sbiManager = null;
	List<ConnectionInfo> connectionLst = new ArrayList<ConnectionInfo>();
	private static SBIClient sbiClient = null;
	private final Map<String, MEDnList> emNeIdsMap = new HashMap<String, MEDnList>();
	private MEDn forceRealignmentMEDn = null;
	private final String ME_NAME_FORMAT = "%1$s:%2$d:%3$d";

	/**
	 * Method to return the ConnectionInfo List
	 *
	 * @return
	 */
	@Override
	public List<ConnectionInfo> getConnectionLst() {
		return connectionLst;
	}

	/**
	 * Method to set the Connection Info List, this method is used to fill in
	 * the SBI related information
	 *
	 * @param connectionLst
	 */
	public void setConnectionLst(final List<ConnectionInfo> connectionLst) {
		this.connectionLst = connectionLst;
	}

	/**
	 * Method to add a new ConnectionInfo to the connectionList
	 *
	 * @param connInfo
	 */
	public void addConnectionLst(final ConnectionInfo connInfo) {
		this.connectionLst.add(connInfo);
	}

	/**
	 * Set to true if it is Force Realignment operation
	 *
	 * @param isForceRealignment
	 */
	@Override
	public void setForceRealignmentMEDn(final MEDn forceRealignmentMEDn) {
		this.forceRealignmentMEDn = forceRealignmentMEDn;
	}

	/**
	 * @return the sbiKey
	 */
	@Override
	public SBIKey getSbiKey() {
		return sbiKey;
	}

	/**
	 * @return the host
	 */
	@Override
	public String getHostName() {
		return host;
	}

	@Override
	public String getHostName(final MEDn meDn, final boolean isSessionOpen) {
		String hostName = null;
		Session session = null;
		try {
			if (!isSessionOpen) {
				session = sbiClient.getDbManager().beginSession(false);
			}
			if (isStandAlone()) {
				hostName = host;
			} else {
				final DBManagedElement me = sbiClient.getDbManager().getManagedElement(meDn);
				if (me != null) {

					final EmSystemProfile emSystemProfile = getEmSystemProfile(me);
					if (emSystemProfile != null) {
						hostName = emSystemProfile.getSyntax().getHostId().getValue();
					}
					if (hostName == null) {
						final Map<String, MEDnList> emNeMap = getPlugIn().getEmNEDetails();
						final Iterator<String> emLst = emNeMap.keySet().iterator();
						while (emLst.hasNext()) {
							hostName = emLst.next();
							if (emNeMap.get(hostName).contains(meDn)) {
								break;
							}
						}
					}
				}
			}
		} catch (final Exception e) {
			LOG.error("Exception while getting hostName from MEDn:");
		} finally {
			if (session != null) {
				session.terminate();
				session = null;
			}
		}
		return hostName;
	}

	/**
	 * @return the eventPort
	 */
	@Override
	public String getEventPort() {
		return eventPort;
	}

	public int cmdPort = 0;

	/**
	 * @return the cmdPort
	 */
	@Override
	public int getCmdPort() {
		return cmdPort;
	}

	public String eventPort = null;

	Profile pluginProfile = null;
	// new member variable added as part of CR377 workitem1.1
	private String x36Version = "";
	/** field added to check whether control plane is enabled or not **/
	private boolean controlPlaneManagement = false;

	/**
	 * constructor
	 *
	 * @param plugIn
	 * @throws SBIInitializationException
	 */
	public SBIClient(final I36PlugIn plugIn) throws SBIInitializationException {
		this.plugIn = plugIn;
		sbiClient = this;
	}

	public static SBIClient getInstance() {
		return sbiClient;
	}

	/**
	 * Gets the Plugin
	 */

	@Override
	public I36PlugIn getPlugIn() {
		return plugIn;
	}

	@Override
	public String toString() {
		if (plugIn != null) {
			return plugIn.getName();
		}

		return "NO PLUGIN";
	}

	/**
	 * @return Plugin EM Id
	 * @see com.marconi.fusion.tmf.i36PlugIn.I36PlugIn#getEMId()
	 */

	@Override
	public String getEMId() {
		return plugIn.getEMId();
	}

	/**
	 * @return the realignmentManager
	 */

	@Override
	public RealignmentManager getRealignmentManager() {
		return realignmentManager;
	}

	/**
	 * Get MEDn list
	 *
	 * @return MEDnList
	 */

	@Override
	public MEDnList getMEDnList() {
		final MEDnList neLocList = meInfos.getManagedIdList();
		return neLocList;
	}

	/**
	 * Sets MEDn list
	 *
	 * @param list
	 */
	public void setMEDnList(final MEDnList list) {

		final MEDnList added = new MEDnList();
		final MEDnList removed = new MEDnList();
		// final List<String> neLocList = naming.getNesId(list);

		meInfos.setNeIdList(list, added, removed);
		if (BaseApplication.getApplication().getCommandLine()
				.hasOption("readBer")) {
			startBERRealignment(list);
			performRestOfTheBerRealignment();
		} else {
			realignNes(added);
			doDeprovisioning(removed);
		}
	}

	/**
	 * Loads NE Id
	 *
	 * @param list
	 *            - MEDnList
	 */
	private void loadNEId(final MEDnList list) {
		final MEDn2Id dn2Id = MEInformation.getMeDn2Id();

		for (final MEDn dn : list) {
			final int id = dn2Id.get(dn);
			if (id != -1) {
				final X36NeId neId = new X36NeId(id);
				final String hostName = getHostName(dn, false);
				naming.insert(neId, dn, hostName);
			}
		}
	}

	/**
	 * Gets inventory support
	 *
	 * @return InventorySupport
	 */

	@Override
	public InventorySupport getInventorySupport() {
		return inventorySupport;
	}

	@Override
	public String getNeLocator(final X36NeId neId, final X36SBIHostName sbiHostName) {
		final String neLocator = getNeLocator(neId, sbiHostName.getValue());
		return neLocator;
	}

	@Override
	public String getNeLocator(final X36NeId neId, final String sbiHostName) {
		// final MEDn dn = naming.makeMEDn(neId, sbiHostName);
		final MEDn dn = null;
		final Map<String, EmDetails> hostDetails = getPlugIn().gethostIds();
		final EmDetails emDetails = hostDetails.get(sbiHostName);
		String emId = null;
		if (!isStandAlone()) {
			emId = emDetails.getEmId() + "";
		} else {
			emId = plugIn.getEMId();
		}
		String neLocator = null;
		// if (isStandAlone() || dn != null) {
		if (dn != null) {
			neLocator = TmfNameUtilities.toString(dn);
		} else {
			final StringBuilder buf = new StringBuilder();

			buf.append(emId).append(":");
			buf.append(neId.getValue());

			neLocator = buf.toString();
		}
		return neLocator;
	}

	/**
	 * Get Ne Locator
	 */

	@Override
	public String getNeLocator(final MEDn meDn) {

		final MEId meId = meDn.getMe();
		final X36NeId neId = getNaming().getNeId(meId);
		Session session = null;
		String neLocator = null;

		try {
			if (isStandAlone() || meDn != null) {
				neLocator = TmfNameUtilities.toString(meDn);
			} else {
				session = getDbManager().beginSession(false);
				final DBManagedElement dbME = getDbManager().getManagedElement(meDn);
				// Extracting EMId from Additional Info of ME
				final EmSystemProfile emSystemProfile = getEmSystemProfile(dbME);

				final StringBuilder buf = new StringBuilder();
				final int emId = emSystemProfile.getSyntax().getSbiId().getValue();

				buf.append(emId).append(":");
				buf.append(neId.getValue());

				neLocator = buf.toString();
			}
		} catch (final Exception e) {
			LOG.error("Can not able to get NeLocator" + e);
		} finally {
			if (session != null) {
				session.terminate();
			}
		}
		return neLocator;
	}

	/**
	 * Get all MEs
	 *
	 * @return ManagedElementList
	 * @throws PlugInException
	 */
	public ManagedElementList getAllMEs() throws PlugInException {
		final ManagedElementList list = getMEList();

		final ManagedElementList out = new ManagedElementList();

		final MEDnList supported = getMEDnList();

		for (final ManagedElement item : list) {
			if (supported.contains(item.getName())) {
				out.add(item);
				supported.remove(item.getName());
			}
		}

		return out;
	}

	/**
	 * Get Profile
	 *
	 * @return Profile
	 */

	@Override
	public Profile getProfile() {
		return plugIn.getProfile();
	}

	/**
	 * @return the naming
	 */

	@Override
	public I36Naming getNaming() {
		return naming;
	}

	/**
	 * @return the secondaryNameMaker
	 */

	@Override
	public IndexesMaker getIndexesMaker() {
		return indexesMaker;
	}

	/**
	 * @return a secondaryNameManager
	 */

	@Override
	public KeysMaker getKeysMaker() {
		return keysMaker;
	}

	/**
	 * Get DbManager
	 *
	 * @return I36DatabaseManager
	 */

	@Override
	public I36DatabaseManager getDbManager() {
		synchronized (dbManagerLock) {
			if (dbManager != null) {
				return dbManager;
			}

			final String value = plugIn.getProfile().getProperty(PluginProperty.databaseManagerConfiguration);
			if ((value != null) && new File(value).isFile()) {
				final Properties prop = Utility.getProperties(value);
				dbManager = new I36DatabaseManager(this, plugIn.getDatabaseManager(), new Profile(prop));
			} else {
				dbManager = new I36DatabaseManager(this, plugIn.getDatabaseManager());
			}

			return dbManager;
		}
	}

	/**
	 * Get message handler
	 *
	 * @return I36MessageHandler
	 */

	@Override
	public I36MessageHandler getMessageHandler() {
		return messageHandler;
	}

	/**
	 * @return Plugin name
	 */

	@Override
	public String getName() {
		return plugIn.getName();
	}

	/**
	 * Gets the Event Manager
	 *
	 * @return IEventConsumer
	 */

	@Override
	public IEventConsumer getEventManager() {
		return plugIn.getEventConsumer();
	}

	/**
	 * @return the meInfos
	 */

	@Override
	public MEInfos getMeInfos() {
		return meInfos;
	}

	/**
	 * @return the actionDelayer
	 */

	@Override
	public ActionDelayer getActionDelayer() {
		return actionDelayer;
	}

	/**
	 * Adds NeId on EM list
	 *
	 * @param meDn
	 *            - MEDn
	 * @param emHostName
	 *            - String
	 */
	@Override
	public void addNeIdOnEmList(final MEDn meDn, final String emHostName) {
		if(emNeIdsMap.containsKey(emHostName)){
			emNeIdsMap.get(emHostName).add(meDn);
		} else {
			final MEDnList meDnList = new MEDnList();
			meDnList.add(meDn);
			emNeIdsMap.put(emHostName, meDnList);
		}
	}

	/**
	 * Removes NeId on EM list
	 *
	 * @param neId
	 *            - X36NeId
	 */

	@Override
	public void removeNeIdOnEmList(final MEDn meDn, final String emHostName) {
		emNeIdsMap.get(emHostName).remove(meDn);
	}

	/**
	 * Checks whether NeId is there on EM list
	 *
	 * @param neId
	 *            - X36NeId
	 * @param hostName
	 *            - String
	 */
	@Override
	public boolean isNeIdOnEmList(final MEDn dn, final String emHostName) {
		return emNeIdsMap.get(emHostName).contains(dn);
	}

	/**
	 * Initializing SBI
	 */
	@Override
	public void init(final IEventConsumer evm) throws WrongInitializationException {

		if (LOG.isDebugEnabled()) {
			LOG.debug(String.format("Initializing X36SBI <%s>: START....", getName()));
		}

		pluginProfile = plugIn.getProfile();

		try {
			if (isStandAlone()) {
				sbiKey = setKey();

				sbiManager = new SBIManager();

				sbiManager.addSBI("X36SBI", getProfile(), plugIn.getName(), sbiKey);
				SBIContainer.getInstance().getSbiObj(sbiKey).init(evm);
			}
			x36Version = initX36Version();
		} catch (final Exception ex) {
			LOG.error(ex);
			throw new WrongInitializationException(ex.getCause());
		}

		naming = new I36Naming(this);
		indexesMaker = new IndexesMaker(this);
		keysMaker = new KeysMaker();

		LOG.debug("Initializing RealignmentManager");
		realignmentManager = new RealignmentManager(this);

		LOG.debug("Initializing ProtectionSyncManager");
		protectionSynchManager = new ProtectionSynchManager(this);

		eventHandler = plugIn.isStandAlone() ? new StandAloneEventHandler(this) : new EventHandler(this);

		actionDelayer = new ActionDelayer(BaseApplication.getApplication().getTimerHandler());

		plugIn.addInternalPropertyChangeListener(this);

		LOG.debug("Initializing DoubleChannel");

		protectionSwitchRaiser = new ProtectionSwitchRaiser(this);

		eventCollector = new EventCollector(this);
		eventCollector.init();
		realignmentManager.addRealignmentEventListener(eventCollector);
		realignmentManager.addRealignmentEventListener(this);

		final long timeout = plugIn.getProfile().getTimeProperty(EmSBIPluginProperty.sbiTimeout, 0); // 0
		// is
		// forever

		meDeletionDelay = plugIn.getProfile().getTimeProperty(PluginProperty.meDeletionDelay, 0);

		LOG.debug("Initializing MessageHandler");
		messageHandler = new I36MessageHandler(this);
		messageHandler.setTimeout(timeout);

		LOG.debug("Initializing InventorySupport");
		inventorySupport = new InventorySupport(this);
		controlPlaneManagement = plugIn.getProfile().getBoolProperty(PluginProperty.ControlplaneManagement, false);

		if (LOG.isDebugEnabled()) {
			LOG.debug(String.format("Initializing X36SBI <%s>: DONE.", getName()));
		}

		LOG.info(String.format("Plugin is using I36 version: %s", I36.getModule().getVersion()));
	}

	/**
	 * Start SBI, Inventory Support, Realignment, ProtectionSynch
	 */

	@Override
	public void start() throws PlugInException {
		LOG.info(String.format("SBI for EM <%s> is starting...", getName()));
		try {
			if (isStandAlone()) {
				loadAllManagedElements();
				eventCollector.start(sbiKey);
				messageHandler.startMessageHandler(sbiKey);
				protectionSynchManager.start(sbiKey);
			}

			inventorySupport.start();

			realignmentManager.setStartUpGetNodePossibleConfiguration(true);

			if (!BaseApplication.getApplication().getCommandLine().hasOption("readBer")) {

				if (isStandAlone()) {
					final FirstConnectionHandler handler = new FirstConnectionHandler();

					((X36MsgClient) SBIContainer.getInstance().getSbiObj(sbiKey)).addListener(handler);
					((X36MsgClient) SBIContainer.getInstance().getSbiObj(sbiKey)).start(getProfile());
				}

				else {
					final Map<String, EmDetails> neMap = plugIn.gethostIds();
					SBI sbi = null;
					for (final EmDetails emDetails : neMap.values()) {
						sbi = SBIContainer.getInstance().getSbiObj(emDetails.getSbiKey());
						if (sbi.isConnected()) {
							final OtherConnectionHandler handler = new OtherConnectionHandler();
							((X36MsgClient) sbi).addListener(handler);
						} else {
							final FirstConnectionHandler handler = new FirstConnectionHandler();
							((X36MsgClient) sbi).addListener(handler);
						}
					}

				}

				/**
				 * il semaforo viene sbloccato al termine del riallineamento ma
				 * se non c'e' la connessione si rimane bloccati allora si
				 * piazza anche un timer!!
				 */
				final boolean synchro = getProfile().getBoolProperty(I36PlugIn.PluginProperty.synchronousStart, true);
				// build Me Cache when Synchro is to false

				if (!synchro) {
					return;
				}

				final long delay = getProfile().getTimeProperty(I36PlugIn.PluginProperty.timeoutOnFirstConnection, -1);
				if (delay > 0) {
					startTimerId = BaseApplication.getApplication().getTimerHandler().startTimer(this, delay, null);
				}
				if (isStandAlone()) {
					startSemaphore.acquire();
				}
				LOG.info(String.format("SBI for EM <%s> started.", getName()));

			} else {
				// Added as part of CR375: As TMF will not be connected to
				// SO-EM, getting SetOfNeIds to be realigned, from the
				// name of the BER files
				try {
					final String berLoc = getProfile().getProperty(
							I36PlugIn.PluginProperty.realignmentBerHome);
					X36SetOfNeId setOfNeIds = null;

					if (isStandAlone()) {
						setOfNeIds = BERReader.getNodeList(getEMId(), berLoc);
						final BERReader reader = new BERReader(null);
						if (setOfNeIds != null && setOfNeIds.size() > 0) {
							processNes(reader.getNetworkElements(getEMId(), berLoc,
									getProfile(), setOfNeIds));
							final MEDnList meNames = loadMEList();
							startBERRealignment(meNames);
							performRestOfTheBerRealignment();

						}
						LOG.info("Realignment of NEs in BER realignment mode is done successfully, shutdown of application is started");
						onExitingApplication();
					}
				}
				catch (final Exception e) {
					LOG.error(new DumpInfo(e,
							"Error occured during realignment of NEs in Ber realignment mode"));

				}
			}
		} catch (final X36MsgClientException exSbi) {
			LOG.error(exSbi);
			throw new PlugInException(com.marconi.fusion.tmf.plugIn.types.ExceptionType.EXCPT_INTERNAL_ERROR, exSbi.getMessage());
		} catch (final Exception e) {
			LOG.error(e);
			throw new PlugInException(com.marconi.fusion.tmf.plugIn.types.ExceptionType.EXCPT_INTERNAL_ERROR, e.getMessage());
		}
	}

	private void performRestOfTheBerRealignment() {
		if (getRealignmentManager().getPostedNes() == 0 && getRealignmentManager().getInRealignmentNes() == 0) {
			/*
			 * SNCs which are in pending state and topological links will not be present in DB, so creating those objects by using
			 * the data exported to SNC_Syntax file and TL_Syntax file
			 */
			final PendingSNCImportUtility pendingSncUtil = new PendingSNCImportUtility();
			pendingSncUtil.createSNCs(this);

			final TLImportUtility tlImportUtil = new TLImportUtility();
			tlImportUtil.createTopologicalLinks(this);

			// Importing TCA Parameter Profiles during BER realignment because in previous versions, TCA parameter
			// profiles used to be exported into realignCustomerData tar files instead of normal Customer data.
			// So, when they are exported in old versions and imported into TMF4.1, the exported files will be
			// accessed from realignCustomerData tar.
			final TCAPPImportUtility tcaPPImportUtil = new TCAPPImportUtility();
			tcaPPImportUtil.createTCAPPs(this);

		}
	}
	/**
	 * SBI shutdown
	 */

	@Override
	public void shutdown() throws PlugInException {
		try {
			LOG.info(String.format("On EM <%s> Shutting down command and event channels", getName()));
			if (isStandAlone()) {
				SBIContainer.getInstance().getSbiObj(sbiKey).shutdown();
				sbiManager.deleteSBI(SBIContainer.getInstance().getSbiObj(sbiKey));
			}

			else {
				final Map<String, EmDetails> neMap = plugIn.gethostIds();
				for (final EmDetails emDetails : neMap.values()) {
					SBIContainer.getInstance().shutdownSbi(emDetails.getSbiKey());
				}
				realignmentManager.shutdown();
				protectionSynchManager.shutdown();
				inventorySupport.shutdown();
			}
		} catch (final Exception e) {
			LOG.error(e);
		}
	}

	/**
	 * @return
	 * @see com.marconi.fusion.tmf.i36PlugIn.I36PlugIn#isStandAlone()
	 */

	@Override
	public boolean isStandAlone() {
		return plugIn.isStandAlone();
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.marconi.fusion.tmf.i36PlugIn.SBIClientI#isAlarmsUnacknowledged()
	 */

	@Override
	public boolean isAlarmsUnacknowledged() {
		return plugIn.isAlarmsUnacknowledged();
	}

	/**
	 * Checks whether SBI is connected or not
	 */
	public boolean isConnected() {

		return SBIContainer.getInstance().getSbiObj(sbiKey).isConnected();
	}

	/**
	 * Property change event fired when a property change event occurs
	 */

	@Override
	public void propertyChange(final PropertyChangeEvent evt) {
		final String name = evt.getPropertyName();
		final Object source = evt.getSource();

		if (source == plugIn) {
			if (name.equals(I36PlugIn.MEDNLIST_PROPERTY)) {
				final MEDnList list = (MEDnList) evt.getNewValue();
				setMEDnList(list);
			} else if (name.equals(I36PlugIn.UPDATEME_PROPERTY)) {
				final MEDn meDn = (MEDn) evt.getNewValue();
				realignNe(meDn);
			} else if (name.equals(I36PlugIn.START_PROVISION)) {
				final Map<String, EmDetails> hostDetails = (evt.getNewValue() instanceof Map) ? (Map<String, EmDetails>) evt
						.getNewValue() : new HashMap<String, EmDetails>();
						final Set<String> hostNameSet = hostDetails.keySet();
						final Iterator<String> hostNameItr = hostNameSet.iterator();
						while (hostNameItr.hasNext()) {
							startProvisioning(hostNameItr.next());
						}
						starting = false;
			}
		} else if (source instanceof X36SBI) {
			final String hostName = ((X36SBI) source).getHostName();
			if (!(hostName == null)) {
				final SBIKey key = new SBIKey(getPlugIn().getClass().getSimpleName(), hostName);
				if (source == SBIContainer.getInstance().getSbiObj(key) && name.equals(X36SBI.SBI_CONNECTED)) {
					final Boolean value = (Boolean) evt.getNewValue();
					onConnection(value.booleanValue(), new X36SBIHostName(hostName));
				}
			} else {
				LOG.error(" Could not get hostName from SBI ");
			}
		}

	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.marconi.fusion.tmf.i36PlugIn.realignment.RealignmentEventListener
	 * #onEvent(com.marconi.fusion.tmf.i36PlugIn.realignment .RealignmentEvent)
	 */

	@Override
	public void onRealignmentEvent(final RealignmentEvent event) {
		final Object source = event.getSource();
		MEDn meDn = new MEDn();
		if (source == realignmentManager) {
			if (event instanceof EndRealignmentEvent) {
				final EndRealignmentEvent end = (EndRealignmentEvent) event;
				meDn = end.getMeDn();
				// final X36NeId neId = end.getNeId();

				meInfos.setState(MEInfos.MEState.uploaded, meDn, true);

				/*
				 * ATTENZIONE siccome non mando il deprovisioning allora faccio
				 * il provisioning SOLO sui linkup e su created NE bella
				 * cazzata.... cosi' ci perdiamo gli allarmi che arrivano prima
				 * che riusciamo a riallineare l'NE.... lo mandiamo ma solo se
				 * non siamo in start perche' in questo caso ci pensiamo nel
				 * metodo onFirstConnection se siamo standAlone o ci pensa il
				 * plugin del 38
				 */
				if (starting == false) {
					// final X36SetOfNeId setOf = new X36SetOfNeId();
					final MEDnList meDnList = new MEDnList();
					meDnList.add(meDn);
					doProvisioning(meDnList, false);
				}

				final MERealignmentEnd re = new MERealignmentEnd(end.getMeDn(), end.isCompleted(), end.getCause());

				PluginEventDispatcher.getPluginEventDispatcher().postEvent(re);
			} else if (event instanceof BeginRealignmentEvent) {
				final BeginRealignmentEvent begin = (BeginRealignmentEvent) event;
				meDn = begin.getMeDn();
				// final X36NeId neId = begin.getNeId();
				meInfos.setState(MEInfos.MEState.uploaded, meDn, false);

				final MERealignmentStart re = new MERealignmentStart(begin.getMeDn());

				PluginEventDispatcher.getPluginEventDispatcher().postEvent(re);
			}

			// Check if realignment of all NE's are Done
			if (getRealignmentManager().getPostedNes() == 0 && getRealignmentManager().getInRealignmentNes() == 0
					&& (forceRealignmentMEDn == null || !forceRealignmentMEDn.equals(meDn))) {

				plugIn.notifyRealignmentEnd("RealignmentEnd");
			}
		}
	}

	/**
	 * to check whether control plane is set or not
	 */
	@Override
	public boolean isControlPlaneManagementEnabled() {
		return controlPlaneManagement;
	}

	/**
	 * Checks whether the MEDn is associated or not
	 *
	 * @param dn
	 *            - MEDn
	 * @return boolean
	 */
	public boolean isAssociated(final MEDn dn) {
		return meInfos.getState(MEState.linkup, dn);
	}

	/**
	 * Checks whether the ME is managed or not
	 *
	 * @param meId
	 *            - MEId
	 * @return boolean
	 */
	public boolean isManaged(final MEId meId) {
		final MEDn dn = new MEDn();

		dn.setMe(meId);

		return isManaged(dn);
	}

	/**
	 * Checks whether the neId is managed or not
	 *
	 * @param neId
	 *            - X36NeId
	 * @return boolean
	 */
	public boolean isManaged(final MEDn meDn) {
		return meInfos.isManaged(meDn);
	}

	/**
	 *
	 * @param mEIdAndHost
	 * @return
	 */
	public boolean isManaged(final MEIdAndHost mEIdAndHost) {
		return meInfos.isManaged(mEIdAndHost);
	}

	/**
	 * This is called whenever an event (like linkUp, linkDown etc) occurs
	 */

	@Override
	public void onEventReport(final X36EventDetailReport report) {
		final X36EventDetail detail = report.getEventDetail();

		final X36SBIHostName sbiHostName = report.getSbihostName();
		try {
			switch (detail.getMemberId()) {
			case X36EventDetail.linkUp:
				eventHandler.onLinkUp(report.getNeId(), sbiHostName);
				break;
			case X36EventDetail.linkDown:
				eventHandler.onLinkDown(report.getNeId(), sbiHostName);
				break;
			case X36EventDetail.neVisualState:
				eventHandler.onNeVisualState(report.getNeId(), detail.getNeVisualState(), sbiHostName);
				break;
			case X36EventDetail.modifiedNe:
				eventHandler.onModifyNe(report.getNeId(), detail.getModifiedNe(), sbiHostName);
				break;
			case X36EventDetail.modifiedNeName:
				eventHandler.onModifiedNeName(report.getNeId(), detail.getModifiedNeName(), sbiHostName);
				break;
			case X36EventDetail.createdNe:
				eventHandler.onCreateNe(detail.getCreatedNe(), sbiHostName);
				break;
			case X36EventDetail.deletedNe:
				eventHandler.onDeleteNe(detail.getDeletedNe(), sbiHostName);
				break;
			case X36EventDetail.protectionChangeEvent:
				onProtectionChangeEvent(report);
				break;
			case X36EventDetail.modifiedNeAddress:
				eventHandler.onModifiedNeAddress(report.getNeId(), detail.getModifiedNeAddress(), sbiHostName);
				break;
			case X36EventDetail.alarmResourceEnableState:
				final X36AlarmResourceDetails rsrcDetails = detail.getAlarmResourceEnableState();
				final X36NeId neId = rsrcDetails.getAlarmResource().getNeId();
				final X36ShelfId shelfId = rsrcDetails.getAlarmResource().getShelfId();
				final X36CardId cardId = rsrcDetails.getAlarmResource().getCardId();
				final MEDn meDn = new MEDn();
				meDn.setMe(naming.get(neId, report.getSbihostName().getValue()));
				if (shelfId != null) {
					eventHandler.onAlarmResourceEnabledOrDisabled(meDn, shelfId, cardId,
							rsrcDetails.getEnableState().isEnabled(), sbiHostName);
				}

				break;
				/**
				 * la creazione cancellazione degli ME e' gestita dal plugin perche'
				 * va effettuata se siamo in modalita' standAlone (perche'
				 * altrimenti ci pensa il plugin del 38)
				 */
			default:
				break;
			}
		} catch (final Exception e) {
			LOG.error(new DumpInfo("Error managing event...", e));
		}
	}

	public class MEDetails {
		public MEDn getMeDn() {
			return meDn;
		}

		public void setMeDn(final MEDn meDn) {
			this.meDn = meDn;
		}

		public boolean isNeUp() {
			return neUp;
		}

		public void setNeUp(final boolean neUp) {
			this.neUp = neUp;
		}

		public X36NetworkElement getNeId() {
			return neId;
		}

		public void setNeId(final X36NetworkElement neId) {
			this.neId = neId;
		}

		MEDn meDn = null;
		boolean neUp = true;
		X36NetworkElement neId = null;

		MEDetails(final MEDn meDn, final boolean neUp, final X36NetworkElement neId) {
			this.meDn = meDn;
			this.neUp = neUp;
			this.neId = neId;
		}

	}

	/**
	 * Called on Connection of SBI
	 *
	 * @param connected
	 */
	protected synchronized void onConnection(final boolean connected, final X36SBIHostName sbiHostName) {
		if (connected) {
			/*
			 * abbiamo ri-ottenuto la connessione, ricarico la lista dei nodi e
			 * restarto il provisioning
			 */
			if (LOG.isInfoEnabled()) {
				LOG.info(String.format("Connection with EM <%s> aquired.", getName()));
			}

			realignmentManager.resume(sbiHostName.getValue());
			getSBIVersion(sbiHostName);

			// Retrieve all the nodes from EM
			X36SetOfNetworkElement nodeList = loadNodeList(sbiHostName.getValue());
			final List<MEDetails> meDetailList = new ArrayList<MEDetails>();
			for (final X36NetworkElement neId : nodeList) {
				final MEDn meDn = new MEDn();
				MEId meId = naming.get(neId.getNeId(), sbiHostName.getValue());
				if (meId == null) {
					if (!isStandAlone()) {
						final String nmName = getProfile().getProperty("PlugIn.NMName", "MV38");
						final int emId = plugIn.gethostIds().get(sbiHostName.getValue()).getEmId();
						meId = new MEId(String.format(ME_NAME_FORMAT, nmName, emId, neId.getNeId().getValue()));
						naming.insert(neId.getNeId(), meId, sbiHostName.getValue());
					} else {
						continue;
					}
				}
				meDn.setMe(meId);
				final boolean neUp = neId.getNeUsageState().isAssociate();
				final MEDetails meDetails = new MEDetails(meDn, neUp, neId);
				meDetailList.add(meDetails);
			}
			final MEDnList newNEs = setCommunicationState(nodeList, meDetailList);

			for (final X36NetworkElement ne : nodeList) {

				final String neModel = ne.getNeInfo().getNeModel().getValue();
				this.getPlugIn().getNeModelMapper().setNeModelIntoMap(ne.getNeId().getValue(), neModel);
			}

			// Remove the Nes from the nodeList which are already existing in
			// the database

			final Iterator<X36NetworkElement> neItr = nodeList.iterator();
			while (neItr.hasNext()) {
				final X36NeId neId = neItr.next().getNeId();
				final MEDn meDn = naming.makeMEDn(neId, sbiHostName.getValue());
				if (!newNEs.contains(meDn)) {
					neItr.remove();
				}
			}

			// If the TMF is running in Standalone mode then process all the NEs
			// and create all the NEs in the DB.

			if (isStandAlone()) {
				processNes(nodeList);
			}
			nodeList = null;
			final MEDnList managedMeDnList = meInfos.getManagedIdList();

			if (managedMeDnList.size() > 0) {
				getDbManager().deleteAllAdditionaInfoAllPGP(managedMeDnList,
						new String[] { MSPProtectionInfo.NAME, BshrConfiguration.NAME, EquipmentProtectionInfo.NAME });
				getDbManager().deleteAllCrossConnectionInfo(managedMeDnList);
			}

			if (isStandAlone()) {
				removeMEs(); // I have to remove ME not longer in charge to EM
			}

			startProvisioning(sbiHostName.getValue());

		} else {
			if (LOG.isInfoEnabled()) {
				LOG.info(String.format("Connection EM <%s> lost.", getName()));
			}
			realignmentManager.suspend(sbiHostName.getValue());
			final MEDnList meDnList = setState(sbiHostName.getValue());

			/*
			 * GG 13/03/2008 marchiamo tutti gli ME con non connessi
			 */
			getDbManager().setNEState(meDnList, false, null);
		}
	}

	/**
	 * sets MEState
	 * 
	 * @param hostName
	 * @return MEDnList
	 */
	private MEDnList setState(final String hostName) {
		final MEDnList meDnList = meInfos.getManagedIdList();
		if (isStandAlone()) {
			meInfos.setState(MEInfos.MEState.linkup, false);
			meInfos.setState(MEInfos.MEState.alarm, false);
		} else {
			final MEDnList emMEDnList = plugIn.getEmNEDetails().get(hostName);
			final MEDnList tempList = new MEDnList();
			tempList.set(meDnList);
			for (final MEDn meDn : tempList) {
				if (!emMEDnList.contains(meDn)) {
					meDnList.remove(meDn);
				}
			}
			meInfos.setState(MEInfos.MEState.linkup, meDnList, false);
			meInfos.setState(MEInfos.MEState.alarm, meDnList, false);
		}

		return meDnList;
	}
	/**
	 * Called on First Connection of SBI
	 */
	protected synchronized void onFirstConnection(final String hostName) {
		/*
		 * abbiamo ottenuto la connessione per la prima volta riallineo in modo
		 * sincrono
		 */
		BaseApplication.getApplication().getTimerHandler().stopTimer(startTimerId);
		startTimerId = null;

		if (LOG.isInfoEnabled()) {
			LOG.info(String.format("Connection with EM <%s> acquired for the first time.", getName()));
		}

		realignmentManager.resume(hostName);

		X36SetOfNetworkElement nodeList = new X36SetOfNetworkElement();
		getSBIVersion(new X36SBIHostName(hostName));
		nodeList = loadNodeList(hostName);

		final List<MEDetails> meDetailList = new ArrayList<MEDetails>();
		for (final X36NetworkElement neId : nodeList) {
			final MEDn meDn = new MEDn();
			final MEId meId = naming.get(neId.getNeId(), hostName);
			meDn.setMe(meId);
			final boolean neUp = neId.getNeUsageState().isAssociate();
			final MEDetails meDetails = new MEDetails(meDn, neUp, neId);
			meDetailList.add(meDetails);
		}
		final MEDnList newNEs = setCommunicationState(nodeList, meDetailList);

		final boolean alarmSuprressionEnabled = getProfile().getBoolProperty(
				I36PlugIn.PluginProperty.alarmSuppressionOnPortWithoutConnections, false);
		/*
		 * Count can be updated only when the property
		 * alarmSuppressionOnPortWithoutConnections is set to true
		 */
		if (alarmSuprressionEnabled) {
			updateCountOnPort(hostName);
		}
		final boolean synchro = getProfile().getBoolProperty(I36PlugIn.PluginProperty.synchronousStart, true);
		MEDnList nesProvisioned = null;
		if (!synchro) {
			try {
				plugIn.buildCacheOnNoSynchStart(nodeList, hostName);
				final MECache meCache = plugIn.getMECache(hostName);
				if (meCache != null) {
					nesProvisioned = doProvisioningOnNoSynchStart();
				}
			} catch (final Exception e) {
				LOG.error("Unable to build the MECache in Non-Synchronous start.", e);
			}
		}
		// If the TMF is running in Standalone mode then process all the NEs
		for (final X36NetworkElement ne : nodeList) {

			final String neModel = ne.getNeInfo().getNeModel().getValue();
			this.getPlugIn().getNeModelMapper().setNeModelIntoMap(ne.getNeId().getValue(), neModel);
		}

		// Remove the Nes from the nodeList which are already existing in the
		// database

		final Iterator<X36NetworkElement> neItr = nodeList.iterator();
		while (neItr.hasNext()) {
			final X36NeId neId = neItr.next().getNeId();
			final MEDn meDn = naming.makeMEDn(neId, hostName);
			if (!newNEs.contains(meDn)) {
				neItr.remove();
			}
		}

		if (isStandAlone()) {
			processNes(nodeList);
		}

		try {
			if (synchro) {
				plugIn.buildMECache(hostName);
			}
		} catch (final Exception exp) {
			LOG.error(new DumpInfo(exp, "Exception while trying to build MECache"));
		}

		/*
		 * adesso starto il riallineamento per tutti gli ne che ho in pancia e
		 * mi sincronizzo per il termine usando un semaforo GG 27/8/2008 dovrei
		 * anche buttare quelli che non ho piu' nel caso sia stand-alone per
		 * fare questo mi carico l'elenco dei ME e poi lo sfando in fondo
		 */
		final MEDnList setOf = meInfos.getManagedIdList();
		// Filter the Managed NEs for the particular EM in TMFoNM mode
		if (!isStandAlone()) {
			final MEDnList meDnLst = plugIn.getEmNEDetails().get(hostName);
			final MEDnList managedDnLst = new MEDnList(setOf);
			final Iterator<MEDn> itrMeDn = managedDnLst.iterator();
			while (itrMeDn.hasNext()) {
				final MEDn meDn = itrMeDn.next();
				if (!meDnLst.contains(meDn)) {
					setOf.remove(meDn);
				}
			}
		}
		final boolean fRealignAll = getProfile().getBoolProperty(PluginProperty.realignmentAtBoot, true);

		if (setOf.size() > 0) {
			getDbManager().deleteAllAdditionaInfoAllPGP(setOf,
					new String[] { MSPProtectionInfo.NAME, BshrConfiguration.NAME, EquipmentProtectionInfo.NAME });
			getDbManager().deleteAllCrossConnectionInfo(setOf);
		}

		if (LOG.isInfoEnabled()) {
			LOG.info(String.format("Realignment at boot on EM <%s> is %s.", getName(), (fRealignAll ? "ENABLED" : "DISABLED")));
		}
		/*
		 * per motivi prestazionali il provisioning non lo mandiamo alla fine
		 * dei riall. a meno che non sia il primo
		 */
		if (provisioningSemaphore != null) {
			try {
				provisioningSemaphore.acquire();
			} catch (final InterruptedException e) {
				LOG.error("Exception while acquiring proviosiong semaphore", e);
			}
			doDeprovisioning(nesProvisioned);
			provisioningSemaphore = null;
		}
		if (fRealignAll) {
			realignNes(setOf, true);
		} else {
			getDbManager().setNEState(setOf, true, null);
		}

		/*
		 * Now the provisioning is started if I am standalone otherwise the I38
		 * plugin will call it
		 */
		if (isStandAlone()) {
			// I have to remove ME not longer in charge to EM
			removeMEs();
			// Before provisioning phase, need to synchronize alarm reporting
			// between TMF and SO-EM
			synchronizeAlarmReportingOnResources(hostName);
			if (setOf.size() > 0) {
				doProvisioning(setOf, false); // faccio il provisioning di tutto
			} else {
				/**
				 * Fix for TR HO80385 : When TMF is started with SOEM that has
				 * no NEs, provisioning request without Nes list is sent to
				 * SOEM. Otherwise SOEM will not send any event like neAdded.
				 */
				sendProvisioningWithoutNes();
			}
		}
		initiateNodePossibleconfiguration(setOf);
		if (isStandAlone()) {
			startSemaphore.release();
		}
		if (isStandAlone()) {
			starting = false;
		}
		realignmentManager.setStartUpGetNodePossibleConfiguration(false);
	}

	/**
	 * Realign Ne
	 *
	 * @param meDn
	 *            - MEDn
	 */

	@Override
	public void realignNe(final MEDn meDn) {
		// final X36NeId neId = getNaming().getNeId(meDn);
		// realignNe(neId);
		final MEDnList list = new MEDnList();
		list.add(meDn);
		realignNes(list);
	}

	/**
	 * Realign Ne
	 *
	 * @param neId
	 *            - X36NeId //
	 */
	// public void realignNe(final X36NeId neId) {
	// final X36SetOfNeId setOf = new X36SetOfNeId();
	// setOf.add(neId);
	//
	// realignNes(setOf);
	// }

	/**
	 * Realign Nes
	 *
	 * @param setOf
	 *            - X36SetOfNeId
	 */
	// public void realignNes(final X36SetOfNeId setOf) {
	// final boolean synchro =
	// getProfile().getBoolProperty(I36PlugIn.PluginProperty.synchronousNodeRealignment,
	// false);
	//
	// realignNes(setOf, synchro);
	// }

	public void realignNes(final MEDnList setOf) {
		final boolean synchro = getProfile().getBoolProperty(I36PlugIn.PluginProperty.synchronousNodeRealignment, false);

		realignNes(setOf, synchro);
	}

	/**
	 * Remove MEs
	 */
	protected void removeMEs() {
		/*
		 * I should remove ME not longer used and also their SN
		 */

		LOG.info(String.format("Check for MEs to be removed on <%s>", getName()));

		final MEDnList dnList = getMEDnList();
		final I36DatabaseManager manager = getDbManager();
		Session session = null;
		int count = 0;

		try {
			session = manager.beginSession(true);
			final List<DBManagedElement> list = getDBManagedElements();

			for (final DBManagedElement item : list) {
				final MEDn meDn = item.getDn();
				if (dnList.contains(meDn)) {
					continue;
				} else {
					/*
					 * Fix for TR HN35687 The usage of MEDeletion job is removed
					 * form this context(Realignment Context). Since in this
					 * context, the MEs which are to be deleted are old MEs.
					 * These MEs could be removed instantly(in the realignment)
					 * rather than using Deletion job. *
					 */
					final String meName = item.getName();
					if (LOG.isDebugEnabled()) {
						LOG.debug(String.format("Removing ME <%s> (and its SN)", meName));
					}

					try {
						final DBIterator<DBSubnetwork> snItr = item.getSubnetworks().iterator();
						final List<DBSubnetwork> snList = new ArrayList<DBSubnetwork>();
						while (snItr.hasNext()) {
							snList.add(snItr.next());
						}
						snItr.close();

						// collecting all FDs on this ME

						final DBManyRelationship<DBMatrixFlowDomain> mfds = item.getMFDs();
						if (mfds.size() > 0) {
							final List<DBFlowDomain> fdList = new ArrayList<DBFlowDomain>();
							final DBIterator<DBMatrixFlowDomain> mfdItr = mfds.iterator();
							while (mfdItr.hasNext()) {
								final DBMatrixFlowDomain dbMfd = mfdItr.next();
								final DBFlowDomain fd = dbMfd.getAssociatingFlowDomain().get();
								if (fd != null) {
									if (!fdList.contains(fd)) {
										fdList.add(fd);
									}
								}
							}
							mfdItr.close();
							if (!fdList.isEmpty()) {
								// deleting FDs on ME
								for (final DBFlowDomain fd : fdList) {
									manager.delete(fd);
								}
							}
						}
						manager.delete(item);
						for (final DBSubnetwork sn : snList) {
							manager.delete(sn);
						}

						// Get MECache specific to this hostName
						final String hostName = getHostName(meDn, false);
						LOG.info("Obtained hostName<" + hostName + "> for MECache");
						getPlugIn().getMECache(hostName).uncache(meDn);

						ConnectionsCount.removeEntriesForME(meDn.getMe().getValue());
						if (LOG.isDebugEnabled()) {
							LOG.debug(String.format("Deleted the the ME [%s] from the MECache", TmfNameUtilities.toString(meDn)));
							getPlugIn().getMECache(hostName).dump();
							LOG.debug(String.format("Deleted all the entries for ME [%s] from connCount maps",
									TmfNameUtilities.toString(meDn)));
						}
						count++;
					} catch (final Exception e) {
						LOG.warn(String.format("Trouble removing ME <%s>", meName));
					}
				}
				if (LOG.isInfoEnabled()) {
					LOG.info(String.format("Removed %d MEs on <%s>", count, getName()));
				}

			}

			session.commit();
		} catch (final Exception e) {
			LOG.error(new DumpInfo(
					e,
					"Exception while trying to remove the MEs which are no longer present in EM but present in TMF database : "));
		}

		finally {
			if (session != null) {
				session.terminate();
			}
		}
	}

	/**
	 * This is to add an entry in the deletionJobMap when the timer is started
	 *
	 * @param neId
	 * @return neID
	 */
	public void addToDeletionJobMap(final MEDn meDn, final String hostName) {
		final MEDeletionJob job = new MEDeletionJob(meDn);
		job.initialize(this);
		job.setHostName(hostName);
		job.onDelete();
		deletionJobMap.put(meDn, job);

	}

	/**
	 * This is to remove an entry from the deletionJobMap when the timer expires
	 *
	 * @param neId
	 * @return neId
	 */

	@Override
	public boolean callbackDelete(final MEDn meDn) {
		final MEDeletionJob meDeletionJob = deletionJobMap.get(meDn);
		if (meDeletionJob != null) {
			if (meDeletionJob.onRollbackDelete() == null) {
				deletionJobMap.remove(meDn);
				return false;
			} else {
				deletionJobMap.remove(meDn);
				return true;
			}
		}
		return false;
	}

	/**
	 * @param neId
	 *            - Deletion Job which needs to be removed for the given neId
	 */
	public void removeMEDeletionJob(final int neId) {
		deletionJobMap.remove(neId);
	}

	/**
	 * Realign Nes
	 *
	 * @param setOf
	 *            - X36SetOfNeId
	 * @param blocking
	 *            - boolean
	 */
	/*
	 * protected void realignNes(final X36SetOfNeId setOf, final boolean
	 * blocking) { if (LOG.isDebugEnabled()) { LOG.debug(new DumpInfo(setOf,
	 * String.format("%s realignment on EM <%s> for %d NEs...", (blocking ?
	 * "Synchronous" : "Asynchronous"), getName(), setOf.size()))); } else if
	 * (LOG.isInfoEnabled()) {
	 * LOG.info(String.format("%s realignment on EM <%s> for %d NEs.", (blocking
	 * ? "Synchronous" : "Asynchronous"), getName(), setOf.size())); }
	 *
	 * // Incase of standAlone mode sbikey is stored in SBIClient if
	 * (isStandAlone() &&
	 * !SBIContainer.getInstance().getSbiObj(sbiKey).isConnected()) { if
	 * (LOG.isInfoEnabled()) { LOG.info(String.format(
	 * "Channel is not connected: realignment on EM <%s> is not performed",
	 * getName())); } return; }
	 *//**
	 * prima di riallinerae il nodo verifico se l'ne e' 1) preso in carico
	 * (isManaged) 2) e' associated seconda la I36
	 */
	/*
	 * final X36SetOfNeId associated = new X36SetOfNeId();
	 *
	 * for (final X36NeId item : setOf) {
	 *
	 * if (!isManaged(item)) { continue; } if (isAssociated(item)) {
	 * associated.add(item); } }
	 *
	 * if (LOG.isInfoEnabled()) {
	 * LOG.info(String.format("On EM <%s> launching realignment for %d/%d NEs",
	 * getName(), associated.size(), setOf.size())); }
	 *
	 * if (associated.size() == 0) { return; }
	 *
	 * if (blocking) { final int permits = associated.size() - 1; final
	 * Semaphore semaphore = new Semaphore(-permits); final RealigmentHandler
	 * handler = new RealigmentHandler(associated, semaphore);
	 * realignmentManager.addRealignmentEventListener(handler);
	 * realignmentManager.realignNe(associated);
	 *
	 * try { if (LOG.isInfoEnabled()) {
	 * LOG.info(String.format("On EM <%s> waiting for realignment of %d NEs.",
	 * getName(), associated.size())); } semaphore.acquire(); if
	 * (LOG.isInfoEnabled()) {
	 * LOG.info(String.format("On EM <%s> realignment of %d NEs done.",
	 * getName(), associated.size())); } } catch (final Exception e) {
	 * LOG.error("On EM <" + getName() +
	 * "> cannot wait for realignment termination", e); }
	 * realignmentManager.removeRealignmentEventListener(handler); } else { if
	 * (LOG.isInfoEnabled()) {
	 * LOG.info(String.format("On EM <%s> scheduling realignment of %d NEs.",
	 * getName(), associated.size())); }
	 * realignmentManager.realignNe(associated); } }
	 */

	protected void realignNes(final MEDnList setOf, final boolean blocking) {
		if (LOG.isDebugEnabled()) {
			LOG.debug(new DumpInfo(setOf, String.format("%s realignment on EM <%s> for %d NEs...", (blocking ? "Synchronous"
					: "Asynchronous"), getName(), setOf.size())));
		} else if (LOG.isInfoEnabled()) {
			LOG.info(String.format("%s realignment on EM <%s> for %d NEs.", (blocking ? "Synchronous" : "Asynchronous"),
					getName(), setOf.size()));
		}

		// Incase of standAlone mode sbikey is stored in SBIClient
		if (isStandAlone() && !SBIContainer.getInstance().getSbiObj(sbiKey).isConnected()) {
			if (LOG.isInfoEnabled()) {
				LOG.info(String.format("Channel is not connected: realignment on EM <%s> is not performed", getName()));
			}
			return;
		}

		// Fix for TR HP33039
		// Calling GetNodeList to refresh the ne state before discarding realignment of idle NEs

		for (final MEDn item : setOf) {
			if (!isManaged(item)) {
				continue;
			}
			if (!isAssociated(item)) {
				updateEMNEsCommState();
				break;
			}
		}
		/**
		 * prima di riallinerae il nodo verifico se l'ne e' 1) preso in carico
		 * (isManaged) 2) e' associated seconda la I36
		 */
		final MEDnList associated = new MEDnList();

		for (final MEDn item : setOf) {
			if (!isManaged(item)) {
				continue;
			}
			if (isAssociated(item)) {
				associated.add(item);
			}
		}

		if (LOG.isInfoEnabled()) {
			LOG.info(String.format("On EM <%s> launching realignment for %d/%d NEs", getName(), associated.size(), setOf.size()));
		}

		if (associated.size() == 0) {
			return;
		}

		if (blocking) {
			final int permits = associated.size() - 1;
			final Semaphore semaphore = new Semaphore(-permits);
			final RealigmentHandler handler = new RealigmentHandler(associated, semaphore);
			realignmentManager.addRealignmentEventListener(handler);
			realignmentManager.realignNe(associated);

			try {
				if (LOG.isInfoEnabled()) {
					LOG.info(String.format("On EM <%s> waiting for realignment of %d NEs.", getName(), associated.size()));
				}
				semaphore.acquire();
				if (LOG.isInfoEnabled()) {
					LOG.info(String.format("On EM <%s> realignment of %d NEs done.", getName(), associated.size()));
				}
			} catch (final Exception e) {
				LOG.error("On EM <" + getName() + "> cannot wait for realignment termination", e);
			}
			realignmentManager.removeRealignmentEventListener(handler);
		} else {
			if (LOG.isInfoEnabled()) {
				LOG.info(String.format("On EM <%s> scheduling realignment of %d NEs.", getName(), associated.size()));
			}
			realignmentManager.realignNe(associated);
		}
	}

	/**
	 * This method is used to process all NEs retrieved from EM.
	 *
	 * @param nodeList
	 * @return
	 */
	public void processNes(final X36SetOfNetworkElement newNEList) {
		// This method will be called only when TMF is running in standAlone
		// mode. Hence getting hostName as below.
		final NeHelper helper = new NeHelper(this, getHostName());
		final MEConverter converter = new MEConverter();

		final int meGranularity = getProfile().getIntProperty(I36PlugIn.PluginProperty.meQueryGranularity, 100);

		Session session = null;

		try {
			session = getDbManager().beginSession(true);

			final List<X36NetworkElement> neList = new ArrayList<X36NetworkElement>(Arrays.asList(newNEList.getAll()));
			final ListCursor<X36NetworkElement> cursor = new ListCursor<X36NetworkElement>(neList);

			while (cursor.hasMore()) {

				final List<X36NetworkElement> cursorList = cursor.getNext(meGranularity);

				for (final Iterator<X36NetworkElement> itr = cursorList.iterator(); itr.hasNext();) {

					final X36NetworkElement ne = itr.next();
					helper.setNe(ne);
					final MEDn meDn = new MEDn();
					final MEId meId = naming.get(ne.getNeId(), host);
					meDn.setMe(meId);

					final MEIdAndHost mEIdAndHost = new MEIdAndHost(ne.getNeId(), getHostName());
					if (isStandAlone() && isManaged(mEIdAndHost)) {
						converter.process(helper, false);
					} else if (isManaged(meDn)) {
						converter.process(helper, false);
					} else if (BaseApplication.getApplication()
							.getCommandLine().hasOption("readBer")) {
						converter.process(helper, false);
					}
				}

				session.checkpoint();
			}

			session.commit();
			/*
			 * final X36NeId neId = new X36NeId(51); LOG.info("neid is" +
			 * getDbManager().getManagedElement(neId));
			 */

		} catch (final Exception ex) {
			LOG.error(new DumpInfo(ex, "Exception while processing the NEs :"));
		} finally {
			if (session != null) {
				session.terminate();
			}
		}
	}

	/**
	 * Gets all ME that are managed by this SBI. <br>
	 * It read MEs from DB and discards that not managed by this SBI, ie not
	 * present on underlying EM.
	 *
	 * @return a managed elements list
	 * @throws PlugInException
	 *             if something goes wrong in DB access
	 */

	@Override
	public ManagedElementList getMEList() throws PlugInException {
		final List<ManagedElement> meList = getManagedElements();

		final MEDnList supported = getMEDnList();
		final ManagedElementList out = new ManagedElementList();

		for (final ManagedElement item : meList) {
			if (supported.contains(item.getName())) {
				out.add(item);
				supported.remove(item.getName());
			}
		}

		return out;
	}

	/**
	 * It read all MEs from DB.<Br>
	 *
	 * @return ManagedElementList
	 */
	@Override
	public ManagedElementList getAllDBManagedElements() {
		final List<ManagedElement> meList = getManagedElements();
		final ManagedElementList out = new ManagedElementList();
		for (final ManagedElement item : meList) {
			out.add(item);
		}
		return out;
	}

	/**
	 * It read all MEs from DB.<Br>
	 *
	 * @return a list of ManagedElement
	 */
	protected List<ManagedElement> getManagedElements() {
		final I36DatabaseManager manager = getDbManager();
		Session session = null;
		try {
			session = manager.beginSession(false);

			final List<DBManagedElement> meList = getDBManagedElements();
			final List<ManagedElement> out = new ArrayList<ManagedElement>();

			for (final DBManagedElement item : meList) {
				out.add(item.getInformation());
			}
			return out;
		} catch (final Exception e) {
			LOG.error(new DumpInfo(e));
			throw PlugInExceptionHandler.internalError(e.getMessage());
		} finally {
			if (session != null) {
				session.terminate();
			}
		}
	}

	/**
	 * It read all MEs from DB.<Br>
	 * A session MUST be in progress.
	 *
	 * @return a list od DBManagedElement
	 */
	protected List<DBManagedElement> getDBManagedElements() {
		final I36DatabaseManager manager = getDbManager();
		DBIterator<DBManagedElement> meItr = null;

		final DBEms ems = manager.getEMS(new EMSDn());

		final DBList<DBSubnetwork> snList = (DBList<DBSubnetwork>) ems.getSubnetworks();
		DBIterator<DBSubnetwork> snItr = snList.iterator();
		final List<DBManagedElement> list = new ArrayList<DBManagedElement>();

		while (snItr.hasNext()) {
			final DBObject dbObject = snItr.next();
			if (dbObject instanceof DBSubnetwork) {
				final DBSubnetwork item = (DBSubnetwork) dbObject;
				meItr = item.getMEs().iterator();

				while (meItr.hasNext()) {
					final DBObject me = meItr.next();
					if (me instanceof DBManagedElement) {
						list.add((DBManagedElement) me);
					}
				}
				meItr.close();
				meItr = null;
			}
		}
		snItr.close();
		snItr = null;

		return list;
	}

	/**
	 * Forces NEID list and Sets 'forcedNEIDList' to 'true'
	 *
	 * @param list
	 *            - X36SetOfNeId
	 */

	@Override
	public void forceNEIdList(final MEDnList meDnlist) {
		meInfos.setNeIdList(meDnlist, null, null);
		forcedNEIDList = true;
	}

	@Override
	public void forceMeIdAndHostList(final List<MEIdAndHost> meIDAndHostList) {
		meInfos.setMeIDAndHostList(meIDAndHostList);
		forcedNEIDList = true;
	}

	/**
	 * Loads all Managed Elements
	 */
	protected void loadAllManagedElements() {
		/**
		 * se sono standAlone allora leggo dal DB tutti gli ME e mi setto la
		 * lista dei nodi questo metodo dovrebbe essere chiamato allo start
		 * della SBI
		 */
		if (!plugIn.isStandAlone() || forcedNEIDList) {
			return;
		}
		try {
			final ManagedElementList lst = getMEList();
			final MEDnList dnList = TmfUtilities2.getAllDn(lst);
			loadNEId(dnList);
			setMEDnList(dnList);
		} catch (final Exception e) {
			LOG.error("Unable to load MEs form DB", e);
		}
	}

	/**
	 * Loads Node list and returns the list
	 */

	protected X36SetOfNetworkElement loadNodeList(final String emHostName) {
		if (LOG.isInfoEnabled()) {
			LOG.info(String.format("On EM <%s> ready to load ME into DB", getName()));
		}

		/**
		 * questo metodo carica la lista dei nodi da MV36 inoltre setta la
		 * struttura dei ME gestiti se gira standAlone
		 */

		X36SetOfNetworkElement meList = null;
		try {
			final long timeout = sbiClient.getProfile().getTimeProperty(EmSBIPluginProperty.sbiTimeout, 180000);
			sbiClient.getMessageHandler().setTimeout(timeout);
			meList = messageHandler.getNetworkElements(emHostName);
			if (LOG.isDebugEnabled()) {
				LOG.debug(new DumpInfo(meList, String.format("Received node list on EM <%s>....", getName())));
			}
		} catch (final Exception e) {
			LOG.error(new DumpInfo("Unable to load node list", e));
			return null;
		}

		/*
		 * se sono standAlone allora per ogni NetworkElement tento di costruire
		 * il nome in modo da riempire la tabella del naming
		 */
		if (plugIn.isStandAlone()) {
			final Iterator<X36NetworkElement> iterator = meList.iterator();

			X36NetworkElement ne = null;

			while (iterator.hasNext()) {
				ne = iterator.next();
				getNaming().makeMEDn(ne, emHostName);
			}
		}

		if (emNeIdsMap.containsKey(emHostName)) {
			emNeIdsMap.get(emHostName).addAll(PluginUtility.getAllMEDns(meList, emHostName, getPlugIn()));
		} else {
			emNeIdsMap.put(emHostName, PluginUtility.getAllMEDns(meList, emHostName, getPlugIn()));
		}
		// neIdOnEmList.addAll(PluginUtility.getAllMEDns(meList, emHostName,
		// getPlugIn()));

		/**
		 * se sono stand-alone allora setto la lista dei nodi gestiti con questa
		 * lista, altrimenti sara' stata settata del plugin superiore
		 */
		if (!forcedNEIDList && plugIn.isStandAlone()) {
			meInfos.setNeIdList(emNeIdsMap.get(emHostName), null, null);
		}

		return meList;
	}

	/**
	 * Get SBI Version
	 */
	protected void getSBIVersion(final X36SBIHostName sbiHostName) {
		if (LOG.isInfoEnabled()) {
			LOG.info(String.format("On EM <%s> ready to get I36 version.", getName()));
		}

		/**
		 * questo metodo carica la lista dei nodi da MV36 inoltre setta la
		 * struttura dei ME gestiti se gira standAlone
		 */
		X36ReportGetVersion version = null;
		try {
			final long timeout = sbiClient.getProfile().getTimeProperty(EmSBIPluginProperty.sbiTimeout, 180000);
			sbiClient.getMessageHandler().setTimeout(timeout);
			version = messageHandler.getVersion(sbiHostName);
			if (LOG.isDebugEnabled()) {
				LOG.debug(new DumpInfo(version, String.format("Received version on EM <%s>....", getName())));
			}
		} catch (final Exception e) {
			LOG.warn("Exception thrown retrieving the version of the SBI. Details: " + e.getMessage());
			LOG.error(new DumpInfo("Unable to version the EM", e));
			return;
		}

		final int major = version.getMajorNum().getValue();
		final int minor = version.getMinorNum().getValue();

		LOG.info(String.format("Underlying EM is using I36 version: %d.%d (%s)", major, minor, version.getInfo().getValue()));
	}

	/**
	 * Set Communication state
	 *
	 * @param meList
	 *            - X36SetOfNetworkElement
	 * @return - Returns the set of Ne Ids which are not existing in the
	 *         database
	 */
	protected MEDnList setCommunicationState(final X36SetOfNetworkElement meList, final List meDetailList) {

		// final X36SetOfNetworkElement onLine = new X36SetOfNetworkElement();
		// final X36SetOfNetworkElement offLine = new X36SetOfNetworkElement();
		final List<MEDetails> onLine = new ArrayList<MEDetails>();
		final List<MEDetails> offLine = new ArrayList<MEDetails>();
		// final X36SetOfNeId newNEs = new X36SetOfNeId();
		final MEDnList newNEs = new MEDnList();
		for (final Iterator<MEDetails> itr = meDetailList.iterator(); itr.hasNext();) {
			final MEDetails item = itr.next();
			final boolean neUp = item.isNeUp();
			if (neUp) {
				onLine.add(item);
			} else {
				offLine.add(item);
			}

			meInfos.setState(MEInfos.MEState.linkup, item.getMeDn(), neUp);
		}

		final I36DatabaseManager mgr = getDbManager();

		newNEs.addAll(mgr.setNEStateAndUpdateEMParams(onLine, true, null));
		newNEs.addAll(mgr.setNEStateAndUpdateEMParams(offLine, false, null));

		if (LOG.isDebugEnabled()) {
			LOG.debug(new DumpInfo(emNeIdsMap, String.format("On EM <%s> there are %d ME (%d associated)...", getName(),
					meList.size(), onLine.size())));
		} else if (LOG.isInfoEnabled()) {
			LOG.info(String.format("On EM <%s> there are %d ME (%d associated)...", getName(), meList.size(), onLine.size()));
		}

		return newNEs;
	}

	/**
	 * Start Provisioning
	 */

	@Override
	public void startProvisioning(final String hostName) {
		final StopWatch watch = new StopWatch();
		watch.start();

		// Before provisioning phase, need to synchronize alarm reporting
		// between TMF and SO-EM

		synchronizeAlarmReportingOnResources(hostName);
		/*
		 * devo dare inizio al provisioning degli allarmi se la lista dei nodi
		 * gestiti e' = null allora gestisco tutto, per sapere quali
		 * provisionare carico i nodi presnti su X36
		 */
		final MEDnList setOf = meInfos.getManagedIdList();
		// Filter the Managed NEs for the particular EM in TMFoNM mode
		if (!isStandAlone()) {
			final MEDnList meDnLst = plugIn.getEmNEDetails().get(hostName);
			final MEDnList managedDnLst = new MEDnList(setOf);
			final Iterator<MEDn> itrMeDn = managedDnLst.iterator();
			while (itrMeDn.hasNext()) {
				final MEDn meDn = itrMeDn.next();
				if (!meDnLst.contains(meDn)) {
					setOf.remove(meDn);
				}
			}
		}
		if (setOf.size() > 0) {
			doProvisioning(setOf, false);
		} else {
			/**
			 * Fix for TR HO80385 : When TMF is started with SOEM that has no
			 * NEs, provisioning request without Nes list is sent to SOEM.
			 * Otherwise SOEM will not send any event like neAdded.
			 */
			sendProvisioningWithoutNes();
		}

		LOG.info("I36 sbi " + getName() + " provisioning started.");
		LOG.info("*** I36Plugin " + getName() + " provisioning started in " + watch.toString());
	}

	/**
	 * Provisioning
	 *
	 * @param neId
	 *            - X36NeId
	 */

	@Override
	public void doProvisioning(final MEDn meDn) {
		final MEDnList setOf = new MEDnList();
		setOf.add(meDn);
		doProvisioning(setOf, false);
	}

	/**
	 * Provisioning
	 *
	 * @param setOf
	 *            - MEDnList
	 */

	public void doProvisioning(final MEDnList meDnList, final boolean hasSemahore) {
		if ((meDnList == null) || (meDnList.size() == 0)) {
			return;
		}

		if (isStandAlone() && !SBIContainer.getInstance().getSbiObj(sbiKey).isConnected()) {
			return;
		}

		final MEDnList neIds = new MEDnList();

		final MEDnList toBeProvisioned = new MEDnList();
		Session session = null;
		try {
			session = getPlugIn().getDatabaseManager().beginSession(false);

			for (final MEDn meDn : meDnList) {
				/*
				 * se non e' in meDnOnEmList allora non e' sul 36 puo' succedere
				 * se siamo stand-alone e e' stato rimosso l'NE dall'EM mentre
				 * si era fuori linea che fare? lo si tromba?
				 */
				final boolean check = isManaged(meDn);
				if (!check) {
					final String neLocator = getNeLocator(meDn);
					LOG.warn(String.format("ME <%s> in not present on EM <%s>", neLocator, getName()));
					continue;
				}
				neIds.add(meDn);
				/*
				 * Provisioning will be done for the ME only if the
				 * AsynchsReporting on the ME is "Yes"
				 */
				boolean isAsynchsEnabled = true;

				/*
				 * Get the AsynchsReporting from the ME and check if it is Yes
				 * of Not"
				 */
				final DBManagedElement dbMe = getDbManager().getManagedElement(meDn);
				final AdditionalInfo dbMe_ai = dbMe.getAdditionalInfo();
				final String asynchsReport = AdditionalInfoUtils.find(dbMe_ai, ProprietaryAdditionalInfo.AsynchsReporting.name());
				// in case of asynchsReport is null it should be treated as
				// ture.
				if (asynchsReport != null) {
					isAsynchsEnabled = asynchsReport.equalsIgnoreCase("Yes") ? true : false;
				}

				if (isAsynchsEnabled) {
					toBeProvisioned.add(meDn);
				} else {
					LOG.info(String.format("Asynchs Reportin is disbaled on ME:%d", meDn.getMe()));
				}
			}

			if (neIds.size() == 0) {
				LOG.info(String.format("No ME to be provisioned on EM <%s>", getName()));
				return;
			}

			if (LOG.isDebugEnabled()) {
				LOG.debug(new DumpInfo(toBeProvisioned, String.format("Sending provisioning message on EM <%s> for ...",
						getName())));
			} else if (LOG.isInfoEnabled()) {
				LOG.info(String.format("Sending provisioning message for %d NEs on EM <%s>", neIds.size(), getName()));
			}

		} catch (final DBException e) {
			LOG.error(new DumpInfo("It wasn't possible to retrieve the information from DB.", e));
		} finally {
			if (session != null) {
				session.terminate();
			}
		}
		AlarmProvisioningReporter reporter = null;
		if (hasSemahore) {
			reporter = new AlarmProvisioningReporter(getName() + "-ProvisioningReporter", eventCollector, toBeProvisioned,
					provisioningSemaphore);
		} else {
			reporter = new AlarmProvisioningReporter(getName() + "-ProvisioningReporter", eventCollector, toBeProvisioned);
		}
		reporter.performProvisioning();

		meInfos.setState(MEInfos.MEState.alarm, neIds, true);
	}

	/**
	 * Deprovisioning
	 *
	 * @param setOf
	 *            - MEDnList
	 */

	protected void doDeprovisioning(final MEDnList setOf) {
		if ((setOf == null) || (setOf.size() == 0)) {
			return;
		}

		final Map<String, X36SetOfNeId> emSetofNeMap = new HashMap<String, X36SetOfNeId>();
		final Map<String, MEDnList> emMeDnList = new HashMap<String, MEDnList>();
		for (int i = 0; i < setOf.size(); i++) {
			final String hostName = sbiClient.getEmHostNameFromMap(setOf.get(i));
			if (emSetofNeMap.containsKey(hostName)) {
				final X36NeId neId = getNaming().getNeId(setOf.get(i).getMe());
				emSetofNeMap.get(hostName).add(neId);
				emMeDnList.get(hostName).add(setOf.get(i));
			} else {
				final X36SetOfNeId setOfNes = new X36SetOfNeId();

				final X36NeId neId = getNaming().getNeId(setOf.get(i).getMe());
				setOfNes.add(neId);
				final MEDnList meDnLst = new MEDnList();
				meDnLst.add(setOf.get(i));
				emSetofNeMap.put(hostName, setOfNes);
				emMeDnList.put(hostName, meDnLst);
			}

		}

		if (LOG.isDebugEnabled()) {
			LOG.debug(new DumpInfo(setOf, String.format("On EM <%s> starting deprovisioning for ...", getName())));
		} else if (LOG.isInfoEnabled()) {
			LOG.info(String.format("On EM <%s> starting deprovisioning for %d NEs", getName(), setOf.size()));
		}
		final Set<String> hostNames = emSetofNeMap.keySet();
		final Iterator<String> itrHostNames = hostNames.iterator();
		while (itrHostNames.hasNext()) {
			final String hostName = itrHostNames.next();
			final X36SetOfNeId emsNeList = emSetofNeMap.get(hostName);
			final X36MsgGetDeprovisioning msg = new X36MsgGetDeprovisioning();
			final X36GetDeprovisioning body = msg.getBody();
			body.setReqId(NumberGenerator.getReqId());
			body.setAdditionalText("NMS Request");
			body.setNeIdList(emsNeList);
			try {
				final long timeout = sbiClient.getProfile().getTimeProperty(EmSBIPluginProperty.sbiTimeout, 180000);
				sbiClient.getMessageHandler().setTimeout(timeout);
				getMessageHandler().getDeprovisioning(msg, hostName);
				meInfos.setState(MEInfos.MEState.alarm, emMeDnList.get(hostName), false);
			} catch (final Exception ex) {
				LOG.error("Cannot deprovisioning nes", ex);
			}
		}
	}

	/***
	 * This method sends provision request with out NEs.
	 */
	private void sendProvisioningWithoutNes() {
		final MEDnList neList = new MEDnList();
		final AlarmProvisioningReporter reporter = new AlarmProvisioningReporter(getName() + "-ProvisioningReporter",
				eventCollector, neList);
		try {
			reporter.sendGetProvisioning(neList);
		} catch (final Exception e) {
			LOG.error(e);
		}
	}

	/**
	 * Called when protection change event occurs
	 *
	 * @param pce
	 */
	protected void onProtectionChangeEvent(final X36EventDetailReport pce) {
		if (LOG.isDebugEnabled()) {
			LOG.debug(new DumpInfo(pce, "Received event detail...."));
		}
		protectionSwitchRaiser.onEventReport(pce);
	}

	/**
	 * Open User Interface
	 */

	@Override
	public Object openUserInterface(final MEId meId, final String userName, final String password, final String gctContext,
			final String displayAddress) throws PlugInException {
		X36NeId neId = null;
		if (meId != null) {
			neId = naming.getNeId(meId);
		}
		final long timeout = sbiClient.getProfile().getTimeProperty(EmSBIPluginProperty.sbiTimeout, 180000);
		sbiClient.getMessageHandler().setTimeout(timeout);
		final MEDn dn = new MEDn();
		dn.setMe(meId);
		final String hostName = sbiClient.getHostName(dn, false);
		final Object ret = messageHandler.openUserInterface(neId, userName, password, gctContext, displayAddress, hostName);

		return ret;
	}

	/**
	 * Close User Interface
	 */

	@Override
	public void closeUserInterface(final Object obj) throws PlugInException {
		final X36MsgUserInterfaceManagement msg = (X36MsgUserInterfaceManagement) obj;
		final long timeout = sbiClient.getProfile().getTimeProperty(EmSBIPluginProperty.sbiTimeout, 180000);
		sbiClient.getMessageHandler().setTimeout(timeout);
		messageHandler.closeUserInterface(msg);
	}

	/**
	 * Called when Timer Expires
	 */

	@Override
	public synchronized void timerExpired(final Object timerId, final Object userData) {
		if (timerId == this.startTimerId) {
			LOG.warn(String.format("On EM <%s> timer waiting first connection expired: continue start procedure", getName()));
			startSemaphore.release();
			startTimerId = null;
		}
	}

	/**
	 * FirstConnectionHandler to handle SBI first connection
	 *
	 * @author Luca Vassalli
	 */
	private class FirstConnectionHandler implements PropertyChangeListener {

		@Override
		public void propertyChange(final PropertyChangeEvent evt) {
			String hostName = "";
			if (isStandAlone()) {
				hostName = getHostName().toString();
			} else {
				hostName = ((X36SBI) evt.getSource()).getConnectionInfo().getHost();
			}
			final String name = evt.getPropertyName();

			final SBIKey key = new SBIKey(getPlugIn().getClass().getSimpleName(), hostName);

			if (name.equals(X36SBI.SBI_CONNECTED)) {
				((X36MsgClient) SBIContainer.getInstance().getSbiObj(key)).removeListener(this);
				onFirstConnection(hostName);
				((X36MsgClient) SBIContainer.getInstance().getSbiObj(key)).addListener(new OtherConnectionHandler());
			}
		}
	}

	/**
	 * OtherConnectionHandler to handle other SBI connections/disconnections
	 *
	 * @author Luca Vassalli
	 */
	private class OtherConnectionHandler implements PropertyChangeListener {

		@Override
		public void propertyChange(final PropertyChangeEvent evt) {
			final String name = evt.getPropertyName();
			final Object source = evt.getSource();
			if (source instanceof X36SBI) {
				final String hostName = ((X36SBI) source).getHostName();
				if (!(hostName == null)) {
					final X36SBIHostName sbiHostName = new X36SBIHostName(hostName);

					if (name.equals(X36SBI.SBI_CONNECTED)) {
						onConnection(true, sbiHostName);
					} else {
						onConnection(false, sbiHostName);
					}
				}
			}
		}
	}

	/**
	 * Realignment Handler class used for realignment
	 *
	 * @author Luca Vassalli
	 *
	 */
	private class RealigmentHandler implements RealignmentEventListener {
		Semaphore semaphore = null;
		MEDnList setOf = null;

		/**
		 * Constructor
		 *
		 * @param setOf
		 *            - X36SetOfNeId
		 * @param semaphore
		 *            - Semaphore
		 */
		RealigmentHandler(final MEDnList setOf, final Semaphore semaphore) {
			this.setOf = setOf;
			this.semaphore = semaphore;
		}

		/**
		 * Called when a realignment event occurs
		 */

		@Override
		public void onRealignmentEvent(final RealignmentEvent event) {
			final Object source = event.getSource();
			if (source != realignmentManager) {
				return; // non dovrebbe succedere
			}

			if (event instanceof EndRealignmentEvent) {
				final EndRealignmentEvent end = (EndRealignmentEvent) event;
				final X36NeId neId = end.getNeId();
				final MEDn meDn = end.getMeDn();
				// se non mio non lo cago....
				if (setOf.remove(meDn)) {
					final String neLocator = getNeLocator(meDn);
					LOG.info(String.format("Received notification for ending realignment on ME <%s>: release semaphore.",
							neLocator));
					semaphore.release();
				}
			}
		}
	}

	/**
	 * BER Realignment Handler class used for realignment TMF is started in BER
	 * realignment mode
	 *
	 * @author tcschpr
	 *
	 */
	private class BERRealigmentHandler implements RealignmentEventListener {
		Semaphore semaphore = null;
		// X36SetOfNeId setOf = null;
		MEDnList meDnList = null;

		/**
		 * Constructor
		 *
		 * @param setOf
		 *            - X36SetOfNeId
		 * @param semaphore
		 *            - Semaphore
		 */
		// BERRealigmentHandler(final X36SetOfNeId setOf, final Semaphore
		// semaphore) {
		BERRealigmentHandler(final MEDnList meDnList, final Semaphore semaphore) {
			// this.setOf = setOf;
			this.meDnList = meDnList;
			this.semaphore = semaphore;
		}

		/**
		 * Called when a realignment event occurs
		 */

		@Override
		public void onRealignmentEvent(final RealignmentEvent event) {
			final Object source = event.getSource();
			if (source != realignmentManager) {
				return;
			}

			if (event instanceof EndRealignmentEvent) {
				final EndRealignmentEvent end = (EndRealignmentEvent) event;
				final MEDn meDn = end.getMeDn();
				// final X36NeId neId = end.getNeId();
				if (meDnList.remove(meDn)) {
					semaphore.release();
				}
			}
		}
	}

	/**
	 * Get Protection Switch Raiser
	 */

	@Override
	public ProtectionSwitchRaiser getProtectionSwitchRaiser() {
		return protectionSwitchRaiser;
	}

	/**
	 * This method is provided to allow the SBICLient's user to send messages
	 * and check if the underlying channels are connected or not.
	 *
	 * @return a reference to the X36SBI instance for the current I36Plugin
	 */

	/*
	 * public X36MsgClient getSBI() { return null; }
	 */
	@Override
	public EventCollector getEventCollector() {
		return this.eventCollector;
	}

	/**
	 * This method is used to increment count information on port when TMF is
	 * started without DB Reset
	 */
	public void updateCountOnPort(final String hostName) {

		final I36DatabaseManager manager = getDbManager();
		Session session = null;

		try {
			session = manager.beginSession(false);
			List<DBManagedElement> dbMeList = new ArrayList<DBManagedElement>();
			/*
			 * HN54402Adding support for processing crossConnection countin NM
			 * mode for alarm suppression.
			 */
			if (isStandAlone()) {
				dbMeList = this.getDBManagedElements();
			} else {
				final MEDnList melist = getPlugIn().getManagedElementList(hostName);
				for (final MEDn meDn : melist) {
					final DBManagedElement me = dbManager.getManagedElement(meDn);
					if (me != null) {
						dbMeList.add(me);
					}
				}
			}

			// For all the DBManagedElements
			final int meListSize = dbMeList.size();
			for (int i = 0; i < meListSize; i++) {
				final DBManagedElement dbMe = dbMeList.get(i);
				// Retrieve the MEIdentification
				final String meID = dbMe.getDn().getMe().getValue();
				if (LOG.isDebugEnabled()) {
					LOG.debug(String.format("Processing the xConns for ME: %s ,to update the connection count", meID));
				}
				// Retrieve all the xConns present on the ME
				final DBList<DBCrossConnection> dbCCList = dbMe.getCrossConnections();
				final DBIterator<DBCrossConnection> dbCCItr = dbCCList.iterator();
				while (dbCCItr.hasNext()) {
					final DBCrossConnection dbCC = dbCCItr.next();
					/*
					 * if (log.isDebugEnabled()) { log.debug(String.format(
					 * "DBCrossConnection : %s present on the ME. Incrementing the ConnectionCount for all the ports"
					 * , TmfNameUtilities.toString(dbCC.getDn()))); }
					 */

					// For all the ports involved in the xConn increase the
					// connection Count by 1
					ConnectionsCountHelper.checkForNotVirtualXConn(meID, dbCC, true);
				}
				dbCCItr.close();
				// Configuring protections
				final DBManyRelationship<DBProtectionGroup> protectionGroup = dbMe.getProtectionGroups();
				final DBIterator<DBProtectionGroup> pgItr = protectionGroup.iterator();
				while (pgItr.hasNext()) {
					final DBProtectionGroup dbProtGroup = pgItr.next();
					// Get the protection group tyep
					final ProtectionGroupType protGroupType = dbProtGroup.getInformation().getProtectionGroupType();
					if (protGroupType.isPgt_msp_1_for_n() || protGroupType.isPgt_msp_1_plus_1()) {

						if (LOG.isDebugEnabled()) {
							LOG.debug(String
									.format("DBProtectionGroup : %s present on the ME. Incrementing the ConnectionCount for all the ports",
											TmfNameUtilities.toString(dbProtGroup.getDn())));
						}

						// Retrieve all the TPs involved in the PGP
						final TPDnList pgpTpDnList = dbProtGroup.getInformation().getPgpTPList();
						final Iterator<TPDn> tpDnItr = pgpTpDnList.iterator();
						final Set<X36PortIdentification> setOfPortIdentifications = new HashSet<X36PortIdentification>();
						while (tpDnItr.hasNext()) {
							// Build the portId
							final X36PortIdentification portIdentification = I36Naming.makePortId(tpDnItr.next().getTp());
							setOfPortIdentifications.add(portIdentification);
						}
						// For all the ports involved in the PGP increase the
						// connection Count by 1
						ConnectionsCountHelper.callToConnectionsCount(meID, setOfPortIdentifications, true);
					}
				}
				pgItr.close();
			}

		} catch (final Exception e) {
			LOG.error(new DumpInfo(e, "Could not update Connection Count Information"));
			throw PlugInExceptionHandler.internalError(e.getMessage());
		} finally {
			if (session != null) {
				session.terminate();
			}
		}
	}

	@Override
	public MEDnList doProvisioningOnNoSynchStart() {
		final I36DatabaseManager manager = getDbManager();
		boolean hasSemaphore = false;
		final MEDnList nes2bProvisioned = new MEDnList();
		Session session = null;
		try {
			session = manager.beginSession(false);

			// final X36SetOfNeId neSet = getMeInfos().getManagedIdList();
			final MEDnList meDnList = getMeInfos().getManagedIdList();
			final Iterator<MEDn> neItr = meDnList.iterator();
			while (neItr.hasNext()) {
				final MEDn meDn = neItr.next();
				final DBManagedElement dbMe = manager.getManagedElement(meDn);

				/*
				 * Fix for TR HO43309 Changed code to avoid exceptions raised in
				 * realignment when TMF is restarted .
				 */
				if (dbMe != null && !dbMe.getHolders().isEmpty()) {
					nes2bProvisioned.add(meDn);
				}
				if (nes2bProvisioned.size() > 0) {
					provisioningSemaphore = new Semaphore(0);
					hasSemaphore = true;
				}
			}
		} catch (final Exception e) {
			LOG.error(new DumpInfo(e, "Could not perform doProvisioningOnNoSynchStart"));
			throw PlugInExceptionHandler.internalError(e.getMessage());
		} finally {
			if (session != null) {
				session.terminate();
			}
		}
		try {
			doProvisioning(nes2bProvisioned, hasSemaphore);
		} catch (final Exception e) {
			LOG.error(new DumpInfo(e, "Could not perform doProvisioningOnNoSynchStart"));
			throw PlugInExceptionHandler.internalError(e.getMessage());
		}
		return nes2bProvisioned;
	}

	@Override
	public String getX36Version() {
		return x36Version;
	}

	@Override
	public String initX36Version() {
		String asnVesrsion = "";
		try {
			asnVesrsion = getPlugIn().getProfile().getProperty("Plugin.ASN.X36Version");
		} catch (final Exception e) {// Catch exception if any
			LOG.error("Error: " + e.getMessage());
		}
		return asnVesrsion;
	}

	/**
	 * disables alarm resources in EM according to disables alarm resources in
	 * TMF and updates the TMF DB according to EM disabled alarm resources.
	 *
	 */
	public void synchronizeAlarmReportingOnResources(final String hostName) {
		LOG.info(String.format("Trying to synchronize alarm reporting on resources between TMF and SO-EM <%s>", hostName));

		if (LOG.isDebugEnabled()) {
			LOG.debug(String.format(
					"Retrieving all the alarm resources from the SO-EM <%s>, on which the alarm reporting is disabled", hostName));
		}

		// Disabled alarm resources from SO-EM
		X36GetReportAlarmResourcesDisabled body = null;
		X36MsgGetReportAlarmResourcesDisabled report = null;

		try {
			final X36MsgGetAlarmResourcesDisabled request = new X36MsgGetAlarmResourcesDisabled();
			final long timeout = this.getProfile().getTimeProperty(EmSBIPluginProperty.sbiTimeout, 30000);

			getMessageHandler().setTimeout(timeout);
			report = getMessageHandler().getAlarmResourcesDisabled(request, hostName);
			body = report.getBody();
			final X36Compliance msgCompliance = body.getCompliance();

			if (!msgCompliance.isResOk()) {
				LOG.error(new DumpInfo(report, "Compliance notOk in the response message : "));
				return;
			}
		} catch (final Exception e) {
			LOG.error(new DumpInfo(
					e,
					String.format(
							"Unable to receive response from SO-EM <%s> for message MsgGetAlarmResourcesDisabled. May be alarm reporting feature is disabled in SO-EM. ",
							hostName)));
			return;
		}
		if (LOG.isDebugEnabled()) {
			LOG.debug(new DumpInfo(report, String.format("Alarm resources on which alarm reporting is disabled in SO-EM <%s>: ",
					hostName)));
		}
		final X36SetOfAlarmResourceDetails setOfEMAlarmResources = body.getDisabledResources();

		if (!plugIn.isStandAlone() || forcedNEIDList) {

			/*
			 * When TMF is over IPTNMS Circuit, all the MEs present in SO-EM
			 * need not be managed by TMF. So removing the unnecessary resources
			 * from the report message.
			 */

			final MEDnList managedNEs = getMeInfos().getManagedIdList();
			// Filter the Managed NEs for the particular EM in TMFoNM mode
			if (!isStandAlone()) {
				final MEDnList meDnLst = plugIn.getEmNEDetails().get(hostName);
				final MEDnList managedDnLst = new MEDnList(managedNEs);
				final Iterator<MEDn> itrMeDn = managedDnLst.iterator();
				while (itrMeDn.hasNext()) {
					final MEDn meDn = itrMeDn.next();
					if (!meDnLst.contains(meDn)) {
						managedNEs.remove(meDn);
					}
				}
			}
			final Iterator<X36AlarmResourceDetails> setOfEMAlarmResourcesItr = setOfEMAlarmResources.iterator();
			while (setOfEMAlarmResourcesItr.hasNext()) {
				final X36AlarmResourceDetails alarmResourceDetails = setOfEMAlarmResourcesItr.next();
				final X36NeId neId = alarmResourceDetails.getAlarmResource().getNeId();
				final Map<String, EmDetails> map = getPlugIn().gethostIds();
				for (final String host : map.keySet()) {
					final MEDn meDn = naming.makeMEDn(neId, host);
					if (!managedNEs.contains(meDn)) {
						setOfEMAlarmResourcesItr.remove();
					}
				}
			}
		}

		LOG.debug("Retrieving all the alarm resources from the TMF database, on which the alarm reporting is disabled");

		// Disabled alarm resources from TMF database
		X36SetOfAlarmResourceDetails setOfAlarmResourceDetailsOfTMF = null;

		try {
			setOfAlarmResourceDetailsOfTMF = collectDisabledTmfAlarmResources();
		} catch (final Exception e) {
			LOG.error(new DumpInfo(e, "Exception while retrieving all the disabled alarm resources from TMF database :"));
			return;
		}

		// Backup of EM and TMF alarm resources
		X36SetOfAlarmResourceDetails backUpSetOfEMAlarmResources = new X36SetOfAlarmResourceDetails(setOfEMAlarmResources);
		X36SetOfAlarmResourceDetails backUpSetOfTMFAlarmResources = new X36SetOfAlarmResourceDetails(
				setOfAlarmResourceDetailsOfTMF);

		// Removing the duplicates from both TMF and EM alarm resources
		setOfAlarmResourceDetailsOfTMF.removeAll(backUpSetOfEMAlarmResources);
		setOfEMAlarmResources.removeAll(backUpSetOfTMFAlarmResources);

		// Nullifying the objects
		backUpSetOfEMAlarmResources = null;
		backUpSetOfTMFAlarmResources = null;

		if (!setOfAlarmResourceDetailsOfTMF.isEmpty()) {

			LOG.info(String.format("Trying to disable alarm reporting on SO-EM <%s> to align with TMF database", hostName));

			if (LOG.isDebugEnabled()) {
				LOG.info(new DumpInfo(setOfAlarmResourceDetailsOfTMF, String.format(
						"Trying to disable alarm reporting on resources on SO-EM <%s>:", hostName)));
			}

			final Map<X36NeId, X36SetOfAlarmResourceDetails> neMap = groupByNE(setOfAlarmResourceDetailsOfTMF);
			final Set<X36NeId> neIdSet = neMap.keySet();
			for (final X36NeId neId : neIdSet) {
				try {
					final X36SetOfAlarmResourceDetails setOfAlarmResources = neMap.get(neId);

					// Creating message
					final X36MsgSetAlarmReporting message = new X36MsgSetAlarmReporting();
					final X36SetAlarmReporting alarmReporting = message.getBody();

					alarmReporting.setSetOfAlarmResources(setOfAlarmResources);
					// since EM is not considering this NEId, we are providing
					// first NeId value
					alarmReporting.setNeId(neId);
					alarmReporting.setReqId(NumberGenerator.getReqId());
					alarmReporting.setAdditionalText("setAlarmReportingOff");
					final long timeout = sbiClient.getProfile().getTimeProperty(EmSBIPluginProperty.sbiTimeout, 180000);
					sbiClient.getMessageHandler().setTimeout(timeout);
					final X36MsgSetReportAlarmReporting reportMessage = getMessageHandler().setAlarmReporting(message, hostName);
					final X36SetReportAlarmReporting reportBody = reportMessage.getBody();
					final X36Compliance msgCompliance = reportBody.getCompliance();

					if (!msgCompliance.isResOk()) {
						LOG.error(new DumpInfo(report, String.format(
								"Compliance notOk in the response message from SO-EM <%s> : ", hostName)));
						continue;
					}
				} catch (final Exception e) {
					LOG.error(new DumpInfo(e, String.format("Exception while disabling alarm reporting on SO-EM <%s> : ",
							hostName)));
					continue;
				}
			}
			LOG.info(String.format("Updated alarm reporting on all the resources on SO-EM <%s> to align with TMF database",
					hostName));
		}

		if (!setOfEMAlarmResources.isEmpty()) {
			processEMAlarmResources(setOfEMAlarmResources, hostName);
		}

		LOG.info(String.format("Synchronized the alarm reporting on resources between TMF and SO-EM <%s>", hostName));
	}

	public void processEMAlarmResources(final X36SetOfAlarmResourceDetails setOfEMAlarmResources, final String hostName) {

		final String emName = getName();

		LOG.info(String.format("Trying to disable alarm reporting on TMF database to align with SO-EM ", emName));

		if (LOG.isDebugEnabled()) {
			LOG.info(new DumpInfo(setOfEMAlarmResources, "Trying to disable alarm reporting on resources in the TMF database :"));
		}

		Session session = null;
		try {
			session = getDbManager().beginSession(true);
			final Iterator<X36AlarmResourceDetails> setOfEMAlarmResourcesItr = setOfEMAlarmResources.iterator();
			final I36Naming naming = getNaming();
			final I36DatabaseManager dbManager = getDbManager();

			while (setOfEMAlarmResourcesItr.hasNext()) {

				final X36AlarmResourceDetails alarmResourceDetails = setOfEMAlarmResourcesItr.next();
				final X36AlarmResource alarmResource = alarmResourceDetails.getAlarmResource();
				final X36NeId neId = alarmResource.getNeId();
				final String neLocator = getNeLocator(neId, hostName);
				final X36CardId card = alarmResource.getCardId();
				final X36ShelfId shelf = alarmResource.getShelfId();
				final MEId meId = naming.get(neId, hostName);
				final MEDn meDn = new MEDn();
				meDn.setMe(meId);
				if (card == null && shelf != null) {
					try {
						final EquipmentOrHolderDn equpHoldDn = new EquipmentOrHolderDn();
						final HolderDn holderDn = naming.makeShelfDn(meDn, shelf);

						equpHoldDn.setHolderDn(holderDn);

						final DBEquipmentOrHolder<?, ?> dbEoh = dbManager.getEquipmentOrHolder(equpHoldDn);

						if (dbEoh != null) {
							final EquipmentOrHolder equipOrHolder = dbEoh.getEquipmentOrHolder();
							if (equipOrHolder.isHolder()) {
								final EquipmentHolder holder = equipOrHolder.getHolder();
								if (holder != null && holder.getAlarmReportingIndicator().getValue()) {
									holder.setAlarmReportingIndicator(false);
									equipOrHolder.setHolder(holder);
									dbEoh.setEquipmentOrHolder(equipOrHolder);
								}
							}
						}

					} catch (final Exception e) {
						LOG.error(new DumpInfo(e, String.format(
								"Exception while updating the alarm reporting on shelf of the ME [%s]", neLocator)));
						continue;
					}

				} else if (card != null && shelf != null) {
					try {
						final X36SlotId slotId = new X36SlotId(card.getValue());
						final EquipmentDn cardDn = naming.makeSlotDn(meDn, shelf, slotId, card);
						final DBEquipment dbEqp = dbManager.getEquipment(cardDn);
						if (dbEqp != null) {
							final EquipmentOrHolder equipOrHolder = dbEqp.getEquipmentOrHolder();
							if (equipOrHolder.isEquip()) {
								final Equipment equip = equipOrHolder.getEquip();
								if (equip != null && equip.getAlarmReportingIndicator().getValue()) {
									equip.setAlarmReportingIndicator(false);
									equipOrHolder.setEquip(equip);
									dbEqp.setEquipmentOrHolder(equipOrHolder);
								}
							}
						}
					} catch (final Exception e) {
						LOG.error(new DumpInfo(e, String.format(
								"Exception while updating the alarm reporting on card of the ME [%s]", neLocator)));
						continue;
					}
				}
			}

			session.commit();
			LOG.info(String.format("Updated alarm reporting on all the resources in TMF database to align with SO-EM <%s> ",
					emName));

		} catch (final Exception e) {
			LOG.error(new DumpInfo(e, "Exception while updating the alarm reporting on the TMF database :"));
			return;
		} finally {
			if (session != null) {
				session.terminate();
				session = null;
			}
		}

	}

	/*
	 * Method which groups the alarm resources by NE
	 */

	private Map<X36NeId, X36SetOfAlarmResourceDetails> groupByNE(final X36SetOfAlarmResourceDetails setOfAlarmResourceDetails) {

		final Map<X36NeId, X36SetOfAlarmResourceDetails> map = new HashMap<X36NeId, X36SetOfAlarmResourceDetails>();

		final Iterator<X36AlarmResourceDetails> itr = setOfAlarmResourceDetails.iterator();
		while (itr.hasNext()) {
			final X36AlarmResourceDetails alarmResourceDetails = itr.next();
			final X36NeId neId = alarmResourceDetails.getAlarmResource().getNeId();
			X36SetOfAlarmResourceDetails setOfAlarmResourceDetailsForNE = map.get(neId);
			if (setOfAlarmResourceDetailsForNE == null) {
				setOfAlarmResourceDetailsForNE = new X36SetOfAlarmResourceDetails();
				map.put(neId, setOfAlarmResourceDetailsForNE);
			}
			setOfAlarmResourceDetailsForNE.add(alarmResourceDetails);
		}

		return map;
	}

	/**
	 * This method is provided to get the disabled alarm resources from TMF.
	 *
	 * @return set of X36 AlarmResourceDetails
	 */
	public X36SetOfAlarmResourceDetails collectDisabledTmfAlarmResources() {

		LOG.debug("Trying to retrieve from TMF database, all the resources on which alarm reporting is disabled");

		final X36SetOfAlarmResourceDetails setOfAlarmResourceDetailsOfTMF = new X36SetOfAlarmResourceDetails();

		MEDnList meDnList = getMEDnList();

		if (meDnList.size() == 0) {
			return setOfAlarmResourceDetailsOfTMF;
		}

		final I36DatabaseManager dbManager = getDbManager();
		Session session = null;
		try {

			session = dbManager.beginSession(false);

			final Iterator<MEDn> meDnItr = meDnList.iterator();

			while (meDnItr.hasNext()) {

				final MEDn meDn = meDnItr.next();

				DBManagedElement dbME = dbManager.getManagedElement(meDn);

				if (dbME != null) {
					final DBIterator<DBEquipmentHolder> holderItr = dbME.getHolders().iterator();

					while (holderItr.hasNext()) {

						DBEquipmentHolder dbEquipmentHolder = holderItr.next();

						if (dbEquipmentHolder.getEquipmentOrHolder().isHolder()) {

							final EquipmentHolder dbEqupHolder = dbEquipmentHolder.getEquipmentOrHolder().getHolder();
							final HolderDn holderDn = dbEqupHolder.getName();
							final HolderId holderId = holderDn.getHolder();

							if (!holderId.isPresentSlot()) {

								if (!dbEqupHolder.getAlarmReportingIndicator().getValue()) {

									final X36AlarmResourceDetails alarmResourceDetails = new X36AlarmResourceDetails();
									final X36AlarmResource alarmResource = new X36AlarmResource();
									final MEId meId = holderDn.getMe();
									alarmResource.setNeId(naming.getNeId(meId));
									alarmResource.setShelfId(Integer.parseInt(holderId.getShelf().getValue()));
									alarmResourceDetails.setAlarmResource(alarmResource);
									alarmResourceDetails.setEnableState(OperationalState.disabled);
									setOfAlarmResourceDetailsOfTMF.add(alarmResourceDetails);
								}

							} else {

								if (dbEquipmentHolder.getEquipment().get() != null) {
									final DBEquipment dbCard = dbEquipmentHolder.getEquipment().get();
									if (dbCard.getEquipmentOrHolder().isEquip()) {
										final Equipment card = dbCard.getEquipmentOrHolder().getEquip();
										if (!card.getAlarmReportingIndicator().getValue()) {

											final EquipmentDn cardDn = card.getName();
											final HolderId holder = cardDn.getHolder();

											final X36AlarmResourceDetails alarmResourceDetails = new X36AlarmResourceDetails();
											final X36AlarmResource alarmResource = new X36AlarmResource();
											final MEId meId = cardDn.getMe();
											alarmResource.setNeId(naming.getNeId(meId));
											alarmResource.setShelfId(Integer.parseInt(holder.getShelf().getValue()));
											alarmResource.setCardId(Integer.parseInt(holder.getSlot().getValue()));
											alarmResourceDetails.setAlarmResource(alarmResource);
											alarmResourceDetails.setEnableState(OperationalState.disabled);
											setOfAlarmResourceDetailsOfTMF.add(alarmResourceDetails);

										}
									}
								}
							}
						}

						dbEquipmentHolder = null;
					}

					holderItr.close();

				} else {
					LOG.warn(String.format("ME [%s] not found in the database. Skipping it.", TmfNameUtilities.toString(meDn)));
					continue;
				}

				dbME = null;
			}

		} catch (final Exception e) {
			LOG.error(new DumpInfo(e, "Exception while retrieving disabled alarm resources from TMF database :"));
		} finally {
			if (session != null) {
				session.terminate();
				session = null;
			}
		}

		meDnList = null;

		return setOfAlarmResourceDetailsOfTMF;
	}

	/**
	 * NodePossibleConfiguration message processes and updated in database
	 *
	 * @param neId
	 * @param nodePossibleConf
	 */

	@Override
	public void processNodePossibleConfiguration(final MEDn meDn, final X36NodePossibleConfiguration nodePossibleConf) {
		Session session = null;
		try {
			session = getDbManager().beginSession(true);
			final PhysicalConverter converter = new PhysicalConverter(this, getDbManager());
			converter.processNodePossibleConfiguration(meDn, nodePossibleConf);
			session.commit();
		} catch (final Exception e) {
			LOG.error(new DumpInfo(e, "Exception while updating nodePossibleConfiguration  :"));
		}

		finally {
			if (session != null) {
				session.terminate();
			}
		}
	}

	/**
	 * Method to update the communication state of NE's in EMS based on the
	 * result of getNodeList
	 */

	@Override
	public void updateEMNEsCommState() {
		// get the Node list from EM by issuing getNodeList command
		if (isStandAlone()) {
			final String hostName = sbiKey.getHost();
			final X36SetOfNetworkElement neList = loadNodeList(hostName);
			// based on the neUsageState (X36NeUsageState) attribute,
			// communication state is set on the ManagedElement
			final List<MEDetails> meDetailList = new ArrayList<MEDetails>();
			for (final X36NetworkElement neId : neList) {
				final MEDn meDn = new MEDn();
				final MEId meId = naming.get(neId.getNeId(), hostName);
				meDn.setMe(meId);
				final boolean neUp = neId.getNeUsageState().isAssociate();
				final MEDetails meDetails = new MEDetails(meDn, neUp, neId);
				meDetailList.add(meDetails);
			}
			setCommunicationState(neList, meDetailList);
		} else {
			final X36SetOfNetworkElement nodeList = new X36SetOfNetworkElement();
			final List<MEDetails> meDetailList = new ArrayList<MEDetails>();
			final Set<String> hostNames = getPlugIn().gethostIds().keySet();
			final Iterator<String> itrHost = hostNames.iterator();
			while (itrHost.hasNext()) {
				final String hostName = itrHost.next();
				final X36SetOfNetworkElement setOf = loadNodeList(hostName);
				// nodeList.addAll();
				for (final X36NetworkElement neId : setOf) {
					final MEDn meDn = new MEDn();
					MEId meId = naming.get(neId.getNeId(), hostName);
					if (meId == null) {
						final String nmName = getProfile().getProperty("PlugIn.NMName", "MV38");
						final int emId = plugIn.gethostIds().get(hostName).getEmId();
						meId = new MEId(String.format(ME_NAME_FORMAT, nmName, emId, neId.getNeId().getValue()));
						naming.insert(neId.getNeId(), meId, hostName);
					}
					meDn.setMe(meId);
					final boolean neUp = neId.getNeUsageState().isAssociate();
					final MEDetails meDetails = new MEDetails(meDn, neUp, neId);
					meDetailList.add(meDetails);
				}
			}
			setCommunicationState(nodeList, meDetailList);
		}
	}

	@Override
	public SBIKey setKey() {

		host = pluginProfile.getProperty(EmSBIPluginProperty.sbiHost, "localhost");

		// sbiKey = new SBIKey(host, cmdPort);
		sbiKey = new SBIKey(getPlugIn().getClass().getSimpleName(), host);
		return sbiKey;
	}

	/**
	 * This method forms the SbiKey by fetching required information from ME
	 * additional info and returns the corresonding SBI object.
	 *
	 * @param meDn
	 * @return X36MsgClient
	 */

	@Override
	public X36MsgClient getSbi(final MEDn meDn) {
		Session session = null;
		SBIKey sbiKey = null;
		try {
			if (isStandAlone()) {
				sbiKey = getSbiKey();
			} else {
				session = getDbManager().beginSession(false);
				final DBManagedElement dbME = getDbManager().getManagedElement(meDn);
				final EmSystemProfile emSystemProfile = getEmSystemProfile(dbME);

				sbiKey = new SBIKey(getPlugIn().getClass().getSimpleName(), emSystemProfile.getSyntax().getHostId().getValue());
			}
			return (X36MsgClient) SBIContainer.getInstance().getSbiObj(sbiKey);
		} finally {
			if (session != null) {
				session.terminate();
				session = null;
			}
		}
	}

	@Override
	public void startListenerAndPerformOnconnect(final String hostName) {

		final SBIKey key = new SBIKey(getPlugIn().getClass().getSimpleName(), hostName);
		eventCollector.start(key);
		messageHandler.startMessageHandler(key);
		protectionSynchManager.start(key);

		final SBI sbi = SBIContainer.getInstance().getSbiObj(key);
		if (sbi != null && sbi.isConnected()) {
			LOG.info(" EM SBI " + hostName + " is connected");
			onFirstConnection(hostName);
			final OtherConnectionHandler handler = new OtherConnectionHandler();
			((X36MsgClient) sbi).addListener(handler);
		} else {
			LOG.info(" EM SBI " + hostName + " is not connected");
			if (sbi != null) {
				final FirstConnectionHandler handler = new FirstConnectionHandler();
				((X36MsgClient) sbi).addListener(handler);
			}
		}

	}

	/**
	 * Initiates request for NodePossibleConfiguration message
	 *
	 * @param neList
	 */
	private void initiateNodePossibleconfiguration(final MEDnList neList) {
		NodePossibleConfigurationReporter reporter = null;
		final MEDnList associated = new MEDnList();

		for (final Iterator<MEDn> itr = neList.iterator(); itr.hasNext();) {
			final MEDn item = itr.next();
			if (!isManaged(item)) {
				continue;
			}
			if (isAssociated(item)) {
				associated.add(item);
			}
		}

		reporter = new NodePossibleConfigurationReporter(getName() + "-NodePossibleConfigurationReporter", eventCollector,
				associated);

		reporter.performGetNodePossibleConfiguration();
	}

	private String getEmHostNameFromMap(final MEDn meDn) {
		String emHostName = "";
		if (isStandAlone()) {
			emHostName = getHostName();
		} else {
			boolean found = false;
			final Map<String, MEDnList> emNeDetails = getPlugIn().getEmNEDetails();
			final Iterator<String> emItr = emNeDetails.keySet().iterator();
			while (emItr.hasNext()) {
				emHostName = emItr.next();
				final MEDnList setOfNeId = emNeDetails.get(emHostName);
				final Iterator<MEDn> neSetItr = setOfNeId.iterator();
				while (neSetItr.hasNext()) {
					if (neSetItr.next().equals(meDn)) {
						found = true;
						break;
					}
				}
				if (found) {
					break;
				}
			}
		}
		return emHostName;
	}

	/**
	 * Returns EmSystemProfile
	 * 
	 * @param dbME
	 * @return
	 */
	@Override
	public EmSystemProfile getEmSystemProfile(final DBManagedElement dbME) {
		EmSystemProfile emSystemProfile = null;
		try {

			final ManagedSystemProfile systemProfiles = (ManagedSystemProfile) dbME
					.getAdditionalInformation(ManagedSystemProfile.NAME);
			if (systemProfiles != null && systemProfiles.isPresentEmSystemProfile()) {
				emSystemProfile = systemProfiles.getEmSystemProfile();
			}
		} catch (final PlugInException e) {
			LOG.error(" Error while reading ManagedSystemProfile from DBManagedElement " + e);
		}
		return emSystemProfile;
	}

	private void startBERRealignment(final MEDnList meNames) {

		final int permits = meNames.size() - 1;
		final Semaphore semaphore = new Semaphore(-permits);
		final BERRealigmentHandler handler = new BERRealigmentHandler(meNames,
				semaphore);
		realignmentManager.addRealignmentEventListener(handler);
		realignmentManager.realignNe(meNames);
		try {
			LOG.info(String.format("Waiting for realignment of %d NEs.",
					meNames.size()));
			semaphore.acquire();
			LOG.info("Realignment of NEs done in BER realignment mode.");
		} catch (final Exception e) {
			LOG.error("Cannot wait for realignment termination", e);
		}
		realignmentManager.removeRealignmentEventListener(handler);
	}

	protected MEDnList loadMEList() {
		MEDnList meDnList = new MEDnList();
		try {

			final ManagedElementList lst = getAllDBManagedElements();
			if (lst != null) {
				meDnList = TmfUtilities2.getAllDn(lst);
			}
		} catch (final Exception e) {
			LOG.error("Unable to load MEs form DB", e);
		}
		return meDnList;
	}

	protected void onExitingApplication() {
		LOG.info("***\n***  Shutdown sequence for BER Realignemnt: begin...\n***");
		// BaseApplication.getApplication().exitApplication();
		BaseApplication.getApplication().getMultiplexer().shutdown();
		BaseApplication.getApplication().exitApplication();
		LOG.info("***\n***  Shutdown sequencefor BER Realignment: completed.\n***");
	}
}

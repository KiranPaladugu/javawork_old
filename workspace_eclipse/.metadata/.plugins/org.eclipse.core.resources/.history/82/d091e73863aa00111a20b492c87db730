/**
 * 
 */
package com.marconi.fusion.tmf.i36PlugIn.inventory;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Properties;
import java.util.TreeSet;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

/**
 * @author guarguag
 *
 */
public class InventoryXMLParser { //implements Runnable {
	static private final Log LOG = LogFactory.getLog(InventoryXMLParser.class.getName());
	
    protected static final String DEFAULT_PARSER_NAME = "org.apache.xerces.parsers.SAXParser";


	InventoryHandler handler        = new InventoryHandler();
	XMLReader        parser         = null;
	String           parsedResource = null;
	/**
	 * 
	 */
	public InventoryXMLParser() {
	}

	public InventoryXMLParser(final String fileName) {
		parse(fileName);
	}

//	public InventoryXMLParser(URL url) {
//		parse(url);
//	}
		
	public Properties getRepository() {
//		try {
//			synchronized (synchro) {
//				if (!isParsed())
//					synchro.wait();
				return handler.getProperties();
//			}
//		} catch (Exception e) {
//		}
//		return null;
	}
	
	private void init() throws SAXException {
		if (parser != null) {
			return;
		}
		parser = XMLReaderFactory.createXMLReader(DEFAULT_PARSER_NAME);
		
		// set handlers
		parser.setContentHandler(handler);
		parser.setErrorHandler(handler);
	}
	
//	public void parse(URL url) {
//		try {
//			InputStream stream = url.openStream();
//			parse(stream);
//		} catch (Exception e) {
//			log.error(String.format("In XML parsing URL <%s>", url.toString()), e);
//		}		
//	}

	private void parse(final String fileName) {
		try {
			System.out.println("File Name :"+fileName);
			final File file = new File(fileName);
			parsedResource = file.getPath();
			final InputStream stream = new FileInputStream(file);
			try {
				parse(stream);
			} finally {
				System.out.println("Done with Success");
				stream.close();
			}
		} catch (final Exception e) {
			LOG.error(String.format("In XML parsing file <%s>", fileName), e);
		}		
	}

	private void parse(final InputStream stream) throws IOException, SAXException {
		init();
		handler.reset();
		
		final FilteringInputStream filter = new FilteringInputStream(stream);
		final InputSource source = new InputSource(filter);
		source.setSystemId(parsedResource);
		parser.parse(source);
	}
		
	static private class FilteringInputStream extends InputStream {
		InputStream inner = null;
		
		FilteringInputStream(final InputStream stream) {
			this.inner = stream;
		}

		/**
		 * @return
		 * @throws IOException
		 * @see java.io.InputStream#available()
		 */
		@Override
		public int available() throws IOException {
			return inner.available();
		}

		/**
		 * @throws IOException
		 * @see java.io.InputStream#close()
		 */
		@Override
		public void close() throws IOException {
			inner.close();
		}

		/**
		 * @param obj
		 * @return
		 * @see java.lang.Object#equals(java.lang.Object)
		 */
		@Override
		public boolean equals(final Object obj) {
			return inner.equals(obj);
		}

		/**
		 * @return
		 * @see java.lang.Object#hashCode()
		 */
		@Override
		public int hashCode() {
			return inner.hashCode();
		}

		/**
		 * @param readlimit
		 * @see java.io.InputStream#mark(int)
		 */
		@Override
		public void mark(final int readlimit) {
			inner.mark(readlimit);
		}

		/**
		 * @return
		 * @see java.io.InputStream#markSupported()
		 */
		@Override
		public boolean markSupported() {
			return inner.markSupported();
		}

		/**
		 * @return
		 * @throws IOException
		 * @see java.io.InputStream#read()
		 */
		@Override
		public int read() throws IOException {
			int r = -1;
			
			while (true) {
				r = inner.read();
				if (r == -1) {
					break;
				}
				final char ch = (char)r;
				if (!toSkip(ch)) {
					break;
				}
			}			
			
			return r;
		}

		/**
		 * @param b
		 * @param off
		 * @param len
		 * @return
		 * @throws IOException
		 * @see java.io.InputStream#read(byte[], int, int)
		 */
		@Override
		public int read(final byte[] b, final int off, final int len) throws IOException {
			int off1 = off;
			final byte []bb = new byte[len];
			
			final int r = inner.read(bb, 0, len);
			int c = r;
			for (int idx = 0; idx < r; idx++) {
				if (toSkip((char)bb[idx])) {
					c--;
					continue;
				}
				b[off1++] = bb[idx];
			}
			return c;
		}

		/**
		 * @param b
		 * @return
		 * @throws IOException
		 * @see java.io.InputStream#read(byte[])
		 */
		@Override
		public int read(final byte[] b) throws IOException {
			return inner.read(b);
		}

		/**
		 * @throws IOException
		 * @see java.io.InputStream#reset()
		 */
		@Override
		public void reset() throws IOException {
			inner.reset();
		}

		/**
		 * @param n
		 * @return
		 * @throws IOException
		 * @see java.io.InputStream#skip(long)
		 */
		@Override
		public long skip(final long n) throws IOException {
			return inner.skip(n);
		}

		/**
		 * @return
		 * @see java.lang.Object#toString()
		 */
		@Override
		public String toString() {
			return inner.toString();
		}
		
		private boolean toSkip(final char c) {
			boolean r = false;
			
			switch (c) {
			case '\00':
			case '\01':
			case '\02':
			case '\03':
			case '\04':
			case '\05':
			case '\06':
			case '\07':
			case '\10':
			case '\11':
			case '\13':
			case '\16':
			case '\17':
			case '\20':
			case '\21':
			case '\22':
			case '\23':
			case '\24':
			case '\25':
			case '\26':
			case '\27':
			case '\30':
			case '\31':
			case '\32':
			case '\33':
			case '\34':
			case '\35':
			case '\36':
			case '\37':
			case '\177':
				r = true;
				break;

			default:
				break;
			}
			return r;
		}
	}
	
    /** Main. */
	public static void main(final String[] argv) throws Exception {
		
		// is there anything to do?
		if (argv.length == 0) {
			System.exit(1);
		}
		
		InventoryXMLParser parser = null;
		parser = new InventoryXMLParser(argv[0]);
//		parser.parse(argv[0]);
		
		final Properties prop = parser.getRepository();
		final TreeSet set = new TreeSet();
		final Enumeration itr = prop.keys();
		while (itr.hasMoreElements()) {
			set.add(itr.nextElement());
		}
		
		final Iterator iter = set.iterator();
		while (iter.hasNext()) {
			final String key = (String)iter.next();
			prop.getProperty(key);
		}
	}

}

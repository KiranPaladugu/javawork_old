/**
 * File: AbstractSncRealigner.java
 */
package com.marconi.fusion.tmf.i38PlugIn.sbi.realigner;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.apache.commons.lang.mutable.MutableBoolean;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.marconi.fusion.X38.X38AstnPath;
import com.marconi.fusion.X38.X38ConnInfo;
import com.marconi.fusion.X38.X38Layer;
import com.marconi.fusion.X38.X38LinkConnQueryResult;
import com.marconi.fusion.X38.X38LinkId;
import com.marconi.fusion.X38.X38LnType;
import com.marconi.fusion.X38.X38PathGroupData;
import com.marconi.fusion.X38.X38PathInfo;
import com.marconi.fusion.X38.X38PathType;
import com.marconi.fusion.X38.X38Pattern;
import com.marconi.fusion.X38.X38RouteItem;
import com.marconi.fusion.X38.X38Routing;
import com.marconi.fusion.X38.X38SNC;
import com.marconi.fusion.X38.X38SNId;
import com.marconi.fusion.X38.X38SetOfAstnPath;
import com.marconi.fusion.X38.X38SetOfPathInfo;
import com.marconi.fusion.X38.X38SetOfPaths;
import com.marconi.fusion.X38.X38SetOfRouteItem;
import com.marconi.fusion.X38.X38SetOfSignalType;
import com.marconi.fusion.X38.X38SetOfVCG;
import com.marconi.fusion.X38.X38SignalType;
import com.marconi.fusion.X38.X38TPId;
import com.marconi.fusion.X38.X38VCGName;
import com.marconi.fusion.tmf.additionalInformation.AdditionalInfoUtils;
import com.marconi.fusion.tmf.additionalInformation.ProprietaryAdditionalInfo;
import com.marconi.fusion.tmf.db.DBComponent;
import com.marconi.fusion.tmf.db.DBConnection;
import com.marconi.fusion.tmf.db.DBCrossConnectableTp;
import com.marconi.fusion.tmf.db.DBCrossConnection;
import com.marconi.fusion.tmf.db.DBException;
import com.marconi.fusion.tmf.db.DBIterator;
import com.marconi.fusion.tmf.db.DBManagedElement;
import com.marconi.fusion.tmf.db.DBManyRelationship;
import com.marconi.fusion.tmf.db.DBObject;
import com.marconi.fusion.tmf.db.DBRouteDescriptor;
import com.marconi.fusion.tmf.db.DBSnc;
import com.marconi.fusion.tmf.db.DBSncConnectableTp;
import com.marconi.fusion.tmf.db.DBSubnetwork;
import com.marconi.fusion.tmf.db.DBTopologicalLink;
import com.marconi.fusion.tmf.db.DBTp;
import com.marconi.fusion.tmf.db.Predicate;
import com.marconi.fusion.tmf.db.Session;
import com.marconi.fusion.tmf.i38PlugIn.AbstractUser;
import com.marconi.fusion.tmf.i38PlugIn.I38Profile;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.Actions;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.ClientSNCData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.IRouteInfo;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.IRouteProcessor;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.IRouteProcessor2;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.RouteBuilder;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.RouteBuilder2;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.RouteInfo;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.RouteInfo2;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.SNCUtils;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.ServerLinkData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.ServerSNCData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.SetOfClientSNCData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.SetOfServerLinkData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.SetOfServerSNCData;
import com.marconi.fusion.tmf.i38PlugIn.SNCManager.XConnInfo2;
import com.marconi.fusion.tmf.i38PlugIn.db2.IndexManager;
import com.marconi.fusion.tmf.i38PlugIn.db2.LinkHolder;
import com.marconi.fusion.tmf.i38PlugIn.db2.MEHolder;
import com.marconi.fusion.tmf.i38PlugIn.db2.SNCData;
import com.marconi.fusion.tmf.i38PlugIn.db2.SNCHolder;
import com.marconi.fusion.tmf.i38PlugIn.sbi.X38SBIClient;
import com.marconi.fusion.tmf.plugIn.types.AdditionalInfo;
import com.marconi.fusion.tmf.plugIn.types.EMSFreedomLevel;
import com.marconi.fusion.tmf.plugIn.types.MEDn;
import com.marconi.fusion.tmf.plugIn.types.MEId;
import com.marconi.fusion.tmf.plugIn.types.PointData;
import com.marconi.fusion.tmf.plugIn.types.PointDataList;
import com.marconi.fusion.tmf.plugIn.types.PointDn;
import com.marconi.fusion.tmf.plugIn.types.ProtectionEffort;
import com.marconi.fusion.tmf.plugIn.types.SNCDn;
import com.marconi.fusion.tmf.plugIn.types.SNCDnList;
import com.marconi.fusion.tmf.plugIn.types.SNCType;
import com.marconi.fusion.tmf.plugIn.types.SubnetworkConnection;
import com.marconi.fusion.tmf.plugIn.types.TerminationPoint;
import com.marconi.fusion.tmf.sbi.nm.SBIException;
import com.marconi.fusion.tmf.tmfFramework.db.DBAutoClosingItr;
import com.marconi.fusion.tmf.tmfFramework.db.filter.FilteringIterator;
import com.marconi.fusion.tmf.tmfFramework.repository.AdditionalInfoManager;
import com.marconi.fusion.tmf.utils.TpUtils;

/**
 * @author EFRANME
 * 
 */
public abstract class AbstractSncRealigner extends AbstractUser {
	private static final Log LOG = LogFactory
			.getLog(AbstractSncRealigner.class);

	private SNCStats stats = null;
	private String userLabel = null;
	private String owner = null;
	protected Realigner realigner = null;
	protected boolean firstRealignment = false;

	protected SNCStats getStats() {
		return stats;
	}

	protected void setStats(final SNCStats stats) {
		this.stats = stats;
	}

	public String getUserLabel() {
		return userLabel;
	}

	public void setUserLabel(final String userLabel) {
		this.userLabel = userLabel;
	}

	public String getOwner() {
		return owner;
	}

	public void setOwner(final String owner) {
		this.owner = owner;
	}

	public AbstractSncRealigner(final X38SBIClient sbi, final String name, final Realigner realigner) {
		super(sbi, name);
		this.realigner = realigner;

	}

	protected void index(final DBSnc dbSnc) {
		try {
			onIndex(dbSnc);
		} catch (final Exception ex) {
			LOG.warn(format("Missing indexing for '%s'", dbSnc.getInformation().getNativeEMSName().getValue()));
		}
	}

	// TRHM14954
	/*
	 * protected void index(DBSnc dbSnc , MEId meId) { try { onIndex(dbSnc ,meId); } catch (Exception ex) {
	 * log.warn(format("Missing indexing for '%s'", dbSnc.getInformation().getNativeEMSName().getValue())); } }
	 */
	// TRHM14954
	protected void index(final DBManagedElement dbMe, final DBSnc dbSnc) {
		try {
			onIndex(dbMe, dbSnc);

		} catch (final Exception ex) {
			LOG.warn(format("Missing indexing for '%s'", dbSnc.getInformation().getNativeEMSName().getValue()));
		}
	}

	// protected abstract void onIndex(DBSnc dbSnc , MEId meId) throws
	// Exception;//TR HM 14954
	protected abstract void onIndex(DBManagedElement dbMe, DBSnc dbSnc) throws Exception;

	protected abstract void onIndex(DBSnc dbSnc) throws Exception;

	protected void associate(final PathData data, final List<PathData> dataList) {
		try {
			onAssociate(data, dataList);
		} catch (final Exception ex) {
			LOG.error(format("Associate failed", ex));
		}
	}

	protected abstract void onAssociate(PathData data, List<PathData> dataList) throws Exception;

	protected void getPathInfo(final List<PathData> dataList,
			final String hostName) {
		if (LOG.isDebugEnabled()) {
			LOG.debug(format("PathDataList:\n\n%s", new PathDataList(dataList)));
		}
		final PathDataList legacyDataList = new PathDataList();
		final PathDataList astnDataList = new PathDataList();

		for (final PathData data : dataList) {
			if (data.isAstnDD()) {
				astnDataList.add(data);
			} else {
				legacyDataList.add(data);
			}
		}

		// ASTNDD
		final X38SetOfAstnPath setOfAstnPath = new X38SetOfAstnPath();
		for (final PathData data : astnDataList) {
			// fix for TR HP15527 :: changed astnDataList to dataList
			getAstnPathInfo(data, setOfAstnPath, dataList, hostName);
		}
		// ~ASTNDD

		// LEGACY

		// Devo chiedere il PathInfo per ogni pathId di PathData.
		// Sulla report non ho il pathId quindi associo le risposte
		// basandomi sul nome del Path e del suo SignalType.

		// must ask PathInfo for every pathId inside the PathData.
		// on NM reply we don't receive the pathId in input so we associate
		// the response (with the request) using the pathName and its
		// signalType.

		final X38SetOfPaths setOfLegacyPaths = new X38SetOfPaths();
		final Map<PathKey, PathData> map = new TreeMap<PathKey, PathData>();

		for (final PathData data : legacyDataList) {
			setOfLegacyPaths.add(data.getPaths());
			map.put(new PathKey(data.getPathName(), data.getPaths().getSignalType().getValue()), data);
		}

		try {
			final X38SetOfPathInfo setOfLegacyPathInfo = sbi
					.getMessageHandler()
					.getPathInfo(setOfLegacyPaths, hostName);
			for (final X38PathInfo pathInfo : setOfLegacyPathInfo) {
				// fix for TR HP15527 :: changed astnDataList to dataList
				getPathInfo(pathInfo, map, dataList);
			}
		} catch (final Exception ex) {
			// if multiple request fails get single path info
			getSinglePathInfo(legacyDataList, hostName);
		}
		map.clear();
		// ~LEGACY
	}

	private void getLegacyPathInfo(final PathData data,
			final List<PathData> dataList, final String hostName) {
		try {
			final X38SetOfPaths setOfLegacyPaths = new X38SetOfPaths();
			setOfLegacyPaths.add(data.getPaths());
			final X38SetOfPathInfo setOfLegacyPathInfo = sbi
					.getMessageHandler()
					.getPathInfo(setOfLegacyPaths, hostName);

			for (final X38PathInfo pathInfo : setOfLegacyPathInfo) {
				// code added for skipping the circuitGroup creation involving
				// openEnded circuits.
				if (skipUnmanagedCircuitGroups(pathInfo)) {
					LOG.warn("The PathInfo cannot be processed as the aEndVCG and zEndVCG size is greater than 1. Hence Skipping");
					dataList.remove(data); // so that processing of this circuit
					// group is skipped
					continue;
				}
				data.setPathInfo(pathInfo);
			}
			setOfLegacyPathInfo.clear();
		} catch (final Exception exc) {
			LOG.error(exc);
			data.setPathInfo(null);
		}

	}

	/**
	 * Sets Path info to dataList
	 * 
	 * @param pathInfo
	 * @param map
	 * @param dataList
	 */
	private void getPathInfo(final X38PathInfo pathInfo, final Map<PathKey, PathData> map, final List<PathData> dataList) {
		final PathData data = map.get(new PathKey(pathInfo.getPathName().getValue(), pathInfo.getSignalType().getValue()));

		// code added for skipping the circuitGroup creation involving openEnded
		// circuits.
		if (skipUnmanagedCircuitGroups(pathInfo)) {
			LOG.warn("The PathInfo cannot be processed as the aEndVCG and zEndVCG size is greater than 1. Hence Skipping");
			dataList.remove(data); // so that processing of this circuit group
			// is skipped
			return;
		}

		if (data == null) {
			LOG.error(format("Cannot find PathData (SNC skipped):", pathInfo));
			return;
		}
		data.setPathInfo(pathInfo);

	}

	/**
	 * Sets path info in PathData data.
	 * 
	 * @param data
	 * @param setOfAstnPath
	 * @param dataList
	 */
	private void getAstnPathInfo(final PathData data,
			final X38SetOfAstnPath setOfAstnPath,
			final List<PathData> dataList, final String hostName) {
		final X38AstnPath astnPath = new X38AstnPath();
		astnPath.setPathId(data.getPaths().getPathId());
		astnPath.setSignalType(data.getPaths().getSignalType());
		setOfAstnPath.add(astnPath);
		X38SetOfPathInfo setOfPathInfo = null;
		try {
			setOfPathInfo = sbi.getMessageHandler().getPathInfo(setOfAstnPath,
					hostName);
		} catch (final Exception ex) {
			if (LOG.isDebugEnabled()) {
				LOG.debug(String.format("Cannot get PathInfo for: <%s>\n%s", data.getPathName(), ex.getMessage()));
			}
			data.setPathInfo(null);
			return;
		}
		for (final X38PathInfo pathInfo : setOfPathInfo) {
			// code added for skipping the circuitGroup creation involving
			// openEnded circuits.
			if (skipUnmanagedCircuitGroups(pathInfo)) {
				LOG.warn("The PathInfo cannot be processed as the aEndVCG and zEndVCG size is greater than 1. Hence Skipping");
				dataList.remove(data); // so that processing of this circuit
				// group is skipped
				continue;
			}

			data.setPathInfo(pathInfo);
		}
		setOfPathInfo.clear();
	}

	/**
	 * This method is used to skip adding the PathInfo to the PathData, if
	 * aEndVCG or zENdVCG size is greater than 1.
	 * 
	 * @param pathInfo
	 * @return
	 */
	private boolean skipUnmanagedCircuitGroups(final X38PathInfo pathInfo) {

		if (pathInfo.getPathGroupInfo().isPresentPathGroupData()) {
			final X38PathGroupData pathGrpData = pathInfo.getPathGroupInfo().getPathGroupData();
			if (pathGrpData.isPresentAEndVCG()) {
				final X38SetOfVCG aEndVcg = pathGrpData.getAEndVCG();
				/*
				 * If the circuit group is open ended , then worker and protection should end on two different NEs. If the circuit group is
				 * simple then worker and protection should end on same NE.
				 */
				if (aEndVcg.size() > 1) {
					final X38VCGName vcg1Name = aEndVcg.get(0).getVcgName();
					final X38VCGName vcg2Name = aEndVcg.get(1).getVcgName();
					if (!vcg1Name.equals(vcg2Name)) {
						return true;
					}
				}
			}
			if (pathGrpData.isPresentZEndVCG()) {
				final X38SetOfVCG zEndVcg = pathGrpData.getZEndVCG();
				if (zEndVcg.size() > 1) {
					final X38VCGName vcg1Name = zEndVcg.get(0).getVcgName();
					final X38VCGName vcg2Name = zEndVcg.get(1).getVcgName();
					if (!vcg1Name.equals(vcg2Name)) {
						return true;
					}
				}
			}

		}
		return false;
	}

	private void getSinglePathInfo(final List<PathData> dataList,
			final String hostName) {
		final PathDataList legacyDataList = new PathDataList();
		final PathDataList astnDataList = new PathDataList();

		for (final PathData data : dataList) {
			if (data.isAstnDD()) {
				astnDataList.add(data);
			} else {
				legacyDataList.add(data);
			}
		}

		// ASTNDD
		final X38SetOfAstnPath setOfAstnPath = new X38SetOfAstnPath();
		for (final PathData data : astnDataList) {
			getAstnPathInfo(data, setOfAstnPath, dataList, hostName);
		}
		// ~ASTNDD

		// LEGACY
		for (final PathData data : legacyDataList) {
			getLegacyPathInfo(data, dataList, hostName);
		}
		// ~LEGACY
	}

	protected void getRouting(final List<PathData> dataList,
			final String hostName) throws Exception {
		if (!realigner.getProfile().sncTPRouting) {
			return;
		}
		// log.warn("TP ROUTING ENABLED.");

		for (final PathData data : dataList) {
			if (data.getPathInfo() == null) {
				LOG.error(format("Cannot find PathInfo for '%s'", data.getPathName()));
				continue;
			}

			final X38PathType pathType = data.getPathInfo().getPathType();

			try {
				if (pathType.isBidPath() || pathType.isUniPath() || pathType.isBroadPath()) {
					getRoutingIfPath(data, hostName);
				} else {
					LOG.error(format("Unmanaged PathType:", data.getPathInfo()));
				}
			} catch (final Exception ex) {
				LOG.error(format("Cannot get Routing:", data.getPathInfo()));
				LOG.error(format(ex));
			}
		}
	}

	private void getRoutingIfPath(final PathData data, final String hostName)
			throws SBIException {

		if (LOG.isDebugEnabled()) {
			LOG.debug(String.format("Fetching TPRouting for path <%s>", data.getPathName()));
		}
		/*
		 * Fix for TR HO28943,pathCategory is optional in X38Constraints structure, checking whether pathCategory is present in
		 * X38Constraints structure and then check whether it is related to vc4path
		 */
		boolean isVC4Path = false;
		if (data.getPathInfo().getConstraints().isPresentPathCategory()
				&& data.getPathInfo().getConstraints().getPathCategory().isVc4Path()) {
			isVC4Path = true;
		}
		if (data.getPathInfo().getRoutingInfo().isPresentRouting()) {
			data.setRouting(sbi.getMessageHandler().getTPRouting(
					data.getPathInfo().getRoutingInfo().getRouting(), true,
					isVC4Path, data.getPathInfo().getSignalType(), hostName));
		} else {
			LOG.error(format("RoutingInformation not present in Path:", data.getPathInfo()));
		}
	}

	protected X38SNId getSNId(final MEDn meDn) throws Exception {
		try {
			Session session = sbi.getDatabase().getSession();
			if (session == null) {
				session = sbi.getDatabase().beginSession(false);
			}

			final MEHolder me = sbi.getDatabase().getManagedElement(meDn);
			if (me == null) {
				LOG.error(format("Cannot find ManagedElement:", meDn));
				throw new Exception("Cannot find ManagedElement.");
			}
			return me.getData().getX38SNId(X38Layer.PH);
		} finally {
			sbi.getDatabase().terminateSession();
		}
	}

	protected void process(final List<PathData> dataList) throws Exception {
		if (dataList.size() == 0) {
			return;
		}
		/* Fix for TR HN52655; Using Session object to track the session */
		Session session = null;
		try {
			session = sbi.getDatabase().beginSession(true);
			final DBSubnetwork sn = sbi.getDatabase().getDBSubnetwork(sbi.getSNDn());
			for (final PathData data : dataList) {
				if (data.getPathInfo() == null) {
					LOG.error(format("Invalid PathInfo for '%s'(SNC skipped).", data.getPathName()));
					incSkipped();
					continue;
				}
				try {
					process(sn, data);
				} catch (final Exception ex) {
					LOG.error(format("Exception while processing path :", ex));
					// process single path
					LOG.info("Problem while processing path, forcing the process");
					processSinglePathInfo(dataList);
					return;
				}
				associate(data, dataList);

				if (firstRealignment) {
					data.clear();
				}
			}
			if (firstRealignment) {
				dataList.clear();
			}
			if (session != null) {
				session.commit();
			}
		} catch (final DBException e) {
			LOG.error(format("DBException while processing path", e));
			if (session != null) {
				session.abort();
			}
		} catch (final Exception ex) {
			LOG.error(format("Transaction Rollback.", ex));
		} finally {
			if (session != null) {
				session.terminate();
				session = null;
			}
		}
	}

	/**
	 * Processing the single path data by opening seperate database transaction.
	 * 
	 * @param dataList
	 */
	private void processSinglePathInfo(final List<PathData> dataList) {
		/* Fix for TR HN52655; Using Session object to track the session */
		Session session = null;
		for (final PathData data : dataList) {
			try {
				if (data.getPathInfo() == null) {
					LOG.error(format("Invalid PathInfo for '%s'(SNC skipped).", data.getPathName()));
					incSkipped();
					continue;
				}

				session = sbi.getDatabase().beginSession(true);
				final DBSubnetwork sn = sbi.getDatabase().getDBSubnetwork(sbi.getSNDn());
				try {
					process(sn, data);
				} catch (final Exception ex) {
					incSkipped();
					LOG.error(format(ex));
					LOG.error(format("Error processing '%s' (SNC skipped).", data.getPathName()));
					session.terminate();
					session = null;
					continue;
				}

				associate(data, dataList);

				if (firstRealignment) {
					data.clear();
				}

				if (session != null) {
					session.commit();
				}

			} catch (final DBException e) {
				LOG.error(format("DBException while processing path", e));
				if (session != null) {
					session.abort();
				}
			} catch (final Exception ex) {
				LOG.error(format(ex));
				LOG.error(format("Error in processing ", data.getPathName()));
			} finally {
				if (session != null) {
					session.terminate();
				}
			}

		}

		if (firstRealignment) {
			dataList.clear();
		}

	}

	protected void process(final DBSubnetwork sn, final PathData pathData) throws Exception {
		if (pathData.hasTPRouting()) {
			processTP(sn, pathData);
		} else {
			processString(sn, pathData);
		}
	}

	protected void processString(final DBSubnetwork sn, final PathData pathData) throws Exception {

		if (LOG.isDebugEnabled()) {
			LOG.debug(format("Processing SNC '%s'", pathData.getPathInfo().getPathName().getValue()));
		}

		final SetOfClientSNCData clientSncData = pathData.getClientSncs();
		final List<ClientSNCData> clientSncs = clientSncData.getClientSncs();

		final SetOfServerLinkData serverLinksData = pathData.getServerLinks();
		final List<ServerLinkData> serverLinksList = serverLinksData.getServerLinks();

		final SetOfServerSNCData serverSncData = pathData.getServerSncs();
		final List<ServerSNCData> serverSncs = serverSncData.getServerSncs();

		final IRouteProcessor routeProcessor = getRouteProcessor();
		final RouteInfo[] routeInfos = routeProcessor.getRoute(pathData);
		for (RouteInfo routeInfo : routeInfos) {
			// If Cp Management is enabled
			if (sbi.getPlugIn().getProfile().getBoolProperty(I38Profile.Key.CONTROLPLANE, false)) {
				// Need to skip SNC when any of TPs involved the SNC are allocated to Cp
				final boolean isCtrlPlaneResource = isWsonResourceInvolvedInSnc(routeInfo);
				if (isCtrlPlaneResource) {
					return;
				}
			}

			final X38SNC i38SNC = getX38SNC(routeInfo);
			pathData.setRouteInfo(routeInfo);
			final SubnetworkConnection snc = toSubnetworkConnection(pathData, i38SNC);
			if (snc == null) {
				LOG.error(format("Invalid SubnetworkConnection (SNC skipped):", pathData.getPathInfo()));
				incSkipped();
				continue;
			}

			boolean error = false;
			boolean created = false;

			DBSnc dbSnc = null;
			if (!firstRealignment) {
				dbSnc = find(snc.getName());
			}

			final X38TPId toTpId = getToTPId(routeInfo);
			final boolean isLeg = toTpId != null;

			final SNCData sncData = new SNCData(pathData.getPaths().getPathId(), pathData.getPathInfo().getSignalType(), pathData.isPath(),
					pathData.isAstnDD(), isLeg, i38SNC, toTpId);

			if (dbSnc == null) {
				dbSnc = sbi.getDatabase().create(snc);
				created = true;
				dbSnc.addAdditionalInformation(sncData);

				if (clientSncs.size() > 0) {
					dbSnc.addAdditionalInformation(clientSncData);
				}
				if (serverSncs.size() > 0) {
					dbSnc.addAdditionalInformation(serverSncData);
				}
				if (serverLinksList.size() > 0) {
					dbSnc.addAdditionalInformation(serverLinksData);
				}
			} else {
				// TODO: se funziona la setAdditionalInformation()...
				// dbSnc.setAdditionalInformation(sncData);
				// TR HL79696
				if (dbSnc.getAdditionalInformation(SNCData.NAME) != null) {
					dbSnc.setAdditionalInformation(sncData);
				} else {
					dbSnc.addAdditionalInformation(sncData);
				}

				// Update the client SNC additional information
				if (clientSncs.size() > 0) {
					if (dbSnc.getAdditionalInformation(SetOfClientSNCData.NAME) != null) {
						dbSnc.setAdditionalInformation(clientSncData);
					} else {
						dbSnc.addAdditionalInformation(clientSncData);
					}
				} else {
					if (dbSnc.getAdditionalInformation(SetOfClientSNCData.NAME) != null) {
						dbSnc.removeAdditionalInformation(SetOfClientSNCData.NAME);
					}
				}

				// Update the server SNC additional information
				if (serverSncs.size() > 0) {
					if (dbSnc.getAdditionalInformation(SetOfServerSNCData.NAME) != null) {
						dbSnc.setAdditionalInformation(serverSncData);
					} else {
						dbSnc.addAdditionalInformation(serverSncData);
					}
				} else {
					if (dbSnc.getAdditionalInformation(SetOfServerSNCData.NAME) != null) {
						dbSnc.removeAdditionalInformation(SetOfServerSNCData.NAME);
					}
				}

				if (serverLinksList.size() > 0) {
					final SetOfServerLinkData serverLinkData = (SetOfServerLinkData) dbSnc
							.getAdditionalInformation(SetOfServerLinkData.NAME);
					if (serverLinkData != null) {
						dbSnc.setAdditionalInformation(serverLinksData);
					} else {
						dbSnc.addAdditionalInformation(serverLinksData);
					}
				} else {
					if (dbSnc
							.getAdditionalInformation(SetOfServerLinkData.NAME) != null) {
						dbSnc.removeAdditionalInformation(SetOfServerLinkData.NAME);
					}
				}
			}

			final String sncNativeEmsName = dbSnc.getNativeEMSName().getValue();

			if (LOG.isDebugEnabled() && clientSncs.size() > 0) {
				final StringBuilder sb = new StringBuilder(String.format("Client SNCs associated to server SNC : <%s> ", sncNativeEmsName));
				for (final ClientSNCData clientSnc : clientSncs) {
					sb.append("\n" + clientSnc.getPathName());
				}
				LOG.debug(format(sb.toString()));
			}

			if (LOG.isDebugEnabled() && serverSncs.size() > 0) {
				final StringBuilder sb = new StringBuilder(String.format("Server SNCs associated to client SNC : <%s> ", sncNativeEmsName));
				for (final ServerSNCData serverSnc : serverSncs) {
					sb.append("\n" + serverSnc.getPathName());
				}
				LOG.debug(format(sb.toString()));
			}

			if (LOG.isDebugEnabled() && serverLinksList.size() > 0) {
				final StringBuilder sb = new StringBuilder(String.format("Server Links associated to client SNC : <%s> ", sncNativeEmsName));
				for (final ServerLinkData server : serverLinksList) {
					sb.append("\n" + server.getLinkName());
				}
				LOG.debug(format(sb.toString()));
			}

			// Associate this SNC as ServerSNC to all the client SNCs
			final ServerSNCData serverData = new ServerSNCData(pathData);
			associateServerToClient(dbSnc, clientSncData, serverData);

			// Associate this SNC as ClientSNC to all the server links
			final ClientSNCData clientData = new ClientSNCData(pathData);
			associateServerLinkToClient(dbSnc, serverLinksData, clientData);
			associateClientToServer(dbSnc, serverSncData, clientData);

			incCount(pathData.getPathInfo().getSignalType());

			// set index on nativeEMSName
			index(dbSnc);

			final RouteBuilder routeBuilder = new RouteBuilder(sbi, name(), snc);
			routeInfo = routeBuilder.build(routeInfo, dbSnc);
			routeBuilder.associate(dbSnc, created);

			error = processTpData(routeInfo, dbSnc, pathData, snc);
			final X38SignalType signalType = pathData.getPaths().getSignalType();
			AdditionalInfoUtils.append(snc.getAdditionalInfo(), getAdditionalInfo(routeInfo, pathData.getProtectionEffort(), signalType));
			updateType(snc, routeInfo);

			if (created) {
				dbSnc.setInformation(snc);
			} else {
				update(dbSnc, snc);
			}

			pathData.setSnc(dbSnc.getInformation());
			pathData.associate(dbSnc.getDn());
			updateTPConnectionState(dbSnc);
			setIndexes(snc, dbSnc, sncData.isPath());
			if (error) {
				incErrors();
			}
		}
	}

	/**
	 * Sets the TPData of AEnds and ZEnds for given dbSnc.
	 * 
	 * @param routeInfo
	 * @param dbSnc
	 * @param pathData
	 * @param snc
	 * @return
	 */
	private boolean processTpData(final RouteInfo routeInfo, final DBSnc dbSnc, final PathData pathData, final SubnetworkConnection snc) {
		boolean error = false;
		dbSnc.getAEnds().clear();
		if (routeInfo.getAEnds() != null && routeInfo.getAEnds().length > 0) {
			for (final DBSncConnectableTp<?, ?> tp : routeInfo.getAEnds()) {
				dbSnc.getAEnds().add(tp);
			}
			setPointData(snc.getAEnd(), dbSnc.getAEnds().iterator());
		} else {
			LOG.error(format("Invalid aEnds for:", pathData.getPathInfo().getPathName()));
			error = true;
		}

		dbSnc.getZEnds().clear();
		if (routeInfo.getZEnds() != null && routeInfo.getZEnds().length > 0) {
			for (final DBSncConnectableTp<?, ?> tp : routeInfo.getZEnds()) {
				dbSnc.getZEnds().add(tp);
			}
			setPointData(snc.getZEnd(), dbSnc.getZEnds().iterator());

		} else {
			LOG.error(format("Invalid zEnds for:", pathData.getPathInfo().getPathName()));
			error = true;
		}
		return error;
	}

	protected void processTP(final DBSubnetwork sn, final PathData pathData) throws Exception {
		if (LOG.isDebugEnabled()) {
			LOG.debug(format("Processing SNC '%s'", pathData.getPathInfo().getPathName().getValue()));
		}

		final IRouteProcessor2 routeProcessor = getRouteProcessor(pathData.getPathInfo().getSignalType());
		final List<RouteInfo2> routeInfos = routeProcessor.getRoute(pathData);
		// if (routeInfos == null) {
		// log.debug(format("SubnetworkConnection rejected:",
		// pathData.pathInfo.getPathName()));
		// incSkipped();
		// DBSnc snc =
		// sbi.getDatabase().getIndexes().get(pathData.getPathInfo().getPathName());
		// if (snc != null) {
		// log.debug(format("Deleting rejected SNC:", snc.getInformation()));
		// sbi.getDatabase().delete(snc);
		// }
		// return;
		// }

		// sbi.getConfigPipe().getLegList(pathData.getPaths());
		// sbi.getConfigPipe().makeLegQuery(pathData.getPathName(),
		// pathData.getPaths().getPathId(),
		// pathData.getPathInfo().getSignalType());

		for (final RouteInfo2 routeInfo : routeInfos) {
			// If Cp Management is enabled
			if (sbi.getPlugIn().getProfile().getBoolProperty(I38Profile.Key.CONTROLPLANE, false)) {
				// Need to skip SNC when any of TPs involved the SNC are allocated to Cp
				final boolean isCtrlPlaneResource = isWsonResourceInvolvedInSnc(routeInfo);
				if (isCtrlPlaneResource) {
					return;
				}
			}

			final X38SNC i38SNC = getX38SNC(routeInfo);
			pathData.setRouteInfo(routeInfo);
			final SubnetworkConnection snc = toSubnetworkConnection(pathData, i38SNC);
			if (snc == null) {
				LOG.error(format("Invalid SubnetworkConnection (SNC skipped):", pathData.getPathInfo()));
				incSkipped();
				continue;
			}

			final X38TPId toTPId = getToTPId(routeInfo);
			final boolean isLeg = toTPId != null;

			boolean error = false;
			final MutableBoolean created = new MutableBoolean();

			DBSnc dbSnc = null;
			if (!firstRealignment) {
				dbSnc = find(snc.getName());
			}

			final SNCData sncData = new SNCData(pathData.getPaths().getPathId(), pathData.getPathInfo().getSignalType(), pathData.isPath(),
					pathData.isAstnDD(), isLeg, i38SNC, toTPId);

			dbSnc = createOrupdateDBSnc(dbSnc, snc, pathData, sncData, created);
			// RouteBuilder routeBuilder = new RouteBuilder(sbi, name(), snc);
			// routeInfo = routeBuilder.build(routeInfo,
			// dbSnc.getInformation());
			final RouteBuilder2 routeBuilder = new RouteBuilder2(sbi, dbSnc);
			/*
			 * Fix for TR - HL96824 - Worker state and protection states of the circuit are considered to create the xConns
			 */
			routeBuilder.build(snc, routeInfo, pathData.getPathInfo().getPathState());
			routeBuilder.associate(dbSnc, created.booleanValue());

			error = processTPData(routeInfo, dbSnc, pathData, snc);

			final List<DBCrossConnectableTp<?, ?>> aEnds = routeInfo.getAEnds();
			final List<DBCrossConnectableTp<?, ?>> zEnds = routeInfo.getZEnds();
			final X38SignalType signalType = pathData.getPaths().getSignalType();

			/*
			 * If all the crossconnections of an SNC are fixed,setting "additionalInfo" fixed for the SNC to true TR HO94936. If all the
			 * cross connections for the SNC are fixed, then the SNC Fixed will be set to true. Removes from the AdditionalInfo if the entry
			 * already exists.
			 */
			final AdditionalInfo additionalInfo = getAdditionalInfo(routeInfo, pathData.getProtectionEffort(), signalType);
			if (AdditionalInfoUtils.exists(snc.getAdditionalInfo(), "Fixed", "True")) {
				AdditionalInfoUtils.remove(additionalInfo, "Fixed");
			}
			AdditionalInfoUtils.append(snc.getAdditionalInfo(), additionalInfo);

			snc.setSncType(RouteInfo2.getSNCType(aEnds != null ? aEnds.size() : 0, zEnds != null ? zEnds.size() : 0));

			if (created.booleanValue()) {
				dbSnc.setInformation(snc);
			} else {
				update(dbSnc, snc);
			}

			pathData.setSnc(snc);
			pathData.associate(dbSnc.getDn());
			updateTPConnectionState(dbSnc);
			setIndexes(snc, dbSnc, sncData.isPath());
			if (error) {
				incErrors();
			}

			if (sbi.isFirstRealignment()) {
				routeInfo.clear();
			}
		}

		if (sbi.isFirstRealignment()) {
			routeInfos.clear();
		}
	}

	/**
	 * This method will creates dbSnc object if dbSnc is null and updates if not
	 * null
	 * 
	 * @param dbSnc
	 * @param snc
	 * @param pathData
	 * @param sncData
	 * @param created
	 *            TODO
	 * @return
	 * @throws Exception
	 */
	private DBSnc createOrupdateDBSnc(final DBSnc dbSnc, final SubnetworkConnection snc, final PathData pathData, final SNCData sncData,
			final MutableBoolean created) throws Exception {
		DBSnc dbSnc1 = dbSnc;

		final SetOfClientSNCData clientSncData = pathData.getClientSncs();
		final List<ClientSNCData> clientSncs = clientSncData.getClientSncs();

		final SetOfServerLinkData serverLinksData = pathData.getServerLinks();
		final List<ServerLinkData> serverLinksList = serverLinksData.getServerLinks();

		final SetOfServerSNCData serverSncData = pathData.getServerSncs();
		final List<ServerSNCData> serverSncs = serverSncData.getServerSncs();

		final String sncNativeEmsName = snc.getNativeEMSName().getValue();
		if (dbSnc1 == null) {
			dbSnc1 = sbi.getDatabase().create(snc);
			if (LOG.isDebugEnabled()) {
				LOG.debug(format(String.format(" Created SNC: <%s> ", snc.getNativeEMSName().getValue())));
			}
			created.setValue(true);
			dbSnc1.addAdditionalInformation(sncData);
			dbSnc1.addAdditionalInformation(pathData.getClientSncs());

			if (clientSncs.size() > 0) {
				dbSnc1.addAdditionalInformation(clientSncData);
			}
			if (serverSncs.size() > 0) {
				dbSnc1.addAdditionalInformation(serverSncData);
			}
			if (serverLinksList.size() > 0) {
				dbSnc1.addAdditionalInformation(serverLinksData);
			}

		} else {
			// TODO: se funziona la setAdditionalInformation()...
			// TR HL79696
			if (dbSnc1.getAdditionalInformation(SNCData.NAME) != null) {
				dbSnc1.setAdditionalInformation(sncData);
			} else {
				dbSnc1.addAdditionalInformation(sncData);
			}

			// Update the client SNC additional information
			if (clientSncs.size() > 0) {
				if (dbSnc1.getAdditionalInformation(SetOfClientSNCData.NAME) != null) {
					dbSnc1.setAdditionalInformation(clientSncData);
				} else {
					dbSnc1.addAdditionalInformation(clientSncData);
				}
			} else {
				if (dbSnc1.getAdditionalInformation(SetOfClientSNCData.NAME) != null) {

					dbSnc1.removeAdditionalInformation(SetOfClientSNCData.NAME);
				}
			}

			// Update the server SNC additional information
			if (serverSncs.size() > 0) {
				if (dbSnc1.getAdditionalInformation(SetOfServerSNCData.NAME) != null) {
					dbSnc1.setAdditionalInformation(serverSncData);
				} else {
					dbSnc1.addAdditionalInformation(serverSncData);
				}
			} else {
				if (dbSnc1.getAdditionalInformation(SetOfServerSNCData.NAME) != null) {
					dbSnc1.removeAdditionalInformation(SetOfServerSNCData.NAME);
				}
			}

			if (serverLinksList.size() > 0) {
				final SetOfServerLinkData serverLinkData = (SetOfServerLinkData) dbSnc1.getAdditionalInformation(SetOfServerLinkData.NAME);
				if (serverLinkData != null) {
					dbSnc1.setAdditionalInformation(serverLinksData);
				} else {
					dbSnc1.addAdditionalInformation(serverLinksData);
				}
			} else {
				if (dbSnc1.getAdditionalInformation(SetOfServerLinkData.NAME) != null) {
					dbSnc1.removeAdditionalInformation(SetOfServerLinkData.NAME);
				}
			}

			created.setValue(false);
		}

		if (LOG.isDebugEnabled() && clientSncs.size() > 0) {
			final StringBuilder sb = new StringBuilder(String.format("Client SNCs associated to server SNC : <%s> ", sncNativeEmsName));
			for (final ClientSNCData clientSnc : clientSncs) {
				sb.append("\n" + clientSnc.getPathName());
			}
			LOG.debug(format(sb.toString()));
		}

		if (LOG.isDebugEnabled() && clientSncs.size() > 0) {
			final StringBuilder sb = new StringBuilder(String.format("Server SNCs associated to client SNC : <%s> ", sncNativeEmsName));
			for (final ServerSNCData serverSnc : serverSncs) {
				sb.append("\n" + serverSnc.getPathName());
			}
			LOG.debug(format(sb.toString()));
		}

		if (LOG.isDebugEnabled() && serverLinksList.size() > 0) {
			final StringBuilder sb = new StringBuilder(String.format("Server Links associated to client SNC : <%s> ", sncNativeEmsName));
			for (final ServerLinkData server : serverLinksList) {
				sb.append("\n" + server.getLinkName());
			}
			LOG.debug(format(sb.toString()));
		}

		// Associate this SNC as ServerSNC to all the client SNCs
		final ServerSNCData serverData = new ServerSNCData(pathData);
		associateServerToClient(dbSnc1, clientSncData, serverData);

		// Associate this SNC as ClientSNC to all the server links
		final ClientSNCData clientData = new ClientSNCData(pathData);
		associateServerLinkToClient(dbSnc1, serverLinksData, clientData);
		associateClientToServer(dbSnc1, serverSncData, clientData);

		incCount(pathData.getPathInfo().getSignalType());
		// set index on nativeEMSName
		index(dbSnc1);

		if (LOG.isDebugEnabled()) {
			LOG.debug(format(String.format(" Indexed SNC: <%s> ", sncNativeEmsName)));
		}

		return dbSnc1;
	}

	private void associateClientToServer(final DBSnc clientSnc, final SetOfServerSNCData serverSncs, final ClientSNCData clientSncData) {

		final List<ServerSNCData> serverSncList = serverSncs.getServerSncs();

		if (serverSncList.size() <= 0) {
			return;
		}

		for (final ServerSNCData serverSncData : serverSncList) {

			SNCHolder serverSncHolder = null;

			try {
				serverSncHolder = sbi.getDatabase().getSnc(serverSncData.getPathName());
			} catch (final Exception ex) {
				LOG.error(format(String.format("Exception while trying to get SNC <%s> :", serverSncData.getPathName(), ex)));
			}

			if (serverSncHolder != null) {
				final DBSnc serverDBSnc = serverSncHolder.getDBObject();
				SetOfClientSNCData clientSNCInfo = (SetOfClientSNCData) serverDBSnc.getAdditionalInformation(SetOfClientSNCData.NAME);
				if (clientSNCInfo != null) {
					final List<ClientSNCData> clientSncList = clientSNCInfo.getClientSncs();
					if (!clientSncList.contains(clientSncData)) {
						clientSncList.add(clientSncData);
					} else {
						LOG.debug(format(String
								.format("SNC <%s> is already associated as a server SNC to the server SNC <%s>",
										clientSncData.getPathName(), serverDBSnc.getInformation().getNativeEMSName().getValue())));
					}
					serverDBSnc.setAdditionalInformation(clientSNCInfo);
				} else {
					clientSNCInfo = new SetOfClientSNCData();
					clientSNCInfo.add(clientSncData);
					serverDBSnc.addAdditionalInformation(clientSNCInfo);
				}

				final List<ClientSNCData> clientSncs = clientSNCInfo.getClientSncs();
				if (LOG.isDebugEnabled() && clientSncs.size() > 0) {
					final StringBuilder sb = new StringBuilder(String.format("Client SNCs associated to server SNC : <%s> ", serverDBSnc
							.getNativeEMSName().getValue()));
					for (final ClientSNCData client : clientSncs) {
						sb.append("\n" + client.getPathName());
					}
					LOG.debug(format(sb.toString()));
				}

			} else {
				LOG.error(format(String.format("Could not find the server SNC <%s> in db. Cannot associate the client SNC <%s> to it",
						serverSncData
						.getPathName(), clientSnc.getInformation().getNativeEMSName().getValue())));
			}

		}

	}

	private void associateServerToClient(final DBSnc serverSnc, final SetOfClientSNCData clientSncs, final ServerSNCData serverSncData) {

		final List<ClientSNCData> clientSncList = clientSncs.getClientSncs();

		if (clientSncList.size() <= 0) {
			return;
		}

		for (final ClientSNCData clientSncData : clientSncList) {

			SNCHolder clientSncHolder = null;

			try {
				clientSncHolder = sbi.getDatabase().getSnc(clientSncData.getPathName());
			} catch (final Exception ex) {
				LOG.error(format(String.format("Exception while trying to get SNC <%s> :", clientSncData.getPathName(), ex)));
			}

			if (clientSncHolder != null) {
				final DBSnc clientDBSnc = clientSncHolder.getDBObject();
				SetOfServerSNCData serverSNCInfo = (SetOfServerSNCData) clientDBSnc.getAdditionalInformation(SetOfServerSNCData.NAME);
				if (serverSNCInfo != null) {
					final List<ServerSNCData> serverSncList = serverSNCInfo.getServerSncs();
					if (!serverSncList.contains(serverSncData)) {
						serverSncList.add(serverSncData);
					} else {
						LOG.debug(format(String
								.format("SNC <%s> is already associated as a server SNC to the client SNC <%s>",
										serverSncData.getPathName(), clientDBSnc.getInformation().getNativeEMSName().getValue())));
					}
					clientDBSnc.setAdditionalInformation(serverSNCInfo);
				} else {
					serverSNCInfo = new SetOfServerSNCData();
					serverSNCInfo.add(serverSncData);
					clientDBSnc.addAdditionalInformation(serverSNCInfo);
				}

				final List<ServerSNCData> serverSncs = serverSNCInfo.getServerSncs();
				if (LOG.isDebugEnabled() && serverSncs.size() > 0) {
					final StringBuilder sb = new StringBuilder(String.format("Server SNCs associated to client SNC : <%s> ", clientDBSnc
							.getNativeEMSName().getValue()));
					for (final ServerSNCData server : serverSncs) {
						sb.append("\n" + server.getPathName());
					}
					LOG.debug(format(sb.toString()));
				}

			} else {
				LOG.error(format(String.format("Could not find the client SNC <%s> in db. Cannot associate the server SNC <%s> to it",
						clientSncData
						.getPathName(), serverSnc.getInformation().getNativeEMSName().getValue())));
			}

		}

	}

	private void associateServerLinkToClient(final DBSnc clientSnc, final SetOfServerLinkData serverLinks, final ClientSNCData clientSncData) {

		final List<ServerLinkData> serverLinksList = serverLinks.getServerLinks();

		if (serverLinksList.size() <= 0) {
			return;
		}

		for (final ServerLinkData serverLinkData : serverLinksList) {

			LinkHolder serverLinkHolder = null;

			try {
				serverLinkHolder = sbi.getDatabase().findTopologicalLink(serverLinkData.getLinkName());
			} catch (final Exception ex) {
				LOG.error(format(String.format("Exception while trying to get Link <%s> :", serverLinkData.getLinkName(), ex)));
			}

			if (serverLinkHolder != null) {
				final DBTopologicalLink serverDBLink = serverLinkHolder.getDBObject();
				SetOfClientSNCData clientSncInfo = (SetOfClientSNCData) serverDBLink.getAdditionalInformation(SetOfClientSNCData.NAME);
				if (clientSncInfo != null) {
					final List<ClientSNCData> clientSncList = clientSncInfo.getClientSncs();
					if (!clientSncList.contains(clientSncData)) {
						clientSncList.add(clientSncData);
					} else {
						LOG.debug(format(String
								.format("SNC <%s> is already associated as a client SNC to the server Link <%s>",
										clientSncData.getPathName(), serverDBLink.getInformation().getNativeEMSName().getValue())));
					}
					serverDBLink.setAdditionalInformation(clientSncInfo);
				} else {
					clientSncInfo = new SetOfClientSNCData();
					clientSncInfo.add(clientSncData);
					serverDBLink.addAdditionalInformation(clientSncInfo);
				}

				final List<ClientSNCData> clientSncs = clientSncInfo.getClientSncs();
				if (LOG.isDebugEnabled() && clientSncs.size() > 0) {
					final StringBuilder sb = new StringBuilder(String.format("Client SNCs associated to server Link : <%s> ", serverDBLink
							.getNativeEMSName().getValue()));
					for (final ClientSNCData client : clientSncs) {
						sb.append("\n" + client.getPathName());
					}
					LOG.debug(format(sb.toString()));
				}

			} else {
				LOG.error(format(String.format("Could not find the server Link <%s> in db. Cannot associate the client SNC <%s> to it",
						serverLinkData
						.getLinkName(), clientSnc.getInformation().getNativeEMSName().getValue())));
			}

		}

	}

	private boolean processTPData(final RouteInfo2 routeInfo, final DBSnc dbSnc, final PathData pathData, final SubnetworkConnection snc) {

		final List<DBCrossConnectableTp<?, ?>> aEnds = routeInfo.getAEnds();
		dbSnc.getAEnds().clear();
		boolean error = false;
		if (aEnds != null && aEnds.size() > 0) {
			for (final DBSncConnectableTp<?, ?> tp : routeInfo.getAEnds()) {
				dbSnc.getAEnds().add(tp);
			}
			setPointData(snc.getAEnd(), dbSnc.getAEnds().iterator());
		} else {
			LOG.error(format("Invalid aEnds for:", pathData.getPathInfo().getPathName()));
			error = true;
		}

		final List<DBCrossConnectableTp<?, ?>> zEnds = routeInfo.getZEnds();
		dbSnc.getZEnds().clear();
		if (zEnds != null && zEnds.size() > 0) {
			for (final DBSncConnectableTp<?, ?> tp : routeInfo.getZEnds()) {
				dbSnc.getZEnds().add(tp);
			}
			setPointData(snc.getZEnd(), dbSnc.getZEnds().iterator());
		} else {
			LOG.error(format("Invalid zEnds for:", pathData.getPathInfo().getPathName()));
			error = true;
		}

		return error;
	}

	protected DBSnc find(final SNCDn dn) throws Exception {
		return sbi.getDatabase().getDBSnc(dn);
	}

	protected void update(final DBSnc in, final SubnetworkConnection newInfo) {
		final SubnetworkConnection info = in.getInformation();
		// info.setUserLabel(newInfo.getUserLabel());
		info.setNativeEMSName(newInfo.getNativeEMSName());
		// info.setOwner(newInfo.getOwner());
		info.setSncState(newInfo.getSncState());
		info.setDirection(newInfo.getDirection());
		info.setRate(newInfo.getRate());
		info.setStaticProtectionLevel(newInfo.getStaticProtectionLevel());
		info.setSncType(newInfo.getSncType());
		info.setAEnd(newInfo.getAEnd());
		info.setZEnd(newInfo.getZEnd());
		info.setRerouteAllowed(newInfo.getRerouteAllowed());
		info.setNetworkRouted(newInfo.getNetworkRouted());
		info.setAdditionalInfo(newInfo.getAdditionalInfo());

		/*
		 * info.setIntendedRoute(newInfo.getIntendedRoute()); info.setBackupRoute(newInfo.getBackupRoute());
		 */

		in.setInformation(info);
	}

	/**
	 * Updates information of DBConnection object
	 * 
	 * @param in
	 * @param newInfo
	 */
	protected void update(final DBConnection in, final SubnetworkConnection newInfo) {
		final SubnetworkConnection info = in.getInformation();
		info.setNativeEMSName(newInfo.getNativeEMSName());
		info.setSncState(newInfo.getSncState());
		info.setDirection(newInfo.getDirection());
		info.setRate(newInfo.getRate());
		info.setStaticProtectionLevel(newInfo.getStaticProtectionLevel());
		info.setSncType(newInfo.getSncType());
		info.setAEnd(newInfo.getAEnd());
		info.setZEnd(newInfo.getZEnd());
		info.setRerouteAllowed(newInfo.getRerouteAllowed());
		info.setNetworkRouted(newInfo.getNetworkRouted());
		info.setAdditionalInfo(newInfo.getAdditionalInfo());

		in.setInformation(info);
	}

	protected AdditionalInfo getAdditionalInfo(final IRouteInfo routeInfo, final ProtectionEffort protectionEffort,
			final X38SignalType signalType) {
		try {
			final com.marconi.fusion.base.application.Profile profile = AdditionalInfoManager.getManager().getProfile();
			/*
			 * Fix for TR HO93383,A1Role and Z1Role set as LCDEndPoint identifies a path.so check whether signalType is present set of
			 * SignalTypes related to Path and then set A1Role and Z1Role set as LCDEndPoint for the SNC
			 */
			final X38SetOfSignalType setOfSignalType = getSNCConverter().getPathSignalTypes();
			if (setOfSignalType.contains(signalType)) {
				if (routeInfo.isAEndLCEndPoint()) {
					profile.setProperty(AdditionalInfoManager.Standard.A1Role, "LCEndPoint");
				}

				if (routeInfo.isZEndLCEndPoint()) {
					profile.setProperty(AdditionalInfoManager.Standard.Z1Role, "LCEndPoint");
				}
			}

			if (protectionEffort != null) {
				profile.setProperty(AdditionalInfoManager.Standard.ProtectionEffort, protectionEffort.getEnum().toUpperCase());
			}

			return AdditionalInfoManager.getAdditionalInfo(DBComponent.TMFObject.SubnetworkConnection, profile);
		} catch (final Exception ex) {
			LOG.error(format(ex));
			return new AdditionalInfo();
		}
	}

	protected SubnetworkConnection toSubnetworkConnection(final PathData data, final X38SNC snc) {
		final SubnetworkConnection out = getSNCConverter().toSubnetworkConnection(sbi.getSNDn(), data, snc);
		if (userLabel != null) {
			out.setUserLabel(userLabel);
		}
		if (owner != null) {
			out.setOwner(owner);
		}
		return out;
	}

	protected IRouteProcessor getRouteProcessor() throws Exception {
		// return new RouteProcessor(sbi, name);
		// return new RouteProcessor2(sbi, name);
		final Class<IRouteProcessor> clazz = Profile.getDefault().sncRouteProcessor;
		final Constructor<IRouteProcessor> ctor = clazz.getConstructor(new Class[] { X38SBIClient.class, String.class });
		return ctor.newInstance(new Object[] { sbi, name() });
	}

	protected IRouteProcessor2 getRouteProcessor(final X38SignalType signalType) throws Exception {
		final Class<IRouteProcessor2> clazz = Profile.getDefault().sncRouteProcessor2;
		final IRouteProcessor2 instance = clazz.newInstance();
		instance.setSBI(sbi);
		return instance;
	}

	protected void setTPData(final PointDataList ptDataList, final DBIterator<DBSncConnectableTp<?, ?>> itr) {
		try {
			while (itr.hasNext()) {
				ptDataList.add(toTPData(itr.next()));
			}
		} finally {
			itr.close();
		}
	}

	protected void setPointData(final PointDataList pointDataList, final DBIterator<DBSncConnectableTp<?, ?>> itr) {
		try {
			while (itr.hasNext()) {
				pointDataList.add(toPointData(itr.next()));
			}
		} finally {
			itr.close();
		}
	}

	private PointData toPointData(final DBSncConnectableTp<?, ?> dbCtp) {
		final PointData pointData = new PointData();
		if (dbCtp instanceof DBTp) {
			final TerminationPoint ctp = ((DBTp) dbCtp).getInformation();
			final PointDn pointDn = new PointDn();
			pointDn.setTpDn(ctp.getName());
			pointData.setTpName(pointDn);
			pointData.setTpMappingMode(ctp.getTpMappingMode());
			pointData.setTransmissionParams(ctp.getTransmissionParams());
		}
		return pointData;
	}

	private PointData toTPData(final DBSncConnectableTp<?, ?> dbCtp) {
		final PointData tpData = new PointData();
		if (dbCtp instanceof DBTp) {
			final TerminationPoint ctp = ((DBTp) dbCtp).getInformation();

			tpData.getTpName().setTpDn(ctp.getName());
			tpData.setTpMappingMode(ctp.getTpMappingMode());
			tpData.setTransmissionParams(ctp.getTransmissionParams());
		}
		return tpData;
	}

	protected X38TPId getToTPId(final IRouteInfo routeInfo) throws Exception {
		if (routeInfo.getType() == RouteInfo2.Type.BROADCAST || routeInfo.getType() == RouteInfo2.Type.PROTBROAD) {
			final X38TPId out = routeInfo.getToTPId();
			if (out == null) {
				throw new Exception("Cannot get X38TPInfo for BROADCAST SNC.");
			}
			return out;
		}
		return null;
	}

	protected X38SNC getX38SNC(final IRouteInfo routeInfo) throws Exception {
		if (routeInfo.getType() == RouteInfo2.Type.BROADCAST || routeInfo.getType() == RouteInfo2.Type.PROTBROAD) {
			final X38SNC out = routeInfo.getSNC();
			if (out == null) {
				throw new Exception("Cannot get X38SNC for BROADCAST SNC.");
			}
			return out;
		}
		return null;
	}

	protected void updateType(final SubnetworkConnection snc, final RouteInfo routeInfo) {
		try {
			if (routeInfo.getSNCType() == null) {
				snc.setSncType(SNCType.ST_SIMPLE);
			} else {
				snc.setSncType(routeInfo.getSNCType());
			}
			routeInfo.dump(LOG, String.format("SNCType: '%s'", snc.getSncType().getEnum()));
		} catch (final Exception ex) {
			LOG.error(format(ex));
		}
	}

	protected void updateTPConnectionState(final DBSnc dbSnc) {
		final Collection<DBSncConnectableTp<?, ?>> connTpList = SNCUtils.getTpRoute(dbSnc);

		for (final DBSncConnectableTp<?, ?> connTp : connTpList) {
			if (connTp instanceof DBCrossConnectableTp<?, ?>) {
				TpUtils.updateConnectionState((DBCrossConnectableTp<?, ?>) connTp);
			} else {
				LOG.info("Skipping .. Update Cross Connection for..." + connTp.getDn());
			}
		}
	}

	protected void synchronize(final SNCDnList old, final PathDataList pathDataList) {
		try {
			sbi.getDatabase().beginSession(false);
			final SNCDnList list = pathDataList.getSncDnList();
			for (final SNCDn sncDn : list) {
				final DBSnc dbSnc = sbi.getDatabase().getSnc(sncDn).getDBObject();
				old.remove(dbSnc.getDn());
			}

		} catch (final Exception ex) {
			LOG.error(format(ex));
		} finally {
			sbi.getDatabase().terminateSession();
		}

		for (final SNCDn sncDn : old) {
			final Actions action = new Actions(sbi, name());
			final EMSFreedomLevel emsFreedomLevel = new EMSFreedomLevel();
			emsFreedomLevel.setEmsfl_reconfiguration();
			try {
				action.delete(sncDn, emsFreedomLevel, false);
			} catch (final Exception ex) {
				LOG.warn(ex);
				continue;
			}
		}
	}

	protected SNCDnList loadDBSnc(final X38SNId snId, final Predicate<DBSnc> predicate, final boolean isPath) {

		// Map<String, DBSnc> out = new HashMap<String, DBSnc>();
		final SNCDnList out = new SNCDnList();
		if (snId == null) {
			// get all sncs under the subnetwork.
			try {
				sbi.getDatabase().beginSession(false);
				final DBManyRelationship<DBSnc> dbSncList = sbi.getDatabase().getDBSubnetwork(sbi.getSNDn()).getSNCs();
				final DBAutoClosingItr<DBSnc> it = new DBAutoClosingItr<DBSnc>(
						new FilteringIterator<DBSnc>(dbSncList.iterator(), predicate), sbi.getDatabase().getSession());
				while (it.hasNext()) {
					final DBSnc dbSnc = it.next();
					out.add(dbSnc.getDn());
				}
			} catch (final Exception ex) {
				LOG.error(format(ex));
				return new SNCDnList();
			} finally {
				sbi.getDatabase().terminateSession();
			}
		} else {
			// get all sncs for this managed element.
			sbi.getDatabase().beginSession(false);

			final DBManagedElement me = sbi.getDatabase().getIndexes().get(snId);
			if (me == null) {
				return new SNCDnList();
			}

			try {
				/*
				 * DBAutoClosingItr<DBSnc> it = new DBAutoClosingItr<DBSnc>(DatabaseSupport .getSNCs(sbi.getPlugIn().getDatabaseManager(),
				 * meDn, predicate), sbi.getDatabase().getSession());
				 */

				final List<DBObject> dbSncList = sbi.getDatabase().getIndexes().get(me, isPath);
				if (dbSncList != null) {
					final Iterator<DBObject> it = dbSncList.iterator();

					while (it.hasNext()) {
						final DBSnc dbSnc = (DBSnc) it.next();
						// if(predicate.match(dbSnc))
						out.add(dbSnc.getDn());
					}
				}
			} catch (final Exception ex) {
				LOG.error(format(ex));
				return new SNCDnList();
			} finally {
				sbi.getDatabase().terminateSession();
			}

		}
		return out;
	}

	protected class PathKey implements Comparable<PathKey> {
		private final String name;
		private final int signalType;

		protected PathKey(final String name, final int signalType) {
			this.name = name;
			this.signalType = signalType;
		}


		@Override
		public int compareTo(final PathKey o) {
			if (this.name.equals(o.getName())) {
				return this.signalType - o.getSignalType();
			} else {
				return this.name.compareTo(o.getName());
			}
		}

		public String getName() {
			return name;
		}

		public int getSignalType() {
			return signalType;
		}

		@Override
		public String toString() {
			return String.format("%s <Name = [%s], SignalType = [%d]>", this.getClass().getSimpleName(), name, signalType);
		}
	}

	/*
	 * Experimental: do not use
	 */
	@Deprecated
	protected void getLinkConns(final List<PathData> dataList,
			final String hostName) throws Exception {
		for (final PathData data : dataList) {
			if (data.getPathInfo() == null) {
				LOG.error(format("Cannot find PathInfo for '%s'", data.getPathName()));
				continue;
			}

			data.linkConns = new HashMap<String, X38LinkConnQueryResult>();

			try {
				final X38Routing routing = data.getPathInfo().getRoutingInfo().getRouting();

				if (routing.isSimple()) {
					getLinkConns(data.linkConns, routing.getSimple(), data
							.getPathInfo().getSignalType(), hostName);
				} else if (routing.isProt()) {
					getLinkConns(data.linkConns, routing.getProt().getWorker(),
							data.getPathInfo().getSignalType(), hostName);
					getLinkConns(data.linkConns, routing.getProt()
							.getProtection(), data.getPathInfo()
							.getSignalType(), hostName);
				} else if (routing.isBroad()) {
					for (final X38SetOfRouteItem bRouting : routing.getBroad()) {
						getLinkConns(data.linkConns, bRouting, data
								.getPathInfo().getSignalType(), hostName);
					}
				} else {
					LOG.error(format("Unmanaged Routing type:", routing));
				}
			} catch (final Exception ex) {
				LOG.error(format("Cannot get Routing:", data.getPathInfo()));
				LOG.error(format(ex));
			}
		}
	}

	/*
	 * Experimental: do not use
	 */
	@Deprecated
	protected void getLinkConns(final Map<String, X38LinkConnQueryResult> linkConns, final X38SetOfRouteItem setOfRouteItem,
			final X38SignalType signalType, final String hostName)
					throws Exception {
		for (final X38RouteItem routeItem : setOfRouteItem) {

			if (routeItem.getInfo().isCurrConn()) {
				final X38LinkConnQueryResult linkConn = makeLinkConnQuery(
						routeItem.getInfo().getCurrConn().getConn(),
						signalType, hostName);
				if (linkConn == null) {
					LOG.error(format("Cannot find LinkConn;", routeItem.getInfo().getCurrConn()));
				} else {
					linkConns.put(linkConn.getLinkConnName().getValue(), linkConn);
				}
			}
		}
	}

	/*
	 * Experimental: do not use
	 */
	@Deprecated
	protected X38LinkConnQueryResult makeLinkConnQuery(
			final X38ConnInfo connInfo, final X38SignalType signalType,
			final String hostName) {
		if (realigner.getLinkConnCache() != null) {
			final String linkConnName = connInfo.getLinkConn().getLinkConnName().getValue();
			final X38LinkConnQueryResult linkConn = realigner.getLinkConnCache().get(linkConnName);
			if (linkConn != null) {
				return linkConn;
			}
			if (LOG.isDebugEnabled()) {
				LOG.debug(format("Cannot find LinkConn '%s'", linkConnName));
			}
			return null;
		}

		try {
			if (!connInfo.isPresentLinkConn()) {
				LOG.error(format("LinkConn not present:", connInfo));
				return null;
			}

			final X38LnType lnType = Profile.getDefault().getLnType(signalType);
			if (lnType == null) {
				LOG.error(format("Unmanaged SignalType:", signalType));
				return null;
			}
			final X38LinkId linkId = new X38LinkId(connInfo.getLink().getLinkId().getValue());
			final X38Pattern linkConnName = new X38Pattern(connInfo.getLinkConn().getLinkConnName().getValue());

			// TODO FM: non funziona: {linkConnName LinkPattern OPTIONAL}
			// ignorato
			final List<X38LinkConnQueryResult> linkConns = sbi
					.getMessageHandler().makeLinkConnQuery(linkId, lnType,
							linkConnName, hostName);
			for (final X38LinkConnQueryResult linkConn : linkConns) {
				if (linkConn.getLinkConnName().getValue().compareTo(linkConnName.getValue()) == 0) {
					return linkConn;
				}
			}
		} catch (final Exception ex) {
			LOG.error(format(ex));
		}

		return null;
	}

	protected void start(final String hostName) {
		if (stats != null) {
			stats.start();
			sbi.getSBI(hostName).getProfiler().addProfiler();
		}
	}

	protected void stop(final String hostName) {
		if (stats != null) {
			stats.stop();
			stats.addCommTimme(sbi.getSBI(hostName).getProfiler()
					.getTotalTime());
		}
		sbi.getSBI(hostName).getProfiler().removeProfiler();

	}

	protected void addCctCount(final int c) {
		if (stats != null) {
			stats.addCctCount(c);
		}
	}

	protected void addPathCount(final int c) {
		if (stats != null) {
			stats.addPathCount(c);
		}
	}

	protected void addCircuitGroupCount(final int c) {
		if (stats != null) {
			stats.addCircuitGroupCount(c);
		}
	}

	protected void incCount(final X38SignalType signalType) {
		if (stats != null) {
			stats.incCount(signalType);
		}
	}

	protected void incSkipped() {
		if (stats != null) {
			stats.incSkipped();
		}
	}

	protected void incErrors() {
		if (stats != null) {
			stats.incErrors();
		}
	}

	/*
	 * protected void setIndexes(SubnetworkConnection snc, DBSnc dbSnc, boolean
	 * isPath) throws Exception { Set<MEId> setOfMeId = new HashSet<MEId>();
	 * Set<DBManagedElement> setOfDBMeId = new HashSet<DBManagedElement>();
	 * List<DBObject> dbMeIdList = sbi.getDatabase().getIndexes().get(dbSnc,
	 * isPath); if(isPath){ MEId meId =
	 * snc.getAEnd().get(0).getTpName().getMe(); MEDn meDn = new MEDn();
	 * meDn.setMe(meId); DBManagedElement dbMe;
	 * 
	 * 
	 * if(meId !=null){ if(setOfMeId.add(meId)){ dbMe =
	 * sbi.getDatabase().getDBManagedElement(meDn); setOfDBMeId.add(dbMe);
	 * if((dbMeIdList != null) && (!dbMeIdList.contains(dbMe)))
	 * index(dbMe,dbSnc); } }
	 * 
	 * meId = snc.getZEnd().get(0).getTpName().getMe(); meDn.setMe(meId);
	 * 
	 * if(meId != null) { dbMe = sbi.getDatabase().getDBManagedElement(meDn);
	 * if(setOfMeId.add(meId)){ setOfDBMeId.add(dbMe); if((dbMeIdList != null)&&
	 * (!dbMeIdList.contains(dbMe))){ index(dbMe,dbSnc); } } } } CCDnList
	 * ccdnList = snc.getIntendedRoute();
	 * 
	 * Iterator<CCDn> ccdnIt = ccdnList.iterator(); while(ccdnIt.hasNext()){
	 * CCDn ccDn = ccdnIt.next();
	 * 
	 * if(setOfMeId.add(ccDn.getMe())){ MEId meId = ccDn.getMe(); MEDn meDn =
	 * new MEDn(); meDn.setMe(meId); DBManagedElement dbMe; dbMe =
	 * sbi.getDatabase().getDBManagedElement(meDn); setOfDBMeId.add(dbMe);
	 * 
	 * // List<DBObject> dbMeIdList = sbi.getDatabase().getIndexes().get(dbSnc,
	 * isPath); if((dbMeIdList != null)&&(!dbMeIdList.contains(dbMe))){
	 * index(dbMe,dbSnc); }
	 * 
	 * 
	 * } } ccdnList = snc.getBackupRoute(); ccdnIt = ccdnList.iterator();
	 * while(ccdnIt.hasNext()){ CCDn ccDn = ccdnIt.next();
	 * 
	 * if(setOfMeId.add(ccDn.getMe())){ MEId meId = ccDn.getMe(); MEDn meDn =
	 * new MEDn(); meDn.setMe(meId); DBManagedElement dbMe; dbMe =
	 * sbi.getDatabase().getDBManagedElement(meDn); setOfDBMeId.add(dbMe);
	 * 
	 * // List<DBObject> dbMeIdList = sbi.getDatabase().getIndexes().get(dbSnc,
	 * isPath); if((dbMeIdList != null)&&(!dbMeIdList.contains(dbMe))){
	 * index(dbMe,dbSnc); }
	 * 
	 * 
	 * } } //Finding the non managed indexes List<DBObject> oldDbMeList =
	 * sbi.getDatabase().getIndexes().get(dbSnc,isPath); if (oldDbMeList !=
	 * null) { // List<DBObject> oldDbMeList = dbMeIdList;
	 * Iterator<DBManagedElement> setOfDBMeIdItr = setOfDBMeId.iterator();
	 * 
	 * while (setOfDBMeIdItr.hasNext()) { DBManagedElement dbMe =
	 * setOfDBMeIdItr.next();
	 * 
	 * try {
	 * 
	 * oldDbMeList.remove(dbMe);
	 * 
	 * } catch (Exception e) { // TODO Auto-generated catch block
	 * log.error(format( "Cannot retrieve the Ne '%s'from DB reason '%s' ",
	 * dbMe.getDn().getMe().getValue(), e)); }
	 * 
	 * } // Removing the non managed indexes Iterator<DBObject> oldDbMeListItr =
	 * oldDbMeList.iterator(); while (oldDbMeListItr.hasNext()) {
	 * DBManagedElement dbMe = (DBManagedElement) oldDbMeListItr .next(); try {
	 * sbi.getDatabase().getIndexes().remove(dbMe, dbSnc, isPath);
	 * sbi.getDatabase().getIndexes().remove(dbSnc, dbMe, isPath); } catch
	 * (Exception e) { // TODO Auto-generated catch block log .error(format(
	 * "Unable to remove the dbsnc '%S' index on Ne '%s'from DB reason '%s' ",
	 * dbSnc.getDn(), dbMe.getDn().getMe() .getValue(), e)); } } }
	 * 
	 * 
	 * 
	 * /* Set<MEId> setOfMeId = new HashSet<MEId>(); Set<DBManagedElement>
	 * setOfDBMeId = new HashSet<DBManagedElement>(); List<DBObject> dbMeIdList
	 * = sbi.getDatabase().getIndexes().get(dbSnc, isPath); if (isPath) {
	 * TPDataList aEnd = snc.getAEnd(); TPDataList zEnd = snc.getZEnd(); MEId
	 * meId; MEDn meDn = new MEDn(); DBManagedElement dbMe; if (aEnd != null &&
	 * aEnd.size() != 0) { meId = aEnd.get(0).getTpName().getMe();
	 * meDn.setMe(meId); if(meId !=null){ if(setOfMeId.add(meId)){ dbMe =
	 * sbi.getDatabase().getDBManagedElement(meDn); setOfDBMeId.add(dbMe);
	 * if((dbMeIdList != null) && (!dbMeIdList.contains(dbMe)))
	 * index(dbMe,dbSnc); } } } else {
	 * log.error("aEnd is not present for snc : "+snc); return; } if (zEnd !=
	 * null && zEnd.size() != 0) { meId = zEnd.get(0).getTpName().getMe();
	 * meDn.setMe(meId);
	 * 
	 * if (meId != null) { dbMe = sbi.getDatabase().getDBManagedElement(meDn);
	 * if(setOfMeId.add(meId)){ setOfDBMeId.add(dbMe); if((dbMeIdList != null)&&
	 * (!dbMeIdList.contains(dbMe))){ index(dbMe,dbSnc); } } } } else {
	 * log.error("zEnd is not present for snc : "+snc); return; } } CCDnList
	 * ccdnList = snc.getIntendedRoute();
	 * 
	 * Iterator<CCDn> ccdnIt = ccdnList.iterator(); while(ccdnIt.hasNext()){
	 * CCDn ccDn = ccdnIt.next();
	 * 
	 * if(setOfMeId.add(ccDn.getMe())){ MEId meId = ccDn.getMe(); MEDn meDn =
	 * new MEDn(); meDn.setMe(meId); DBManagedElement dbMe; dbMe =
	 * sbi.getDatabase().getDBManagedElement(meDn); setOfDBMeId.add(dbMe);
	 * 
	 * // List<DBObject> dbMeIdList = sbi.getDatabase().getIndexes().get(dbSnc,
	 * isPath); if((dbMeIdList != null)&&(!dbMeIdList.contains(dbMe))){
	 * index(dbMe,dbSnc); }
	 * 
	 * 
	 * } } ccdnList = snc.getBackupRoute(); ccdnIt = ccdnList.iterator();
	 * while(ccdnIt.hasNext()){ CCDn ccDn = ccdnIt.next();
	 * 
	 * if(setOfMeId.add(ccDn.getMe())){ MEId meId = ccDn.getMe(); MEDn meDn =
	 * new MEDn(); meDn.setMe(meId); DBManagedElement dbMe; dbMe =
	 * sbi.getDatabase().getDBManagedElement(meDn); setOfDBMeId.add(dbMe);
	 * 
	 * // List<DBObject> dbMeIdList = sbi.getDatabase().getIndexes().get(dbSnc,
	 * isPath); if((dbMeIdList != null)&&(!dbMeIdList.contains(dbMe))){
	 * index(dbMe,dbSnc); }
	 * 
	 * 
	 * } } // Finding the non managed indexes List<DBObject> oldDbMeList =
	 * sbi.getDatabase().getIndexes().get(dbSnc, isPath); if (oldDbMeList !=
	 * null) { // List<DBObject> oldDbMeList = dbMeIdList;
	 * Iterator<DBManagedElement> setOfDBMeIdItr = setOfDBMeId.iterator();
	 * 
	 * while (setOfDBMeIdItr.hasNext()) { DBManagedElement dbMe =
	 * setOfDBMeIdItr.next(); try { oldDbMeList.remove(dbMe); } catch (Exception
	 * e) { log.error(format("Cannot retrieve the Ne '%s'from DB reason '%s' ",
	 * dbMe.getDn().getMe().getValue(), e)); }
	 * 
	 * } // Removing the non managed indexes Iterator<DBObject> oldDbMeListItr =
	 * oldDbMeList.iterator(); while (oldDbMeListItr.hasNext()) {
	 * DBManagedElement dbMe = (DBManagedElement) oldDbMeListItr.next(); try {
	 * sbi.getDatabase().getIndexes().remove(dbMe, dbSnc, isPath);
	 * sbi.getDatabase().getIndexes().remove(dbSnc, dbMe, isPath); } catch
	 * (Exception e) { // TODO Auto-generated catch block log .error(format(
	 * "Unable to remove the dbsnc '%S' index on Ne '%s'from DB reason '%s' ",
	 * dbSnc.getDn(), dbMe.getDn().getMe() .getValue(), e)); } } } }
	 */

	protected void setIndexes(final SubnetworkConnection snc, final DBSnc dbSnc, final boolean isPath) throws Exception {

		final IndexManager indexMgr = sbi.getDatabase().getIndexes();

		List<DBObject> oldDBMesIndexed = null;
		Set<MEId> oldMeSet = null;
		Map<MEId, DBManagedElement> oldMeMap = null;

		if (!firstRealignment) {

			// DBManagedElements already indexed for the SNC
			oldDBMesIndexed = indexMgr.get(dbSnc, isPath);

			oldMeSet = new HashSet<MEId>();
			oldMeMap = new HashMap<MEId, DBManagedElement>();

			// Building MEIds for faster comparison
			for (final DBObject dbObj : oldDBMesIndexed) {
				final DBManagedElement dbMe = (DBManagedElement) dbObj;
				final MEId meId = dbMe.getDn().getMe();
				oldMeSet.add(meId);
				oldMeMap.put(meId, dbMe);
			}
		}

		Set<MEId> meSet = new HashSet<MEId>();
		List<DBManagedElement> dbMeList = new ArrayList<DBManagedElement>();
		Map<MEId, DBManagedElement> meMap = new HashMap<MEId, DBManagedElement>();

		// Processing the MEs involved in the route
		processRouteDiscriptorsForIndexing(dbSnc, meSet, dbMeList, meMap);

		// Index the MEs involved in aEnd/zEnd of the path/circuit
		processTpForIndexing(snc.getAEnd(), meSet, dbMeList, meMap);
		processTpForIndexing(snc.getZEnd(), meSet, dbMeList, meMap);

		// Removing the already indexed DBManagedElements
		removeIndexingIfExists(oldMeSet, meSet, dbMeList, meMap, oldDBMesIndexed, oldMeMap);

		// Indexing the new DBManagedElements included in the route of the SNC
		for (final DBManagedElement dbME : dbMeList) {
			onIndex(dbME, dbSnc);
		}

		// Removing the old DBManagedElements indexed for the SNC, which are no
		// more included in the new route of the SNC
		if (oldDBMesIndexed != null) {
			for (final DBObject dbObj : oldDBMesIndexed) {
				final DBManagedElement dbME = (DBManagedElement) dbObj;
				indexMgr.remove(dbME, dbSnc, isPath);
				indexMgr.remove(dbSnc, dbME, isPath);
			}
		}

		oldDBMesIndexed = null;
		oldMeSet = null;
		oldMeMap = null;
		meSet = null;
		dbMeList = null;
		meMap = null;
	}

	/**
	 * Removes Indexing if exists.
	 * 
	 * @param oldMeSet
	 * @param meSet
	 * @param dbMeList
	 * @param meMap
	 * @param oldDBMesIndexed
	 * @param oldMeMap
	 */
	private void removeIndexingIfExists(final Set<MEId> oldMeSet, final Set<MEId> meSet, final List<DBManagedElement> dbMeList,
			final Map<MEId, DBManagedElement> meMap, final List<DBObject> oldDBMesIndexed, final Map<MEId, DBManagedElement> oldMeMap) {
		if (oldMeSet != null && oldMeSet.size() > 0) {
			final Iterator<MEId> newMeSetItr = meSet.iterator();
			while (newMeSetItr.hasNext()) {
				final MEId newMe = newMeSetItr.next();
				if (oldMeSet.contains(newMe)) {
					oldMeSet.remove(newMe);
					newMeSetItr.remove();
					oldDBMesIndexed.remove(oldMeMap.get(newMe));
					dbMeList.remove(meMap.get(newMe));
				}
			}
		}
	}

	/**
	 * Sets TP indexing.
	 * 
	 * @param tpList
	 * @param meSet
	 * @param dbMeList
	 * @param meMap
	 * @throws Exception
	 */
	private void processTpForIndexing(final PointDataList tpList, final Set<MEId> meSet, final List<DBManagedElement> dbMeList,
			final Map<MEId, DBManagedElement> meMap) throws Exception {
		if (tpList != null && tpList.size() > 0) {
			final MEId meId = tpList.get(0).getTpName().getTpDn().getMe();
			if (meSet.add(meId)) {
				final MEDn meDn = new MEDn();
				meDn.setMe(meId);
				final DBManagedElement dbME = sbi.getDatabase().getDBManagedElement(meDn);
				dbMeList.add(dbME);
				meMap.put(meId, dbME);
			}
		}
	}

	/**
	 * processes RouteDiscriptos
	 * 
	 * @param dbSnc
	 * @param meSet
	 * @param dbMeList
	 * @param meMap
	 */
	private void processRouteDiscriptorsForIndexing(final DBSnc dbSnc, final Set<MEId> meSet, final List<DBManagedElement> dbMeList,
			final Map<MEId, DBManagedElement> meMap) {
		DBIterator<DBRouteDescriptor> routeDescItr = null;

		try {
			routeDescItr = dbSnc.getRouteDescriptors().iterator();
			while (routeDescItr.hasNext()) {
				final DBRouteDescriptor routeDesc = routeDescItr.next();
				final DBIterator<DBCrossConnection> xConnItr = routeDesc.getCrossConnections().iterator();
				while (xConnItr.hasNext()) {
					final DBCrossConnection dbXConn = xConnItr.next();
					final DBManagedElement dbME = dbXConn.getMe().get();
					final MEId meId = dbME.getDn().getMe();
					if (meSet.add(meId)) {
						dbMeList.add(dbME);
						meMap.put(meId, dbME);
					}
				}
				xConnItr.close();
			}
		} finally {
			if (routeDescItr != null) {
				routeDescItr.close();
				routeDescItr = null;
			}
		}
	}

	/**
	 * Checks whether TP is allocated to control plane
	 * 
	 * @param routeInfo
	 * @return boolean
	 */
	private boolean isWsonResourceInvolvedInSnc(final RouteInfo2 routeInfo) {

		final List<XConnInfo2> intendedXConnInfo = routeInfo.getIntended();

		final List<DBCrossConnectableTp<?, ?>> allXConnectableTps = new ArrayList<DBCrossConnectableTp<?, ?>>();

		for (final XConnInfo2 xConInfo : intendedXConnInfo) {
			DBCrossConnectableTp<?, ?> temp = xConInfo.getAEnd1();
			if (temp != null) {
				allXConnectableTps.add(temp);
			}

			temp = xConInfo.getAEnd2();
			if (temp != null) {
				allXConnectableTps.add(temp);
			}

			temp = xConInfo.getZEnd1();
			if (temp != null) {
				allXConnectableTps.add(temp);
			}

			temp = xConInfo.getZEnd2();
			if (temp != null) {
				allXConnectableTps.add(temp);
			}

		}

		if (isWsonResource(allXConnectableTps)) {
			return true;
		}

		allXConnectableTps.clear();
		final List<XConnInfo2> backupXConnInfo = routeInfo.getBackup();
		for (final XConnInfo2 xConInfo : backupXConnInfo) {
			DBCrossConnectableTp<?, ?> temp = xConInfo.getAEnd1();
			if (temp != null) {
				allXConnectableTps.add(temp);
			}

			temp = xConInfo.getAEnd2();
			if (temp != null) {
				allXConnectableTps.add(temp);
			}

			temp = xConInfo.getZEnd1();
			if (temp != null) {
				allXConnectableTps.add(temp);
			}

			temp = xConInfo.getZEnd2();
			if (temp != null) {
				allXConnectableTps.add(temp);
			}
		}

		return isWsonResource(allXConnectableTps);

	}

	/**
	 * Checks whether TP is allocated to control plane
	 * 
	 * @param routeInfo
	 * @return boolean
	 */
	private boolean isWsonResourceInvolvedInSnc(final RouteInfo routeInfo) {

		final DBSncConnectableTp<?, ?> aEnds[] = routeInfo.getAEnds();
		final DBSncConnectableTp<?, ?> zEnds[] = routeInfo.getZEnds();

		if (aEnds == null && zEnds == null) {
			return false;
		}

		boolean isCpResource = false;

		if (aEnds != null && aEnds.length > 0) {
			isCpResource = isWsonResource(aEnds);
		}

		if (isCpResource) {
			return true;
		}

		if (zEnds != null && zEnds.length > 0) {
			isCpResource = isWsonResource(zEnds);
		}

		return isCpResource;
	}

	/**
	 * Checks for AdditionalInfo allocated to Control plane .
	 * 
	 * @param tpList
	 * @return boolean
	 */
	private boolean isWsonResource(final List<DBCrossConnectableTp<?, ?>> tpList) {

		if (tpList != null && tpList.size() > 0) {
			final Iterator<DBCrossConnectableTp<?, ?>> tpListItr = tpList.iterator();
			while (tpListItr.hasNext()) {
				final DBCrossConnectableTp<?, ?> dbXTp = tpListItr.next();
				final AdditionalInfo infos = dbXTp.getAdditionalInfo();
				final Boolean flag = AdditionalInfoUtils.findBoolean(infos, ProprietaryAdditionalInfo.AllocatedToControlPlane);
				if (flag != null && flag) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Checks for AdditionalInfo allocated to Control plane .
	 * 
	 * @param tpList
	 * @return boolean
	 */
	private boolean isWsonResource(final DBSncConnectableTp<?, ?>[] tpList) {
		for (int i = 0; i < tpList.length; i++) {
			final DBSncConnectableTp<?, ?> sncTp = tpList[i];
			final AdditionalInfo infos = sncTp.getAdditionalInfo();
			final Boolean flag = AdditionalInfoUtils.findBoolean(infos, ProprietaryAdditionalInfo.AllocatedToControlPlane);
			if (flag != null && flag) {
				return true;
			}
		}
		return false;
	}

}

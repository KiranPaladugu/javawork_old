
-- ============================
-- NRQH Warning codes
-- The following warning codes are used by the NRQH server
-- in the Res sequence. They are only present
-- when Res.ResCode == resWarning
-- 102 - queue full
-- 106 - nodes not known
-- 107 - transient object error
-- ============================

LogicType ::= ENUMERATED {
    logicalAnd(1),
    logicalOr(2)
}

-- Possible filters are:
-- d.	slot
-- e.	port
-- f.	J (e.g. AU4)
-- g.	K (e.g. TU3/VC3)
-- h.	L (e.g. TU2/VC2)
-- i.	M (e.g. VC12)

Channel ::= SEQUENCE {
    snId      SNId,
    shelfId   INTEGER,
    cardId    INTEGER  OPTIONAL,-- present if filter is d/e/f/g/h/i
    portId    INTEGER  OPTIONAL,-- present if filter is e/f/g/h/i
    channelId Timeslot OPTIONAL -- present if filter is f/g/h/i
}

SetOfChannel ::= SET OF  Channel

SelectedNodes ::= SEQUENCE {
    recurseSelectedNodes BOOLEAN,
    selectedNodes        SetOfSNId,
    logicType            LogicType OPTIONAL,
    selectedChannels     SetOfChannel OPTIONAL
}

-- ============================
-- Version
-- Returns the version of the MV38 from the
-- the basename of the $MV38 environment variable
-- ============================

GetNMVersion ::= SEQUENCE {
    reqId SmartReqIdtype
}

MsgGetNMVersion MESSAGE GetNMVersion ::= 5300
	FROM CCC
	TO NRQH

ReportGetNMVersion ::= SEQUENCE {
    reqId     SmartReqIdtype,
    result    Res,
    nmVersion GraphicString
}

-- ReportGetNMVersion Constraints
--  If for some reason the version cannot be determined nmVersion will
--  return a dot(.).

MsgReportGetNMVersion MESSAGE ReportGetNMVersion ::= 5301
	FROM NRQH
	TO CCC

-- ============================
-- EMs
-- This query only returns physical element managers. Therefore, the
-- virtual element manager used by SOO-NM to contain VSNs is not returned.
-- ============================

EMQuery ::= SEQUENCE {
}

EMQueryResult ::= SEQUENCE {
    emName EMName,
    emId   SmartResIdtype
}

SetOfEMQueryResult ::= SET OF EMQueryResult

MakeEMQuery ::= SEQUENCE {
    reqId     SmartReqIdtype,
    queriedBy EMQuery,
    limit     INTEGER
}

MsgMakeEMQuery MESSAGE MakeEMQuery ::= 5111
	FROM CCC
	TO NRQH

ReportMakeEMQuery ::= SEQUENCE {
    reqId              SmartReqIdtype,
    result             Res,
    numResults         INTEGER, -- the actual number of results found
    setOfEMQueryResult SetOfEMQueryResult -- up to the limit in the request
}

MsgReportMakeEMQuery MESSAGE ReportMakeEMQuery ::= 5211
	FROM NRQH
	TO CCC

-- ============================
-- VcgCircuitGroup
-- This query will identify a VCG (via EM ID and EMNeName and Shelf/Card/Port
-- IDs) and will expect a Circuit Group ID, Signal Type and Circuit Group
-- Name and the other end VCG (as EMId and EMNeName and shelf/card/port IDs)
-- in return. If there is no Circuit Group an empty response will be returned.
-- If there is no VCG at the other end (the Circuit Group extends beyond this
-- MV38's domain) then only a Circuit Group ID, Circuit Group Name and far end
-- EMID and EmNeName will be returned and not the shelf/card/port IDs of the VCG.
-- ============================

VcgEndPoint ::= SEQUENCE {
    emId       SmartResIdtype,
    neNameInEM NEName,
    shelfId    INTEGER OPTIONAL,
    cardId     INTEGER OPTIONAL,
    portId     INTEGER OPTIONAL
}

--  VcgEndPoint Constraints
--  shelfId, cardId and portId: must be supplied in request but may not be
--  in the report when other end VCG does not exist. You get all three fields
--  or none.

VcgCircuitGroupQuery ::= SEQUENCE {
    nearEndPoint VcgEndPoint
}

VcgCircuitGroupQueryResult ::= SEQUENCE {
    pathId      PathId,
    pathName    PathName,
    signalType  SignalType,
    farEndPoint VcgEndPoint
}

SetOfVcgCircuitGroupQueryResult ::= SET OF VcgCircuitGroupQueryResult

MakeVcgCircuitGroupQuery ::= SEQUENCE {
    reqId     SmartReqIdtype,
    queriedBy VcgCircuitGroupQuery,
    limit     INTEGER
}

MsgMakeVcgCircuitGroupQuery MESSAGE MakeVcgCircuitGroupQuery ::= 5131
	FROM CCC
	TO NRQH

ReportMakeVcgCircuitGroupQuery ::= SEQUENCE {
    reqId                           SmartReqIdtype,
    result                          Res,
    numResults                      INTEGER,--the actual number of results found
    setOfVcgCircuitGroupQueryResult SetOfVcgCircuitGroupQueryResult
    -- up to the limit in the request
}

MsgReportMakeVcgCircuitGroupQuery MESSAGE ReportMakeVcgCircuitGroupQuery ::= 5231
	FROM NRQH
	TO CCC

-- ============================
-- NeVsnList
-- This query will provide a regular expression that will be used to generate a
-- return list of all VSN/NEs where the EMNeName matches the provided regular
-- expression, returning an EM ID and EMNeName for each match. If no regular
-- expression is specified, all the VSN/NEs NE installed on the MV38 will be
-- returned. If there are no matches, an empty list will be returned.
-- ============================

NeVsnListQuery ::= SEQUENCE {
    neNameInEM NEName -- pattern
}

NeVsnListQueryResult ::= SEQUENCE {
    emId       SmartResIdtype,
    neNameInEM NEName
}

SetOfNeVsnListQueryResult ::= SET OF NeVsnListQueryResult

MakeNeVsnListQuery ::= SEQUENCE {
    reqId     SmartReqIdtype,
    queriedBy NeVsnListQuery,
    limit     INTEGER
}

MsgMakeNeVsnListQuery MESSAGE MakeNeVsnListQuery ::= 5141
	FROM CCC
	TO NRQH

ReportMakeNeVsnListQuery ::= SEQUENCE {
    reqId                     SmartReqIdtype,
    result                    Res,
    numResults                INTEGER, -- the actual number of results found
    setOfNeVsnListQueryResult SetOfNeVsnListQueryResult
    -- up to the limit in the request
}

MsgReportMakeNeVsnListQuery MESSAGE ReportMakeNeVsnListQuery ::= 5241
	FROM NRQH
	TO CCC

-- ============================
-- Circuit
-- Get a list of circuits
-- This query will provide the following four choices. (Note: VSN do have an
-- EMNeName in MV38):
-- 1.	Find circuits terminating on EMId and EMNeName
-- 2.	Find circuits terminating on EMId, EMNeName with a particular SignalType
-- 3.	Find circuits having a CircuitName regular expression
-- 4.	Find circuits terminating on EMId, EMNeName with particular SignalType
--      and CircuitName regular expression
-- ============================

CircuitQuery ::= CHOICE {
    neVsnCircuitQuery1 CircuitQuery1,
    neVsnCircuitQuery2 CircuitQuery2,
    neVsnCircuitQuery3 CircuitQuery3,
    neVsnCircuitQuery4 CircuitQuery4
}

CircuitQuery1 ::= SEQUENCE {
    emId       SmartResIdtype,
    neNameInEM NEName
}

CircuitQuery2 ::= SEQUENCE {
    emId       SmartResIdtype,
    neNameInEM NEName,
    signalType SignalType
}

CircuitQuery3 ::= SEQUENCE {
    pathName PathName  -- pattern
}

CircuitQuery4 ::= SEQUENCE {
    emId       SmartResIdtype,
    neNameInEM NEName,
    pathName   PathName, -- pattern
    signalType SignalType
}

CircuitQueryResult ::= SEQUENCE {
    pathId            PathId,
    pathName          PathName,
    signalType        SignalType,
    nearEmId          SmartResIdtype,
    nearEndNeNameInEM NEName,
    farEmId           SmartResIdtype,
    farEndNeNameInEM  NEName
}

SetOfCircuitQueryResult ::= SET OF CircuitQueryResult

MakeCircuitQuery ::= SEQUENCE {
    reqId     SmartReqIdtype,
    queriedBy CircuitQuery,
    limit     INTEGER
}

MsgMakeCircuitQuery MESSAGE MakeCircuitQuery ::= 5161
	FROM CCC
	TO NRQH

ReportMakeCircuitQuery ::= SEQUENCE {
    reqId                   SmartReqIdtype,
    result                  Res,
    numResults              INTEGER, -- the actual number of results found
    setOfCircuitQueryResult SetOfCircuitQueryResult -- up to the limit in the request
}

MsgReportMakeCircuitQuery MESSAGE ReportMakeCircuitQuery ::= 5261
	FROM NRQH
	TO CCC

-- ============================
-- Subnetwork
-- ============================

RestorePhase ::= ENUMERATED {
    noRestore(0),
    phase1   (1),
    phase2   (2),
    phase3   (3)
}

SetOfRestorePhase ::= SET OF RestorePhase

SNASTNOpStateFilter ::= ENUMERATED {
    locked   (0),--used only for NetworkElements
    enableCD (1),
    enableDD (2),
    disable  (3),
    noASTN   (4),
    phase1   (5),
    phase2   (6),
    phase3   (7)
}

SetOfSNASTNOpStateFilter ::= SET OF SNASTNOpStateFilter

SNQuery ::= SEQUENCE {
    nodeName              SNName,
    nodeType              SetOfSNType,
    layer                 SetOfLayer,
    selectedNodes         SelectedNodes            OPTIONAL,
    caseSensitiveMatching NULL                     OPTIONAL,
    astnOpStateFilters    SetOfSNASTNOpStateFilter OPTIONAL
}
-- SNQuery Constraints
-- nodeName: must include the suffix
-- nodeType: must have at least one entry
-- layer: must have at least one entry
-- selectedNodes: means the node and any nodes it contains. The
-- layer component of the node is taken as a wildcard and
-- means all layers. If present selectedNodes must have at least one entry.

ASONNodeType ::= ENUMERATED {
    indeterminate (0),
    astnCD        (1),
    astnDD        (2),
    wson          (3)
}

SNQueryResult ::= SEQUENCE {
    snId           SNId,
    name           SNName,
    parent         SNId,
    parentName     SNName,
    type           SNType,
    snCoord        SNCoord,
    mapFile        MapFile              OPTIONAL,
    managedVSN     ManagedVSNInfo       OPTIONAL,
    emName         EMName               OPTIONAL,
    emId           EMId                 OPTIONAL,
    neName         NEName               OPTIONAL,
    neId           NeId                 OPTIONAL,
    neType         SNType               OPTIONAL,
    neIdInEM       INTEGER              OPTIONAL,
    astnOpState    ASTNOperationalState OPTIONAL,
    gmplsIpAddress GraphicString        OPTIONAL,
    restorePhase   RestorePhase         OPTIONAL,
    asonType       ASONNodeType         OPTIONAL,
    snState        SNState              OPTIONAL
}

-- SNQueryResult Constraints
--  mapFile: only returned when an image has been assigned to subnetwork
--  This is only applicable for generic subnetworks.
--  managedVSN: only returned for subnetworks with SNType virtualSN. This is
--  only applicable for managed VSNs.
--  emName, emId, neName, neId, neType and neIdInEM: only returned for NEs in which case
--  all six fields will always be returned.
--  astnOpState:    only returned for ASTN NEs
--  gmplsIpAddress: only returned for ASTN DD NEs

SetOfSNQueryResult ::= SET OF SNQueryResult

MakeSNQuery ::= SEQUENCE {
    reqId     SmartReqIdtype,
    userId    AttrId,
    queriedBy SNQuery,
    limit     INTEGER
}

MsgMakeSNQuery MESSAGE MakeSNQuery ::= 5171
	FROM UI
	TO NRQH

md_MsgMakeSNQuery MessageDescriptor ::= { mdKind 2, mdReport 5271 }

ReportMakeSNQuery ::= SEQUENCE {
    reqId              SmartReqIdtype,
    result             Res,
    numResults         INTEGER, -- the actual number of results found
    setOfSNQueryResult SetOfSNQueryResult -- up to the limit in the request
}

MsgReportMakeSNQuery MESSAGE ReportMakeSNQuery ::= 5271
	FROM NRQH
	TO UI

md_MsgReportMakeSNQuery MessageDescriptor ::= { mdKind 3 }

-- ============================
-- CctQuery
-- Get a list of circuits
-- ============================

SetOfCycleLifeState ::= SET OF CycleLifeState
SetOfOperState ::= SET OF OperState

ASTNOpStateFilter ::= ENUMERATED {
    cdEnabled    (1),
    ddEnabled    (2),
    disabled     (3),
    cdOutOfOrder (4),
    notApplicable(5),
    phase1       (6),
    phase2       (7),
    phase3       (8)
}

SetOfASTNOpStateFilter ::= SET OF ASTNOpStateFilter

CctQuery ::= SEQUENCE {
    circuitName           PathPattern, -- pattern
    customerData          CustomerDataItemString, -- pattern
    signalTypes           SetOfSignalType,
    serviceStates         SetOfServiceState,
    circuitStates         SetOfCycleLifeState,
    protTypes             SetOfProtType,
    operStates            SetOfOperState,
    selectedNodes         SelectedNodes OPTIONAL,
    --astnOperationalStates SetOfASTNOperationalState OPTIONAL  OPTIONAL behaviour will be removed in future.
    astnOpStateFilters    SetOfASTNOpStateFilter,
    caseSensitiveMatching NULL OPTIONAL,
    linkCluster           GraphicString
}

-- CctQuery Constraints
-- customerData only matches the name and data fields - number field is ignored
-- signalTypes, serviceStates, circuitStates, protTypes, operStates,
-- astnOperationalStates must have at least one entry
-- selectedNodes: means the node and any nodes it contains. Any circuits
-- which terminate or pass through at least one node will be included
-- in the results. The layer component of the node is taken as a wildcard and
-- means all layers. If present selectedNodes must have at least one entry.

CctQueryResult ::= SEQUENCE {
    pathId                      PathId,
    pathName                    PathName,
    signalType                  SignalType,
    pathState                   PathState,
    pathType                    PathType,
    operState                   OperState,
    protType                    ProtType,
    serviceState                ServiceState,
    astnOpState                 ASTNOperationalState OPTIONAL,
    astnCircuitType             ASTNCircuitType      OPTIONAL,
    astnPotentialManagementType ManagementType       OPTIONAL,
    isJobPresent                BOOLEAN,
    restorePhase                RestorePhase         OPTIONAL
}

-- CctQueryResult Constraints
--  astnOpState:     only returned for ASTN Circuits; independent of astnPotentialManagementType.
--  astnCircuitType: only returned if astnOpState is enable, should not be indeterminate.

SetOfCctQueryResult ::= SET OF CctQueryResult

MakeCctQuery ::= SEQUENCE {
    reqId     SmartReqIdtype,
    userId    AttrId,
    queriedBy CctQuery,
    limit     INTEGER
}

MsgMakeCctQuery MESSAGE MakeCctQuery ::= 5181
	FROM UI
	TO NRQH

md_MsgMakeCctQuery MessageDescriptor ::= { mdKind 2, mdReport 5281 }

ReportMakeCctQuery ::= SEQUENCE {
    reqId               SmartReqIdtype,
    result              Res,
    numResults          INTEGER, -- the actual number of results found
    setOfCctQueryResult SetOfCctQueryResult -- up to the limit in the request
}

MsgReportMakeCctQuery MESSAGE ReportMakeCctQuery ::= 5281
	FROM NRQH
	TO UI

md_MsgReportMakeCctQuery MessageDescriptor ::= { mdKind 3 }

-- ==========================
-- PathQuery
-- ============================

PathQuery ::= SEQUENCE {
    pathName              PathPattern, -- pattern
    customerData          CustomerDataItemString, -- pattern
    signalTypes           SetOfSignalType,
    serviceStates         SetOfServiceState,
    pathStates            SetOfCycleLifeState,
    protTypes             SetOfProtType,
    operStates            SetOfOperState,
    selectedNodes         SelectedNodes OPTIONAL,
    caseSensitiveMatching NULL OPTIONAL,
    clientPath            Paths OPTIONAL
}

-- PathQuery Constraints
-- customerData only matches the name and data fields - number field is ignored
-- signalTypes, serviceStates, pathStates, protTypes, operStates
-- must have at least one entry
-- selectedNodes: means the node and any nodes it contains. Any paths
-- which terminate or pass through at least one node will be included
-- in the results. The layer component of the node is taken as a wildcard and
-- means all layers. If present selectedNodes must have at least one entry.

PathQueryResult ::= SEQUENCE {
    pathId          PathId,
    pathName        PathName,
    signalType      SignalType,
    pathState       PathState,
    pathType        PathType,
    operState       OperState,
    protType        ProtType,
    serviceState    ServiceState,
    clntTrafficType ClientTrType,
    isJobPresent    BOOLEAN
}

SetOfPathQueryResult ::= SET OF PathQueryResult

MakePathQuery ::= SEQUENCE {
    reqId     SmartReqIdtype,
    userId    AttrId,
    queriedBy PathQuery,
    limit     INTEGER
}

MsgMakePathQuery MESSAGE MakePathQuery ::= 5191
	FROM UI
	TO NRQH

md_MsgMakePathQuery MessageDescriptor ::= { mdKind 2, mdReport 5291 }

ReportMakePathQuery ::= SEQUENCE {
    reqId                SmartReqIdtype,
    result               Res,
    numResults           INTEGER, -- the actual number of results found
    setOfPathQueryResult SetOfPathQueryResult -- up to the limit in the request
}

MsgReportMakePathQuery MESSAGE ReportMakePathQuery ::= 5291
	FROM NRQH
	TO UI

md_MsgReportMakePathQuery MessageDescriptor ::= { mdKind 3 }

-- ==========================
-- CircuitGroupQuery
-- ============================
SetOfLCASOpState ::= SET OF LCASOpState

SetOfDirectionality ::= SET OF Directionality

CircuitGroupQuery ::= SEQUENCE {
	circGroupName         PathPattern, -- pattern
	customerData          CustomerDataItemString, -- pattern
	signalTypes           SetOfSignalType,
	lcasOpStates          SetOfLCASOpState,
	selectedNodes         SelectedNodes        OPTIONAL,
	caseSensitiveMatching NULL                 OPTIONAL,
	directionalities      SetOfDirectionality,
	pendingZEnds          NULL                 OPTIONAL
}

-- CircuitGroupQuery Constraints
-- customerData only matches the name and data fields - number field is ignored
-- signalTypes and lcasOpStates must have at least one entry
-- selectedNodes: means the node and any nodes it contains. Any paths
-- which terminate or pass through at least one node will be included
-- in the results. The layer component of the node is taken as a wildcard and
-- means all layers. If present selectedNodes must have at least one entry.

CircuitGroupQueryResult ::= SEQUENCE {
	groupId        PathId,
	groupName      PathName,
	signalType     SignalType,
	lcasOpState    LCASOpState,
	directionality Directionality,
	pendingZEnds   NULL             OPTIONAL
}

SetOfCircuitGroupQueryResult ::= SET OF CircuitGroupQueryResult

MakeCircuitGroupQuery ::= SEQUENCE {
	reqId     SmartReqIdtype,
	userId    AttrId,
	queriedBy CircuitGroupQuery,
	limit     INTEGER
}

MsgMakeCircuitGroupQuery MESSAGE MakeCircuitGroupQuery ::= 5121
	FROM UI
	TO NRQH

md_MsgMakeCircuitGroupQuery MessageDescriptor ::= { mdKind 2, mdReport 5221 }

ReportMakeCircuitGroupQuery ::= SEQUENCE {
	reqId                        SmartReqIdtype,
	result                       Res,
	numResults                   INTEGER, -- the actual number of results found
	setOfCircuitGroupQueryResult SetOfCircuitGroupQueryResult -- up to the limit in the request
}

MsgReportMakeCircuitGroupQuery MESSAGE ReportMakeCircuitGroupQuery ::= 5221
	FROM NRQH
	TO UI

md_MsgReportMakeCircuitGroupQuery MessageDescriptor ::= { mdKind 3 }

-- ==========================
-- LinkQuery
-- ============================

LinkFilter ::= ENUMERATED {
       all           (0), -- all links shall be reported (internal, external, locked, unlocked and so on)
       notLockedOnly (1)  -- ONLY not locked links shall be reported
}

SetOfLnType ::= SET OF LnType

-- LS Provisioning Enhancement:
MultipleCreation  ::= SEQUENCE {
    numOfCapacityRequest  INTEGER,
    signalType            SignalType,
    directionality        Directionality,
    preemptFlag           PreemptFlag
}

LinkQuery ::= SEQUENCE {
    linkName              LinkPattern, -- pattern
    customerData          CustomerDataItemString, -- pattern
    layer                 Layer,
    operStates            SetOfOperState,
    selectedNodes         SelectedNodes   OPTIONAL,
    -- new fields for Add Circuit wizard
    weight                NULL            OPTIONAL,
    colour                NULL            OPTIONAL,
    setOfSRG              NULL            OPTIONAL,
    caseSensitiveMatching NULL            OPTIONAL,
    circuitName           PathPattern     OPTIONAL,
    filter                LinkFilter      OPTIONAL, -- Not present means that the locked links shall NOT reported
    multipleCreation      MultipleCreation  OPTIONAL  -- LS Provisioning Enhancement
}

-- LinkQuery Constraints
-- customerData only matches the name and data fields - number field is ignored
-- customerData only applies to the Phyiscal layer - it is gnored if other layers
-- are requested.
-- operStates must have at least one entry
-- selectedNodes: means the node and any nodes it contains. Any links
-- which terminate on at least one node will be included
-- in the results. The layer component of the node is taken as a wildcard and
-- means all layers. If present selectedNodes must have at least one entry.

LinkQueryResult ::= SEQUENCE {
    linkId     LinkId,
    linkName   LinkName,
    lnType     LnType,
    linkType   LinkType,
    operState  OperState,
    sNNameFrom SNName,
    fromSnId   SNId,
    sNNameTo   SNName,
    toSnId     SNId,
    -- new fields for Add Circuit wizard
    weight     Weight   OPTIONAL,
    colour     Colour   OPTIONAL,
    setOfSRG   SetOfSRG OPTIONAL,
    aEndPortCoord PortCoord OPTIONAL,
    zEndPortCoord PortCoord  OPTIONAL,
    isLocked   NULL OPTIONAL -- NOT PRESENT means that the link is not locked
}

SetOfLinkQueryResult ::= SET OF LinkQueryResult

MakeLinkQuery ::= SEQUENCE {
    reqId     SmartReqIdtype,
    userId    AttrId,
    queriedBy LinkQuery,
    limit     INTEGER
}

MsgMakeLinkQuery MESSAGE MakeLinkQuery ::= 5151
	FROM UI
	TO NRQH

md_MsgMakeLinkQuery MessageDescriptor ::= { mdKind 2, mdReport 5251 }

ReportMakeLinkQuery ::= SEQUENCE {
    reqId SmartReqIdtype,
    result Res,
    numResults INTEGER, -- the actual number of results found
    setOfLinkQueryResult SetOfLinkQueryResult -- up to the limit in the request
}

MsgReportMakeLinkQuery MESSAGE ReportMakeLinkQuery ::= 5251
	FROM NRQH
	TO UI

md_MsgReportMakeLinkQuery MessageDescriptor ::= { mdKind 3 }

-- new messages for Add Circuit wizard
LinkConnQuery::= SEQUENCE {
	linkId             LinkId,
	lnType             LnType,
	linkConnName       LinkPattern         OPTIONAL,
	signalType         SignalType          OPTIONAL,
	assignInfo         LCAssignInfo        OPTIONAL,
	startTime          SchedTime           OPTIONAL,
	endTime            SchedTime           OPTIONAL,
	preemptFlag        PreemptFlag         OPTIONAL,
	pathId             PathId              OPTIONAL,
    constraint         LCConstraint        OPTIONAL --LP Sprint5 TRUS03M1A
}

MakeLinkConnQuery ::= SEQUENCE {
    reqId     SmartReqIdtype,
    userId    AttrId,
    queriedBy LinkConnQuery
}

TTPIdInfo ::= SEQUENCE {
    tpId   TTPId,
    tpName TPName
}

EndTP ::= SEQUENCE {
    endTP            TTPIdInfo,
    endPoint         AccessPoint,
    connectedToEndTP TTPIdInfo    OPTIONAL,
    endCTT           ClientTrType OPTIONAL
}

ReportMakeLinkConnQuery ::= SEQUENCE {
    reqId                    SmartReqIdtype,
    result                   Res,
    numResults               INTEGER,
    setOfLinkConnQueryResult SetOfLinkConnQueryResult
}

SetOfLinkConnQueryResult ::= SET OF LinkConnQueryResult

LinkConnQueryResult::= SEQUENCE {
    linkConnId   LinkConnRelId,
    linkConnName LinkConnName,
    aEndTP       EndTP,
    zEndTP       EndTP,
    freq         Wavelengths OPTIONAL,
    bshrType     BSHRType    OPTIONAL
}

MsgMakeLinkConnQuery MESSAGE MakeLinkConnQuery ::= 5152
	FROM UI
	TO NRQH

md_MsgMakeLinkConnQuery MessageDescriptor ::= { mdKind 2, mdReport 5252 }

MsgReportMakeLinkConnQuery MESSAGE ReportMakeLinkConnQuery ::= 5252
	FROM NRQH
	TO UI

md_MsgReportMakeLinkConnQuery MessageDescriptor ::= { mdKind 3 }

-- ************************************
-- PEZZO NUOVO

LSRQuery ::= SEQUENCE {
	labelSwitchedRouterName LSRElement,
	nodeType                SetOfSNType,
	selectedNodes           SelectedNodes  OPTIONAL,
	routerId                GenericAddress,
	routingAreaId           GenericAddress,
	onlyRouterController    NULL                OPTIONAL,
	caseSensitiveMatching   NULL                OPTIONAL,
	restorePhases           SetOfRestorePhase   OPTIONAL,
        setOfConfigurable       SetOfConfigurableOnCP,
        setOfConfigured         SetOfConfiguredOnCP
}

MakeLSRQuery ::= SEQUENCE {
	reqId     SmartReqIdtype,
	userId    AttrId,
	queriedBy LSRQuery,
	limit     INTEGER,
	dummy     NULL   OPTIONAL
}

MsgMakeLSRQuery MESSAGE MakeLSRQuery ::= 5153
	FROM	UI
	TO	NRQH

md_MsgMakeLSRQuery MessageDescriptor ::= { mdKind 2, mdReport 5253 }

LSRQueryResult ::= SEQUENCE {
	labelSwitchedRouterId   LSRId,
	labelSwitchedRouterName LSRElement,
	nodeType                SNType,
	routerControllerId      GenericAddress OPTIONAL,
	restorePhase            RestorePhase,
        configurable            ConfigurableOnCP,
        configured              ConfiguredOnCP,
        managedSignalTypes	SetOfSignalType
}

SetOfLSRQueryResult ::= SET OF LSRQueryResult

ReportMakeLSRQuery ::= SEQUENCE {
	reqId               SmartReqIdtype,
	result              Res,
	numResults          INTEGER,     -- the actual number of results found
	setOfLSRQueryResult SetOfLSRQueryResult, -- up to the limit in the request,
	dummy               NULL   OPTIONAL
}

MsgReportMakeLSRQuery MESSAGE ReportMakeLSRQuery ::= 5253
	FROM	NRQH
	TO	UI

md_MsgReportMakeLSRQuery MessageDescriptor ::= { mdKind 3 }

-- LCQT
LinkComponentQuery ::= SEQUENCE {
	linkComponentName       GraphicString,
	setOfLcOperState        SetOfLCOperState,
	setOfAllocated          SetOfAllocated,
	setOfForcedUp           SetOfForcedUp,
	selectedNodes           SelectedNodes  OPTIONAL,
	linkClusterAssociated   GraphicString,
	edge                    NULL           OPTIONAL,
	caseSensitiveMatching   NULL           OPTIONAL,
	lkInterface             GenericAddress OPTIONAL,
        setOfConfigurable       SetOfConfigurableOnCP,
        setOfConfigured         SetOfConfiguredOnCP,
        setOfEdgeType           SetOfEdgeType  OPTIONAL,
        setOfRestorePhase       SetOfRestorePhase
}

MakeLinkComponentQuery ::= SEQUENCE {
	reqId     SmartReqIdtype,
	userId    AttrId,
	queriedBy LinkComponentQuery,
	limit     INTEGER,
	dummy     NULL   OPTIONAL
}

MsgMakeLinkComponentQuery MESSAGE MakeLinkComponentQuery ::= 5154
	FROM	UI
	TO	NRQH

md_MsgMakeLinkComponentQuery MessageDescriptor ::= { mdKind 2, mdReport 5254 }

LCId ::= SEQUENCE {
	lsrId     LSRId,
	portCoord PortCoord
}

LinkComponentQueryResult ::= SEQUENCE {
	lcId                  LCId,
	lcName                GraphicString,
	lcOperationalState    LCOperState,
	allocated             Allocated,
	forcedUp              ForcedUp,
	linkClusterAssociated GraphicString,
	dummy                 NULL           OPTIONAL,
        configurable          ConfigurableOnCP,
        configured            ConfiguredOnCP,
        edgeType              EdgeType,
        restorePhase          RestorePhase,
        managedSignalTypes    SetOfSignalType
}

SetOfLinkComponentQueryResult ::= SET OF LinkComponentQueryResult

ReportMakeLinkComponentQuery ::= SEQUENCE {
	reqId                         SmartReqIdtype,
	result                        Res,
	numResults                    INTEGER,
	setOfLinkComponentQueryResult SetOfLinkComponentQueryResult,
	dummy                         NULL   OPTIONAL
}

MsgReportMakeLinkComponentQuery MESSAGE ReportMakeLinkComponentQuery ::= 5254
	FROM	NRQH
	TO	UI

md_MsgReportMakeLinkComponentQuery MessageDescriptor ::= { mdKind 3 }

-- LKQT

LMPOperState ::= ENUMERATED {
	up        (0),
	down      (1),
	testing   (2),
	init      (3),
	degraded  (4),
	undefined (5)
}

SetOfLMPOperState ::= SET OF LMPOperState

LkAdminState ::= ENUMERATED {
	up        (0),
	down      (1),
    	undefined (2)
}

SetOfLkAdminState ::= SET OF LkAdminState

EdgeType ::= ENUMERATED {
	enni    (0),
	e2_enni (1),
	trib    (2),
	na      (3),
	uni     (4)
}

SetOfEdgeType ::= SET OF EdgeType

LinkClusterQuery ::= SEQUENCE {
	linkClusterName           GraphicString,
	setOfLmpOperState         SetOfLMPOperState,
	setOfLkAdminState         SetOfLkAdminState,
	setOfEdgeType             SetOfEdgeType       OPTIONAL,
	selectedNodes             SelectedNodes       OPTIONAL,
	controlChannelName        GraphicString,
	caseSensitiveMatching     NULL                OPTIONAL,
        setOfConfigurable         SetOfConfigurableOnCP,
        setOfConfigured           SetOfConfiguredOnCP,
        adjacencyName             GraphicString,
        setOfRestorePhase         SetOfRestorePhase
}

MakeLinkClusterQuery ::= SEQUENCE {
	reqId     SmartReqIdtype,
	userId    AttrId,
	queriedBy LinkClusterQuery,
	limit     INTEGER,
	dummy     NULL   OPTIONAL
}

MsgMakeLinkClusterQuery MESSAGE MakeLinkClusterQuery ::= 5156
	FROM	UI
	TO	NRQH

md_MsgMakeLinkClusterQuery MessageDescriptor ::= { mdKind 2, mdReport 5256 }

LinkClusterQueryResult ::= SEQUENCE {
	lkId            LKId,
	linkClusterName GraphicString,
	lmpOperState    LMPOperState,
	lkAdminState    LkAdminState,
	edgeType        EdgeType,
        configurable    ConfigurableOnCP,
        configured      ConfiguredOnCP,
        restorePhase    RestorePhase,
        managedSignalTypes SetOfSignalType,
        ospfLkAdminState  LkAdminState
}

SetOfLinkClusterQueryResult ::= SET OF LinkClusterQueryResult

ReportMakeLinkClusterQuery ::= SEQUENCE {
	reqId                       SmartReqIdtype,
	result                      Res,
	numResults                  INTEGER, -- the actual number of results found
	setOfLinkClusterQueryResult SetOfLinkClusterQueryResult, -- up to the limit in the request,
	dummy                       NULL   OPTIONAL
}

MsgReportMakeLinkClusterQuery MESSAGE ReportMakeLinkClusterQuery ::= 5256
	FROM	NRQH
	TO	UI

md_MsgReportMakeLinkClusterQuery MessageDescriptor ::= { mdKind 3 }

GetControlChannelList ::= SEQUENCE {
	reqId  SmartReqIdtype,
	userId AttrId,
	lkKey  LKKey,
	dummy  NULL   OPTIONAL
}

MsgGetControlChannelList MESSAGE GetControlChannelList ::= 5157
	FROM	UI
	TO	CPM

md_MsgGetControlChannelList MessageDescriptor ::= { mdKind 2, mdReport 5257 }

ReportGetControlChannelList ::= SEQUENCE {
	reqId                          SmartReqIdtype,
	result                         Res,
	setOfControlChannelQueryResult SetOfControlChannelQueryResult,
	controlChannelQuery            ControlChannelQuery
}

MsgReportGetControlChannelList MESSAGE ReportGetControlChannelList ::= 5257
	FROM	CPM
	TO	UI

md_MsgReportGetControlChannelList MessageDescriptor ::= { mdKind 3 }

GetLinkComponentList ::= SEQUENCE {
	reqId  SmartReqIdtype,
	userId AttrId,
	lkKey  LKKey,
	dummy  NULL OPTIONAL
}

MsgGetLinkComponentList MESSAGE GetLinkComponentList ::= 5158
	FROM	UI
	TO	CPM

md_MsgGetLinkComponentList MessageDescriptor ::= { mdKind 2, mdReport 5258 }

ReportGetLinkComponentList ::= SEQUENCE {
	reqId                         SmartReqIdtype,
	result                        Res,
	setOfLinkComponentQueryResult SetOfLinkComponentQueryResult,
	linkComponentQuery            LinkComponentQuery,
	dummy                         NULL   OPTIONAL
}

MsgReportGetLinkComponentList MESSAGE ReportGetLinkComponentList ::= 5258
	FROM	CPM
	TO	UI

md_MsgReportGetLinkComponentList MessageDescriptor ::= { mdKind 3 }

--GetCircuitList ::= SEQUENCE {
--	reqId         SmartReqIdtype,
--	userId        AttrId,
--	linkClusterId LKId,
--	dummy         NULL   OPTIONAL
--}
--
--MsgGetCircuitList MESSAGE GetCircuitList ::= 5159
--	FROM	UI
--	TO	CPM
--
--md_MsgGetCircuitList MessageDescriptor ::= { mdKind 2, mdReport 5259 }
--
--ReportGetCircuitList ::= SEQUENCE {
--	reqId                    SmartReqIdtype,
--	result                   Res,
--	setOfCircuitQueryResult SetOfCircuitQueryResult,
--	dummy                    NULL   OPTIONAL
--}
--
--MsgReportGetCircuitList MESSAGE ReportGeCircuitList ::= 5259
--	FROM	 CPM
--	TO	 UI
--
--md_MsgReportGetCircuitList MessageDescriptor ::= { mdKind 3 }
--
MakeControlChannelQuery ::= SEQUENCE {
	reqId     SmartReqIdtype,
	userId    AttrId,
	queriedBy ControlChannelQuery,
	limit     INTEGER,
	dummy     NULL   OPTIONAL
}

MsgMakeControlChannelQuery MESSAGE MakeControlChannelQuery ::= 5160
	FROM	UI
	TO	NRQH

md_MsgMakeControlChannelQuery MessageDescriptor ::= { mdKind 2, mdReport 5260 }

ControlChannelQuery ::= SEQUENCE {
	controlChannelName    GraphicString,
	linkClusterName       GraphicString,
	setOfCCType           SetOfCCType,
	setOfCCOperState      SetOfCCOperState,
	setOfforcedUp         SetOfForcedUp,
	selectedNodes         SelectedNodes  OPTIONAL,
	caseSensitiveMatching NULL           OPTIONAL,
        setOfConfigurable     SetOfConfigurableOnCP,
        setOfConfigured       SetOfConfiguredOnCP,
        adjacencyName         GraphicString,
        setOfRestorePhase     SetOfRestorePhase
}

CCId ::= SEQUENCE {
	routingArea GenericAddress,
	ccNum       INTEGER
}

ControlChannelQueryResult ::= SEQUENCE {
	ccId        CCId,
	ccName      GraphicString,
	ccOperState CCOperState,
	ccType      CCType,
	forcedUp    ForcedUp,
        configurable ConfigurableOnCP,
        configured   ConfiguredOnCP,
        restorePhase RestorePhase,
	managedSignalTypes SetOfSignalType
}

SetOfControlChannelQueryResult ::= SET OF ControlChannelQueryResult

ReportMakeControlChannelQuery ::= SEQUENCE {
	reqId                          SmartReqIdtype,
	result                         Res,
	numResults                     INTEGER, -- the actual number of results found
	setOfControlChannelQueryResult SetOfControlChannelQueryResult,  -- up to the limit in ,
	dummy                          NULL   OPTIONAL
	-- the request
}

MsgReportMakeControlChannelQuery MESSAGE ReportMakeControlChannelQuery ::= 5260
	FROM	NRQH
	TO	UI

md_MsgReportMakeControlChannelQuery MessageDescriptor ::= { mdKind 3 }

-- *****************  End Topology Browsing ****************************

-- *****************  Init Full ERO Management *************************

LCLabelsQuery::= SEQUENCE {
	linkComponentName     GraphicString,
	lcId                  LCId          OPTIONAL,
	caseSensitiveMatching NULL          OPTIONAL
}

MakeLCLabelsQuery ::= SEQUENCE {
	reqId     SmartReqIdtype,
	userId    AttrId,
	queriedBy LCLabelsQuery,
	limit     INTEGER,
	dummy     NULL          OPTIONAL
}

MsgMakeLCLabelsQuery MESSAGE MakeLCLabelsQuery::= 5401
	FROM	UI
	TO	NRQH

md_MsgMakeLCLabelsQuery MessageDescriptor ::= { mdKind 2, mdReport 5402 }

LCLabelsQueryResult ::= SEQUENCE {
	timeslot       Timeslot,
	otherTimeslot  Timeslot,
	labelName      GraphicString,
	dummy          NULL          OPTIONAL
}

SetOfLCLabelsQueryResult ::= SET OF LCLabelsQueryResult

ReportMakeLCLabelsQuery ::= SEQUENCE {
	reqId                    SmartReqIdtype,
	result                   Res,
	numResults               INTEGER,
	lcId                     LCId,
	setOfLCLabelsQueryResult SetOfLCLabelsQueryResult,
	dummy                    NULL                     OPTIONAL
}

MsgReportMakeLCLabelsQuery MESSAGE ReportMakeLCLabelsQuery ::= 5402
	FROM	NRQH
	TO	UI

md_MsgReportMakeLCLabelsQuery MessageDescriptor ::= { mdKind 3 }

-- *****************  End Full ERO Management *************************


-- *****************  Export ETN Circuit *************************

-- ============================
-- EndPoint
-- This query will identify a End Point (via EM ID and EMNeName and
-- Shelf/Card/Port IDs) and will expect a Path ID, Signal Type and Path
-- Name and the other End Point (as EMId and EMNeName and shelf/card/port IDs)
-- in return. If there is no End Point an empty response will be returned.
-- If there is no End Point at the other end (the Path extends beyond this
-- MV38's domain) then only a Path ID, Path Name and far end
-- EMID and EmNeName will be returned and not the shelf/card/port IDs of the
-- End Point.
-- The network resources returned will be of the following signalTypes:
-- au4vc4_ncv, tu12vc12_ncv, tu2vc2_ncv, tu3vc3_ncv for pathGroup
-- och for optical path
-- odu1, odu2,odu3 for ODU paths
-- in the future release this message could be used to retrieve network
-- resources of any kind
-- ============================

EndPoint ::= SEQUENCE {
	emId       SmartResIdtype,
	neNameInEM NEName,
	shelfId    INTEGER OPTIONAL,
	cardId     INTEGER OPTIONAL,
	portId     INTEGER OPTIONAL
}

-- EndPoint Constraints
-- shelfId, cardId and portId: must be supplied in request but may not be
-- in the report when other end End Point does not exist.
-- You get all three fields or none.

EndPointPathQuery ::= SEQUENCE {
	nearEndPoint EndPoint
}

EndPointPathQueryResult ::= SEQUENCE {
	pathId      PathId,
	pathName    PathName,
	signalType  SignalType,
	farEndPoint EndPoint
}

SetOfEndPointPathQueryResult ::= SET OF EndPointPathQueryResult

MakeEndPointPathQuery ::= SEQUENCE {
	reqId     SmartReqIdtype,
	queriedBy EndPointPathQuery,
	limit     INTEGER
}

MsgMakeEndPointPathQuery MESSAGE MakeEndPointPathQuery ::= 5132
	FROM CCC
	TO NRQH

md_MsgMakeEndPointPathQuery MessageDescriptor ::= { mdKind 2, mdReport 5232 }

ReportMakeEndPointPathQuery ::= SEQUENCE {
	reqId                        SmartReqIdtype,
	result                       Res,
	numResults                   INTEGER, -- the actual number of results found
	setOfEndPointPathQueryResult SetOfEndPointPathQueryResult
	-- up to the limit in the request
}

MsgReportMakeEndPointPathQuery MESSAGE ReportMakeEndPointPathQuery ::= 5232
	FROM NRQH
	TO CCC

md_MsgReportMakeEndPointPathQuery MessageDescriptor ::= { mdKind 3 }

-- *****************  Export ETN Circuit *************************

-- *****************  OTE - UDC Management ***********************

LegQuery ::= SEQUENCE {
	circuitName           PathPattern            OPTIONAL,-- pattern
	customerData          CustomerDataItemString OPTIONAL,-- pattern
	signalTypes           SetOfSignalType,
	circuitStates         SetOfCycleLifeState    OPTIONAL,
	protTypes             SetOfProtType          OPTIONAL,
	selectedNodes         SelectedNodes          OPTIONAL,
	caseSensitiveMatching NULL                   OPTIONAL,
	pathId                PathId                 OPTIONAL
}

MakeLegQuery ::= SEQUENCE {
	reqId     SmartReqIdtype,
	userId    AttrId,
	queriedBy LegQuery,
	limit     INTEGER
}

LegId ::= CHOICE {
	ttp TTPId,
	ctp CTPId
}

LegQueryResult ::= SEQUENCE {
	pathId       PathId,
	pathname     PathName,
	aEndTpname   TPName,
	tpname       TPName,
	legId        TPId,
	signalType   SignalType,
	pathState    PathState,
	pathType     PathType,
	protType     ProtType,
	isJobPresent BOOLEAN
}

SetOfLegQueryResult ::= SET OF LegQueryResult

ReportMakeLegQuery ::= SEQUENCE {
	reqId               SmartReqIdtype,
	result              Res,
	numResults          INTEGER, -- the actual number of results found
	setOfLegQueryResult SetOfLegQueryResult -- up to the limit in the request
}

MsgMakeLegQuery MESSAGE MakeLegQuery ::= 5133
	FROM UI
	TO NRQH

md_MsgMakeLegQuery MessageDescriptor ::= { mdKind 2, mdReport 5233 }

MsgReportMakeLegQuery MESSAGE ReportMakeLegQuery ::= 5233
	FROM NRQH
	TO UI

md_MsgReportMakeLegQuery MessageDescriptor ::= { mdKind 3 }

-- *****************  WSON *****************************************
-- *****************  MakeAdjacencyQuery  **************************
ADJId ::= SEQUENCE {
      routingArea GenericAddress,
      routerIdA   GenericAddress,
      routerIdZ   GenericAddress,
      dummy       NULL OPTIONAL
}

ConfiguredOnCP ::= ENUMERATED {
            notConfigured       (0),
            configured          (1),
            partiallyConfigured (2),
            misaligned          (3)
}

SetOfConfiguredOnCP ::= SET OF ConfiguredOnCP

ConfigurableOnCP ::= ENUMERATED {
        notConfigurable (0),
        configurable    (1)
}

SetOfConfigurableOnCP ::= SET OF ConfigurableOnCP

MsgMakeAdjacencyQuery MESSAGE MakeAdjacencyQuery ::= 5134
        FROM UI
        TO NRQH

md_MsgMakeAdjacencyQuery MessageDescriptor ::= { mdKind 2, mdReport 5234 }

MsgReportMakeAdjacencyQuery MESSAGE ReportMakeAdjacencyQuery ::= 5234
        FROM NRQH
        TO UI

md_MsgReportMakeAdjacencyQuery MessageDescriptor ::= { mdKind 3 }

MakeAdjacencyQuery ::= SEQUENCE {
            reqId     SmartReqIdtype,
            userId    AttrId,
            queriedBy AdjacencyQuery,
            limit     INTEGER,
	    dummy     NULL OPTIONAL
}

ReportMakeAdjacencyQuery ::= SEQUENCE {
            reqId               SmartReqIdtype,
            result              Res,
            numResults          INTEGER, -- the actual number of results found
            setOfAdjQueryResult SetOfAdjacencyQueryResult, -- up to the limit in the request
	    dummy               NULL OPTIONAL
}

AdjacencyQuery ::= SEQUENCE {
        adjacencyName         GraphicString,
        setOfEdgeType         SetOfEdgeType,
        setOfLmpOperState     SetOfLMPOperState,
        selectedNodes         SelectedNodes OPTIONAL,
        setOfConfigurable     SetOfConfigurableOnCP,
        setOfConfigured       SetOfConfiguredOnCP,
        setOfRestorePhase     SetOfRestorePhase,
        caseSensitiveMatching NULL OPTIONAL
}

AdjacencyQueryResult ::= SEQUENCE {
        adjId         ADJId,
        adjacencyName GraphicString,
        edgeType      EdgeType,
        lmpOperState  LMPOperState,
        configurable  ConfigurableOnCP,
        configured    ConfiguredOnCP,
        restorePhase  RestorePhase,
	dummy         NULL OPTIONAL
}

SetOfAdjacencyQueryResult ::= SET OF AdjacencyQueryResult

-- *****************  end MakeAdjacencyQuery  **************************
-- *****************  CombinedPathQuery ********************************
SetOfASTNTcOperStatus ::= SET OF ASTNTcOperStatus

Status::= ENUMERATED {
    no    (0),
    yes   (1)
}

SetOfStatus ::= SET OF Status

CombinedPathQuery::= SEQUENCE {
	pathName		PathPattern,
	pathStates		SetOfCycleLifeState,
	protectionTypes		SetOfProtType,
	wsonOperStates		SetOfOperState,
        tcOperationalStates     SetOfASTNTcOperStatus,
	selectedNodes		SelectedNodes OPTIONAL,
	caseSensitiveMatching	NULL OPTIONAL,
        linkCluster             GraphicString,
	setOfRestorePhase       SetOfRestorePhase,
	mustBePreemptiveStates  SetOfStatus,
        waitingForPreemptionStates SetOfStatus
}

MsgMakeCombinedPathQuery MESSAGE MakeCombinedPathQuery ::= 5135
	FROM UI
	TO NRQH

md_MsgMakeCombinedPathQuery MessageDescriptor ::= { mdKind 2, mdReport 5235 }

MakeCombinedPathQuery ::= SEQUENCE {
	reqId	  SmartReqIdtype,
	userId	  AttrId,
	queriedBy CombinedPathQuery,
	limit	  INTEGER,
	dummy     NULL OPTIONAL
}

CombinedPathType ::= ENUMERATED {
            wsonPath (0)
}

CombinedPathQueryResult ::= SEQUENCE {
	pathId		   PathId,
	pathName	   PathName,
	pathState	   CycleLifeState,
	protectionType	   ProtType,
	pathType	   PathType,
	wsonOperState	   OperState,
        tcOperState 	   ASTNTcOperStatus,
        combinedPathType   CombinedPathType,
        signalType         SignalType,
	restorePhase       RestorePhase,
	mustBePreemptive   Status,
        waitingForPreemption Status,
	dummy              NULL OPTIONAL
}

SetOfCombinedPathQueryResult ::= SET OF CombinedPathQueryResult

MsgReportMakeCombinedPathQuery MESSAGE ReportMakeCombinedPathQuery ::= 5235
	FROM NRQH
	TO UI

md_MsgReportMakeCombinedPathQuery MessageDescriptor ::= { mdKind 3 }

ReportMakeCombinedPathQuery ::= SEQUENCE {
	reqId			     SmartReqIdtype,
	result			     Res,
	numResults		     INTEGER,
	setOfCombinedPathQueryResult SetOfCombinedPathQueryResult,
	dummy                        NULL OPTIONAL
}

-- *****************  end CombinedPathQuery********************************
-- *****************   PortQuery  *****************************************
ConnectionStatus ::= ENUMERATED {
	connected (0),
	notConn   (1)
}

SetOfConnectionStatus ::= SET OF ConnectionStatus

SetOfPortType ::= SET OF PortType

PortQuery ::= SEQUENCE {
	linkName              LinkName          OPTIONAL,
	pathName              PathPattern       OPTIONAL,
	circName              PathPattern       OPTIONAL,
	portTypes             SetOfPortType,
	asonStates            SetOfASTNOperationalState,
	connections           SetOfConnectionStatus,
	operStates            SetOfOperState,
	selectedNodes         SelectedNodes     OPTIONAL,
	caseSensitiveMatching NULL              OPTIONAL
}

PortId ::= INTEGER

PortName ::= GraphicString

Bandwith ::= GraphicString

SetOfPortQueryResult ::= SET OF PortQueryResult

PortQueryResult ::= SEQUENCE {
	portId    PortId,
	portName  PortName,
        neId      NEId,
	neName    NEName,
	portInfo  LabelPortCoord,
	portType  PortType,
	asonState ASTNOperationalState,
	connected BOOLEAN,
	operState OperState,
	bandwidth Bandwith,
	tpRole TPRole OPTIONAL
}

MakePortQuery ::= SEQUENCE {
	reqId     SmartReqIdtype,
	userId    AttrId,
	queriedBy PortQuery,
	limit	  INTEGER,
	dummy     NULL OPTIONAL
}

ReportMakePortQuery ::= SEQUENCE {
	reqId                SmartReqIdtype,
	result               Res,
	numResult            INTEGER,
	setOfPortQueryResult SetOfPortQueryResult
}

MsgMakePortQuery MESSAGE MakePortQuery ::= 5136
	FROM UI
	TO NRQH

md_MsgMakePortQuery MessageDescriptor ::= { mdKind 2, mdReport 5236 }

MsgReportMakePortQuery MESSAGE ReportMakePortQuery ::= 5236
	FROM NRQH
	TO UI

md_MsgReportMakePortQuery MessageDescriptor ::= { mdKind 3 }
-- *****************  end PortQuery ***************************************
-- *****************  END WSON *********************************





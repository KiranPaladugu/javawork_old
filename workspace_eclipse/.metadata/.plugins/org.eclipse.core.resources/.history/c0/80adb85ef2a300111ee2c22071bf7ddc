package com.marconi.fusion.tmf.i36PlugIn;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.marconi.fusion.X36.X36GetReportPortConfiguration;
import com.marconi.fusion.X36.X36InternalODUInfo;
import com.marconi.fusion.X36.X36InternalODUPort;
import com.marconi.fusion.X36.X36NeId;
import com.marconi.fusion.X36.X36ODUId;
import com.marconi.fusion.X36.X36ODUTimeSlot;
import com.marconi.fusion.X36.X36STMnBackplanePort;
import com.marconi.fusion.X36.X36STMnPort;
import com.marconi.fusion.X36.X36SpecificPortInformation;
import com.marconi.fusion.base.logging.DumpInfo;
import com.marconi.fusion.base.util.Holder;
import com.marconi.fusion.tmf.additionalInformation.AdditionalInfoUtils;
import com.marconi.fusion.tmf.additionalInformation.ChannelInformation;
import com.marconi.fusion.tmf.additionalInformation.DBAdditionalInfoUtilities;
import com.marconi.fusion.tmf.additionalInformation.EmSystemProfile;
import com.marconi.fusion.tmf.additionalInformation.NextLongIdAdditionalInfo;
import com.marconi.fusion.tmf.additionalInformation.ProprietaryAdditionalInfo;
import com.marconi.fusion.tmf.additionalInformation.TimeSlotInformation;
import com.marconi.fusion.tmf.agnosticInfo.AIPortCoord;
import com.marconi.fusion.tmf.agnosticInfo.AIPortInfo;
import com.marconi.fusion.tmf.agnosticInfo.AIPortType;
import com.marconi.fusion.tmf.agnosticInfo.AITimeSlotInfo;
import com.marconi.fusion.tmf.db.DBComponent.TMFObject;
import com.marconi.fusion.tmf.db.DBConnectionTerminationPoint;
import com.marconi.fusion.tmf.db.DBCrossConnectableTp;
import com.marconi.fusion.tmf.db.DBCtp;
import com.marconi.fusion.tmf.db.DBFtp;
import com.marconi.fusion.tmf.db.DBManagedElement;
import com.marconi.fusion.tmf.db.DBPortTp;
import com.marconi.fusion.tmf.db.DBPtp;
import com.marconi.fusion.tmf.db.DBTp;
import com.marconi.fusion.tmf.db.Session;
import com.marconi.fusion.tmf.i36PlugIn.I36PlugIn.PluginProperty;
import com.marconi.fusion.tmf.plugIn.PlugInException;
import com.marconi.fusion.tmf.plugIn.PlugInExceptionHandler;
import com.marconi.fusion.tmf.plugIn.TpType;
import com.marconi.fusion.tmf.plugIn.types.CtpName;
import com.marconi.fusion.tmf.plugIn.types.CtpNameComponent;
import com.marconi.fusion.tmf.plugIn.types.GenericTPId;
import com.marconi.fusion.tmf.plugIn.types.LayerRate;
import com.marconi.fusion.tmf.plugIn.types.LayeredParameterList;
import com.marconi.fusion.tmf.plugIn.types.LayeredParameters;
import com.marconi.fusion.tmf.plugIn.types.MEDn;
import com.marconi.fusion.tmf.plugIn.types.MEId;
import com.marconi.fusion.tmf.plugIn.types.TPDn;
import com.marconi.fusion.tmf.plugIn.types.TerminationPoint;
import com.marconi.fusion.tmf.sbi.em.EmSBIPluginProperty;
import com.marconi.fusion.tmf.tmfFramework.TmfNameUtilities;
import com.marconi.fusion.tmf.tmfFramework.repository.LayerRateManager;
import com.marconi.fusion.tmf.utils.AIHelper;
import com.marconi.fusion.tmf.utils.CrossConnectionHelper;
import com.marconi.fusion.tmf.utils.CrossConnectionHelper.EndPoint;
import com.marconi.fusion.tmf.utils.LayeredParametersUtils;

/**
 * @author QGIUVUL
 **
 */
//123
public class TPManager {
	private static final Log LOG = LogFactory.getLog(TPManager.class);
	private SBIClientI sbiClient = null;
	private Session session = null;
	private final Set<Short> validJ0Rates = new HashSet<Short>();
	private final Set<Short> validJRates = new HashSet<Short>();
	int muxAggrClientPort = 0;
	private boolean isACTPJO = false;
	private boolean isClientCtpJO = false;
	private boolean flag;
	private int port = 0;
	public TPManager(final SBIClientI sbiClient) {
		this.sbiClient = sbiClient;

		validJ0Rates.add(LayerRateManager.getLayerRateAsShort("LR_Section_OC3_STS3_and_RS_STM1"));
		validJ0Rates.add(LayerRateManager.getLayerRateAsShort("LR_Section_OC12_STS12_and_RS_STM4"));
		validJ0Rates.add(LayerRateManager.getLayerRateAsShort("LR_Section_OC48_STS48_and_RS_STM16"));
		validJ0Rates.add(LayerRateManager.getLayerRateAsShort("LR_Section_OC192_STS192_and_RS_STM64"));
		validJ0Rates.add(LayerRateManager.getLayerRateAsShort("LR_Optical_Transmission_Section"));

		validJRates.add(LayerRateManager.getLayerRateAsShort("LR_OCH_Transport_Unit_1"));
		validJRates.add(LayerRateManager.getLayerRateAsShort("LR_OCH_Transport_Unit_2"));
		validJRates.add(LayerRateManager.getLayerRateAsShort("LR_OCH_Transport_Unit_3"));
		validJRates.add(LayerRateManager.getLayerRateAsShort("LR_OCH_Data_Unit_0"));
		validJRates.add(LayerRateManager.getLayerRateAsShort("LR_OCH_Data_Unit_1"));
		validJRates.add(LayerRateManager.getLayerRateAsShort("LR_OCH_Data_Unit_2"));
		validJRates.add(LayerRateManager.getLayerRateAsShort("LR_OCH_Data_Unit_3"));
	}

	private boolean isStmTransporMuxPonder(final AIPortType aiPortType) {
		if (aiPortType.isPt_stmTransponder() || aiPortType.isPt_muxponderAggregated() || aiPortType.isPt_muxponderClientTM() || aiPortType.isPt_muxponderClientLM()) {
			return true;
		} else {
			return false;
		}
	}

	public void getTP(final TPDn tpDn,final Holder<TerminationPoint> tpHolder) throws Exception {
		//modified to fix TR HL31707
		// getTPFromDB = true --> get the TP information from TMF DB
		// getTPFromDB = false --> get the TP information from NE
		final boolean getTPFromDB = getSBIClient().getPlugIn().getProfile().getBoolProperty(PluginProperty.getTPFromDB, true);
		this.updateJ0(tpDn, tpHolder, getTPFromDB);
	}

	public void updateJ0(final TPDn tpDn) throws Exception {
		Holder<TerminationPoint> outTPHolder = new Holder<TerminationPoint>();
		updateJ0(tpDn, outTPHolder, false);
		outTPHolder = null;
	}

	private void updateJ0(final TPDn tpDn, final Holder<TerminationPoint> outTPHolder, final boolean getTPFromDB) throws Exception {
		final I36DatabaseManager dbManager = getSBIClient().getDbManager();
		if (LOG.isDebugEnabled()) {
			LOG.debug(new DumpInfo(tpDn, "#Invoke getTP for:"));
		}
		AIPortType aiPortType = null;
		AIPortInfo portInfo = null;
		final TerminationPoint tpTemp = new TerminationPoint();
		/*
		 * variable isAftp is used to identify ctp is ptp side or ftp side in LMtransponder. For other transponders it will always
		 * false
		 */
		boolean isAFTP = false;
		try {
			this.session = dbManager.beginSession(false);
			DBTp dbTP = null;
			dbTP = checkCtp(dbManager, tpDn, outTPHolder, getTPFromDB,
					isACTPJO, dbTP);
			if (flag) {
				return;
			}
			portInfo = DBAdditionalInfoUtilities.getPortInfo(dbTP);
			if (portInfo != null) {
				aiPortType = portInfo.getType();
			}
			tpTemp.set(dbTP.getInformation());
		} catch (final PlugInException ex) {
			LOG.error(new DumpInfo(
					"Exception while trying to retrieve Tp from db :", ex));
			throw ex;
		} catch (final Exception ex) {
			LOG.error(new DumpInfo("Unexpected error:", ex));
			return;
		} finally {
			if (session != null) {
				session.terminate();
				session = null;
			}
		}
		if (aiPortType != null) {
			if (isStmTransporMuxPonder(aiPortType)) {
				try {
					this.session = dbManager.beginSession(false);
					final DBTp dbTP = dbManager.getTP(tpDn);
					// if getobject is clicked on ctp or ftp on client side with wrapped TM
					if (aiPortType.isPt_muxponderClientTM() && !isACTPJO && (dbTP instanceof DBFtp)) {
						// isACTP is set true if coming port is clientftp of MuxponderTM. this variable validated in getJ0() and
						// updateTrailTraceMuxponder
						isACTPJO = true;
					} else if (aiPortType.isPt_muxponderClientLM()) {
						checkmuxponderClientLM(dbTP);
					} else if (isACTPJO && (aiPortType.isPt_muxponderClientTM())) {
						portInfo = checkmuxponderClientTM(portInfo, dbTP);
					} else if (aiPortType.isPt_muxponderClientTM()) { // case of client PTP
						if (!dbTP.getInformation().getAdditionalInfo().isEmpty()) {
							final int serverPortId = AdditionalInfoUtils.findInteger(dbTP.getInformation().getAdditionalInfo(),
									ProprietaryAdditionalInfo.ServerPortId);
							// Muxponder FTP and PTP are on same card only portId are different, so just changing port id
							// Also from portInfo only port coordinates are used to fetch TP from SBI
							portInfo.getCoord().setPortId(serverPortId);
							portInfo.getType().setPt_muxponderAggregated();
							portInfo.getDescriptor().clear();
						}
					} else if (isACTPJO && aiPortType.isPt_stmTransponder()) {
						// isClientCtp is used to distinguish between client side and line side ctp on G709 stm transponder
						final DBPortTp dbPtp = ((DBCtp) dbTP).getPtp().get();
						if (dbPtp.getType().equals(TMFObject.PTP)) {
							isClientCtpJO = true;
						}
					}
					/*
					 * Fix for TR HM76877: Returning without sending request to So-EM, if get operation is performed on CTPs over
					 * line side FTP of TDM Muxponder with STM16 client G709 wrapped. Because these CTPs are dummy ctps,
					 * TrailTrace parameters should not be set to these CTPs.
					 */
					else if (aiPortType.isPt_muxponderAggregated()) {
						if (isACTPJO) {
							// ctps over line side FTP of TDM Muxponder with STM16 client G709 wrapped will come here
							final DBConnectionTerminationPoint dbCtp = (DBConnectionTerminationPoint) dbTP;
							if (I36Utilities.isMuxDummyCTP(dbCtp)) {
								outTPHolder.setTarget(tpTemp);
								session.commit();
								return;
							}
						} else if (tpDn.getTp().isFtp()) {
							/*
							 * for Datamuxponder configured in intercard,ODU layer rate will splitted to protected FTP with label
							 * odu1(TR HN14391)
							 */
							final GenericTPId tpId = tpDn.getTp().getFtp();
							if (tpId != null && tpId.getLabel() != null && tpId.getLabel().getValue() != null
									&& tpId.getLabel().getValue().indexOf("odu") != -1) {
								isAFTP = true;
							}
						}

					}
				} catch (final Exception ex) {
					LOG.error(new DumpInfo("Unexpected error:", ex));
					return;
				} finally {
					if (session != null) {
						session.terminate();
						session = null;
					}
				}

			}
			/* this if block checks the lmtranspoder type and sets the varaiables according to lmtranspoder type */
			else if (aiPortType.isPt_lmTransponderIngress() || aiPortType.isPt_lmTransponder()
					|| aiPortType.isPt_lmTransponderEgress()) { // aiPortType.isPt_lmTransponderEgress() is added to handle LM
				// transponder Egress type ports
				try {
					this.session = dbManager.beginSession(false);

					final DBTp dbTP = dbManager.getTP(tpDn);

					isAFTP = checkLmTranspoderPorts(aiPortType, isAFTP, dbTP);
				} catch (final Exception ex) {
					LOG.error(new DumpInfo("Unexpected error:", ex));
					return;
				} finally {
					if (session != null) {
						session.terminate();
						session = null;
					}
				}
			} else {
				/*
				 * Checking whether tp is CTP contained in FTP or PTP for InternalODU ports,CBR Ports,OTM ports,Backplane
				 * Transponder ports and updating isClientCtp,isAFTP flags
				 */
				try {
					this.session = dbManager.beginSession(false);
					final DBTp dbTP = dbManager.getTP(tpDn);
					if (dbTP.getType().equals(TMFObject.FTP)) {
						isAFTP = true;
					} else if (dbTP.getType().equals(TMFObject.CTP)
							&& ((DBCtp) dbTP).getPtp().get().getType().equals(TMFObject.PTP)) {
						isClientCtpJO = true;
					}
				} catch (final Exception ex) {
					LOG.error(new DumpInfo("Unexpected error:", ex));
					return;
				} finally {
					if (session != null) {
						session.terminate();
						session = null;
					}
				}
			}
			getJ0(tpTemp, portInfo, isACTPJO, isClientCtpJO, isAFTP);
		}
		final LayeredParameterList lrParList = tpTemp.getTransmissionParams();
		try {
			session = dbManager.beginSession(true);
			DBTp dbTPup = null;

			dbTPup = checkTP(dbManager, tpDn, dbTPup);
			final TerminationPoint termPt = new TerminationPoint(dbTPup.getInformation());
			termPt.setTransmissionParams(lrParList);
			dbTPup.setInformation(termPt);
			outTPHolder.setTarget(dbTPup.getInformation());
			session.commit();
		} catch (final Exception ex) {
			LOG.error(new DumpInfo("Unexpected error:", ex));
			return;
		} finally {

			if (session != null) {
				session.terminate();
				session = null;
			}
		}
	}

	/**
	 * @param tp
	 * @param portInfo
	 * @param isACTP
	 * @param isClientCtp
	 * @param isAFTP
	 * This method gets the trail trace expected,actual,recevied
	 * values from NM fro a given port
	 */
	private void getJ0(final TerminationPoint tp, final AIPortInfo portInfo, final boolean isACTP, final boolean isClientCtp, final boolean isAFTP)
			throws Exception {
		TerminationPoint tp1 = tp;
		DBManagedElement dbME = null;
		final MEDn meDn = new MEDn();

		String hostName = null;
		Session session = null;
		try {
			if (sbiClient.isStandAlone()) {
				hostName = sbiClient.getHostName();
			} else {
				session = sbiClient.getDbManager().beginSession(false);
				final MEId meId = tp1.getName().getMe();// getDn().getMe();
				if (meId == null) {
					LOG.error(new DumpInfo(meId, "Cannot find ME:"));
					throw PlugInExceptionHandler
					.entityNotFound(TmfNameUtilities.toString(meId));
				}

				final MEDn dn = new MEDn();
				dn.setMe(meId);

				final DBManagedElement dbMe = sbiClient.getDbManager()
						.getManagedElement(dn);

				final EmSystemProfile emSystemProfile = sbiClient
						.getEmSystemProfile(dbME);
				hostName = emSystemProfile.getSyntax().getHostId().getValue();
			}
		} catch (final Exception e) {
			LOG.error("Failed to open a session" + e);
		} finally {
			if (session != null) {
				session.terminate();
				session = null;
			}
		}

		final AIPortCoord portCoord = portInfo.getCoord();
		final X36NeId neId = getSBIClient().getNaming().getNeId(tp1.getName());
		int shelf = portCoord.getShelfId().getValue();
		int card = portCoord.getCardId().getValue();
		port = portCoord.getPortId().getValue();
		final int tempPort = port;
		/*
		 * get all the list of layeredparameters and check whether layer rate is supported and add them to a LayeredParameters
		 * list object
		 */
		final LayeredParameterList dpLpList = tp1.getTransmissionParams();
		final List<LayeredParameters> layeredParametersList = new ArrayList<LayeredParameters>();
		for (final LayeredParameters layeredParameters : dpLpList) {
			final LayerRate rate = layeredParameters.getLayer();
			if (!(validJ0Rates.contains((short) rate.getValue()) || validJRates.contains((short) rate.getValue()))) {
				continue;
			} else {
				layeredParametersList.add(layeredParameters);
			}
		}
		/*
		 * check whether list object contains any layered parameters and get all the trail trace values for each layer rate for
		 * particular port here if port type is wdmadaptation port,then we are sending entire layeredParametersList object which
		 * contains all supporting layer rates where as for other ports which support only one layer,the list object contains only
		 * 1 element.so we are passing only LayeredParameters object
		 */
		if (layeredParametersList.size() > 0) {
			/* code is added for LMTransponder */
			/*
			 * In rm transponder case,if port type is bsidermtransponder then it is client ctp
			 */
			final AIPortType aiPortType = portInfo.getType();
			/*
			 * When Backplane Transponder port is configured with klevel 2 and structured, ODU1 CTP's will be created for each of
			 * ODUInfo present in Backplane Transponder port configuration.oduId id used to identify the correponding ODUInfo
			 * present in set of ODUInfo's of Backplane Transponder port
			 */
			X36ODUId oduId = new X36ODUId();
			// internalOduId is used to identify the InternalODUInfo as InternalODUPort has set of InternalODUInfo's
			int internalOduId = 0;
			I36DatabaseManager dbManager = getSBIClient().getDbManager();
			if (!isACTP) {
				if (aiPortType.isPt_lmTransponderIngress()
						|| aiPortType.isPt_bSideRmTransponder()) {
					if (!tp1.getAdditionalInfo().isEmpty()) {
						port = AdditionalInfoUtils.findInteger(tp1
								.getAdditionalInfo(),
								ProprietaryAdditionalInfo.ServerPortId);
					}
				} else if (aiPortType.isPt_aSideRmTransponder()) {
				}
			} else {
				if (aiPortType.isPt_muxponderClientTM()
						|| aiPortType.isPt_muxponderClientLM()) {

					getJOMuxponderClientTMLM(dbManager, tp1);
				} else if ((aiPortType.isPt_lmTransponderIngress())) {

					checklmTransponderIngress(dbManager, tp1);
				} else if (aiPortType.isPt_muxponderAggregated()) {
					try {
						this.session = dbManager.beginSession(false);
						final DBTp dbTP = dbManager.getTP(tp1.getName());
						if (dbTP.getDn().isPresentCtp()) {
							final DBCtp dbCtp = (DBCtp) dbTP;
							if (LayeredParametersUtils.isMuxOTMCTP(dbCtp)) {
								muxAggrClientPort = AdditionalInfoUtils
										.findInteger(
												tp1.getAdditionalInfo(),
												ProprietaryAdditionalInfo.FTPClientPort);
							}
						}
					} catch (final Exception ex) {
						LOG.error(new DumpInfo("Unexpected error:", ex));
						return;
					} finally {

						if (session != null) {
							session.terminate();
							session = null;
						}
					}

				} else if (aiPortType.isPt_bSideRmTransponder()) {
					try {
						this.session = dbManager.beginSession(false);
						final DBTp dbTP = dbManager.getTP(tp1.getName());
						final DBPortTp dbPtp = ((DBCtp) dbTP).getPtp().get();
						tp1 = dbPtp.getInformation();
						// get server port Id of client port
						port = AdditionalInfoUtils.findInteger(tp1
								.getAdditionalInfo(),
								ProprietaryAdditionalInfo.ServerPortId);
					} catch (final Exception ex) {
						LOG.error(new DumpInfo("Unexpected error:", ex));
						return;
					} finally {

						if (session != null) {
							session.terminate();
							session = null;
						}
					}
				} else if (aiPortType.isPt_aSideRmTransponder()) {
				}
			}
			/* checking whether ports are InternalODU ports,Backplane ports and updating isClientCtp flag */
			if (aiPortType.isPt_backplaneOdu()) {
				try {
					this.session = dbManager.beginSession(false);
					final DBTp dbTP = dbManager.getTP(tp1.getName());
					if (dbTP instanceof DBCtp) {
						final TimeSlotInformation ts = (TimeSlotInformation) dbTP.getAdditionalInformation(TimeSlotInformation.NAME);
						final AITimeSlotInfo aiTsInfo = ts.getSyntax();
						final TpType ctpTpType = TpType.valueOf(aiTsInfo.getDescriptor().getValue());
						if (ts.getSyntax().getCoord().isOduTimeSlot()) {
							final X36ODUTimeSlot oduTimeSlot = AIHelper.buildTimeSlot(ts.getSyntax().getCoord().getOduTimeSlot());
							oduId = oduTimeSlot.getOduId();
						}
						if (ctpTpType == TpType.odu1AggregateCtps || ctpTpType == TpType.odu2AggregateCtps) {
						}
					}
				} catch (final Exception ex) {
					LOG.error(new DumpInfo("Unexpected error:", ex));
					return;
				} finally {
					dbManager.abortSession();
				}
			} else if (aiPortType.isPt_internalODU()) {
				if (isAFTP || isACTP) {
					/*
					 * If port is InternalODU port,getting oduid from AdditionalInformation to identify the corresponding
					 * InternalODUInfo of InternalODU port as InternalODU port has set of InternalODU info's.
					 */
					dbManager = getSBIClient().getDbManager();
					try {
						this.session = dbManager.beginSession(false);
						final DBTp dbTP = dbManager.getTP(tp1.getName());
						if (dbTP instanceof DBCtp) {
							final DBPortTp ftp = ((DBCtp) dbTP).getPtp().get();
							internalOduId = ((NextLongIdAdditionalInfo) (ftp
									.getAdditionalInformation(NextLongIdAdditionalInfo.NAME))).getSyntax().getValue();
						} else {
							internalOduId = ((NextLongIdAdditionalInfo) (dbTP
									.getAdditionalInformation(NextLongIdAdditionalInfo.NAME))).getSyntax().getValue();
						}
						if (isACTP) {
							/*
							 * This is related to case where Internal ODU port is configured with OPU1_2v mapping In this case
							 * InternalODUInfo's of InternalODU port is configured as Master and slave.For the slave Internal ODU
							 * Port,aggregated CTP's are created with tp cordinates of Master.In this case,getting portCordinates
							 * of slave port from channelindentification of Aggregated CTP's
							 */
							final ChannelInformation channelInformation = (ChannelInformation) (dbTP
									.getAdditionalInformation(ChannelInformation.NAME));
							if (channelInformation != null) {
								shelf = channelInformation.getSyntax().getPortInfo().getCoord().getShelfId().getValue();
								card = channelInformation.getSyntax().getPortInfo().getCoord().getCardId().getValue();
								port = channelInformation.getSyntax().getPortInfo().getCoord().getPortId().getValue();
							}
						}
					} catch (final Exception ex) {
						LOG.error(new DumpInfo("Unexpected error:", ex));
						return;
					} finally {
						if (session != null) {
							session.terminate();
							session = null;
						}
					}

				}
			}
			/* end of code for LMTransponder */
			final long timeout = sbiClient.getProfile().getTimeProperty(EmSBIPluginProperty.sbiTimeout, 180000);
			sbiClient.getMessageHandler().setTimeout(timeout);
			final X36GetReportPortConfiguration portConf = getSBIClient()
					.getMessageHandler().getPortConfiguration(neId, shelf,
							card, port, hostName);
			if (!portConf.getCompliance().isResOk()) {
				LOG.error(new DumpInfo(portConf, String
						.format("GetPortConfiguration error for <%s>...", getSBIClient().getName())));
				// throw PlugInExceptionHandler.internalError(portConf.getCause().getValue());
				return;
			} else {
				specificPortInfos(portConf, layeredParametersList, aiPortType, port, isACTP, isClientCtp, isAFTP, internalOduId,
						tempPort, oduId, tp1);
			}
			// break;
		}
	}

	private SBIClientI getSBIClient() {
		return sbiClient;
	}

	private int getOduId(final X36ODUId x36OduId) {
		int oduId = 0;
		if (x36OduId != null) {
			if (x36OduId.getOdu0().getValue() > 0) {
				oduId = x36OduId.getOdu0().getValue();
			} else if (x36OduId.getOdu1().getValue() > 0) {
				oduId = x36OduId.getOdu1().getValue();
			} else if (x36OduId.getOdu2().getValue() > 0) {
				oduId = x36OduId.getOdu2().getValue();
			} else if (x36OduId.getOdu3().getValue() > 0) {
				oduId = x36OduId.getOdu3().getValue();
			}
		}
		return oduId;
	}

	/**
	 * get the coments from ctpDn,check component and store the value in dbTPup.if dbTPup value is null then throws Exception
	 * @param dbManager
	 * @param tpDn
	 * @param dbTPup
	 * @return
	 * @throws Exception
	 */
	private DBTp checkTP(final I36DatabaseManager dbManager, final TPDn tpDn, final DBTp dbTPup) throws Exception {
		DBTp dbTPup1 = dbTPup;
		if (tpDn.isPresentCtp()) {
			final CtpName ctpDn = tpDn.getCtp();
			final CtpNameComponent component = ctpDn.getComponents().get(0);
			if (component.isEth() || component.isEthvid() || component.isEthsvid()) {
				dbTPup1 = dbManager.getFP(tpDn);
			} else {

				dbTPup1 = dbManager.getTP(tpDn);
			}

		} else {
			dbTPup1 = dbManager.getTP(tpDn);
		}

		if (dbTPup1 == null) {
			LOG.error(new DumpInfo(tpDn, "Unable to locate TP... "));
			throw PlugInExceptionHandler.entityNotFound("tpInfo.tpName");
		}
		return dbTPup1;
	}

	/**
	 * get tpDn value and store in dbTP.if dbTP value is null then throws Exception
	 * @param dbManager
	 * @param tpDn
	 * @param outTPHolder
	 * @param getTPFromDB
	 * @param isACTP
	 * @param dbTP
	 * @return
	 * @throws Exception
	 */
	private DBTp checkCtp(final I36DatabaseManager dbManager, final TPDn tpDn, final Holder<TerminationPoint> outTPHolder,
			final boolean getTPFromDB, final boolean isACTP, final DBTp dbTP) throws Exception {
		boolean isACTP1 = isACTP;
		DBTp dbTP1 = dbTP;

		dbTP1 = dbManager.getTP(tpDn);

		if (dbTP1 == null) {
			LOG.error(new DumpInfo(tpDn, "Unable to locate TP... "));
			throw PlugInExceptionHandler.entityNotFound("tpInfo.tpName");
		}
		// get TP information from TMF DB
		if (getTPFromDB) {
			outTPHolder.setTarget(dbTP1.getInformation());
			flag = true;
			return dbTP1;
		}

		if (tpDn.isPresentCtp()) {
			isACTP1 = true;
		}
		/*
		 * If tp is CTP contained FTP of Internal ODU Port which is not
		 * terminated,then Trail Trace parameters will not be applicable in on
		 * the CTP
		 */
		if (isACTP1) {
			TpType ctpTpType = null;
			if (dbTP1 instanceof DBCtp) {
				final TimeSlotInformation ts = (TimeSlotInformation) dbTP1.getAdditionalInformation(TimeSlotInformation.NAME);
				final AITimeSlotInfo aiTsInfo = ts.getSyntax();
				ctpTpType = TpType.valueOf(aiTsInfo.getDescriptor().getValue());
				if (ctpTpType == TpType.internalOdu1Ctp || ctpTpType == TpType.internalOdu2Ctp
						|| ctpTpType == TpType.internalOdu3Ctp) {
					outTPHolder.setTarget(dbTP1.getInformation());
					flag = true;
					return dbTP1;
				}
			}
		}
		return dbTP1;
	}

	/**
	 * check porttype as lmTransponderIngress() and dbPtp value with PTP then update isClientCtp_JO value as true.other wise store the dbTp value in dbPtp
	 * @param aiPortType
	 * @param isAFTP
	 * @param dbTP
	 * @return
	 * @throws Exception
	 */
	private boolean checkLmTranspoderPorts(final AIPortType aiPortType, final boolean isAFTP, final DBTp dbTP) throws Exception {
		boolean isAFTP1 = isAFTP;
		if (isACTPJO && aiPortType.isPt_lmTransponderIngress()) {
			// isClientCtp is used to distinguish between client side and line side ctp on G709 lm transponder
			final DBPortTp dbPtp = ((DBCtp) dbTP).getPtp().get();

			if (dbPtp.getType().equals(TMFObject.PTP)) {
				/*
				 * It is used in the lmdualstage transponder. if isClientCtp is true clientside odu parameters are displayed
				 * otherwise lineside odu parameters are displayed
				 */
				isClientCtpJO = true;
			}
		} // condition is changed to handle LM Egress type ports.
		else if (aiPortType.isPt_lmTransponder() || aiPortType.isPt_lmTransponderEgress()) {
			DBPortTp dbPtp = null;
			if (isACTPJO) {
				dbPtp = ((DBCtp) dbTP).getPtp().get();
			} else {
				if (dbPtp instanceof DBPtp) {
					dbPtp = ((DBPtp) dbTP);
				}
			}
			/*
			 * It is used in the lmsinglestage transponder. if isAFTP is true clientside odu parameters are displayed otherwise
			 * lineside odu parameters are displayed
			 */
			if(dbPtp!=null){
				if (dbPtp.getType().equals(TMFObject.PTP)) {
					isAFTP1 = false;
				} else if (dbPtp.getType().equals(TMFObject.FTP)) {
					isAFTP1 = true;
				}}
		}
		return isAFTP1;
	}

	/**
	 * check X36SpecificPortInformation according to that call the methods in
	 * I36LayeredParameterManager.java
	 * 
	 * @param portConf
	 * @param layeredParametersList
	 * @param aiPortType
	 * @param port
	 * @param isACTP
	 * @param isClientCtp
	 * @param isAFTP
	 * @param internalOduId
	 * @param tempPort
	 * @param oduId
	 * @param tp
	 */
	private void specificPortInfos(final X36GetReportPortConfiguration portConf,final List<LayeredParameters> layeredParametersList,final AIPortType aiPortType,final int port,
			final boolean isACTP, final boolean isClientCtp, final boolean isAFTP,final int internalOduId,final int tempPort,final X36ODUId oduId,final TerminationPoint tp)
	{
		int port1 = port;
		final X36SpecificPortInformation specificPortInfo = portConf.getPortInformation().getSpecificPortInformation();
		switch (specificPortInfo.getMemberId()) {

		case X36SpecificPortInformation.eStm1Port:
		case X36SpecificPortInformation.oStm1Port:
		case X36SpecificPortInformation.stm4Port:
		case X36SpecificPortInformation.stm16Port:
		case X36SpecificPortInformation.stm64Port:
		case X36SpecificPortInformation.stm256Port: {

			final X36STMnPort stmnPort = (X36STMnPort) specificPortInfo.getObject();
			I36LayeredParameterManager.updateSTMnPortTrailTrace(stmnPort, layeredParametersList.get(0));
		}
		break;
		case X36SpecificPortInformation.stm_EthCtpPort:
			I36LayeredParameterManager.updateStmEthCtpPortTrailTrace(specificPortInfo.getStm_EthCtpPort(),
					layeredParametersList.get(0));
			break;
		case X36SpecificPortInformation.radioPort:
			I36LayeredParameterManager.updateRadioPortTrailTrace(specificPortInfo.getRadioPort(), layeredParametersList
					.get(0));
			break;
		case X36SpecificPortInformation.wdmAdaptationPort:

			/*
			 * BackplaneTransponder is reported as wdmAdaptationPort.Checking whether Transptype is backplane transponder
			 * and updating LayeredParameters of Backplane Transponder tp with Backplane Transponder configuration
			 * reported.
			 */
			if (specificPortInfo.getWdmAdaptationPort().getTranspInfo().isBackplaneTransponder()) {

				/*
				 * Iterating through the set of LayeredParameters present on Backplane Transponder tp and if any layer
				 * rate matches with ODU or OTU layer,updating layered parameters with Backplane Transponder configuration
				 */
				for (final LayeredParameters layeredParameters : layeredParametersList) {
					if (validJRates.contains((short) layeredParameters.getLayer().getValue())) {
						I36LayeredParameterManager.updateBackPlanePortTrailTrace(specificPortInfo.getWdmAdaptationPort()
								.getTranspInfo().getBackplaneTransponder(), layeredParameters, isClientCtp, oduId);
						break;
					}
				}

			} else {
				if ((aiPortType.isPt_muxponderClientTM() || aiPortType.isPt_muxponderClientLM()) && isACTP) {
					port1 = tempPort;
				}
				// when getobject is performed on client side ctp under a ptp,
				// port type is muxponderAggregated,ctp is true,client port is not zero
				// and server port !=client port then equate port with client port
				else if (aiPortType.isPt_muxponderAggregated() && isACTP
						&& (muxAggrClientPort > 0 && port1 != muxAggrClientPort)) {
					port1 = muxAggrClientPort;
				}
				I36LayeredParameterManager.updateWdmAdaptationPortTrailTrace(specificPortInfo.getWdmAdaptationPort(),
						layeredParametersList, isACTP, isClientCtp, isAFTP, port1, tp);
			}
			break;
		case X36SpecificPortInformation.wdmPort:
			I36LayeredParameterManager.updateWdmPortTrailTrace(specificPortInfo.getWdmPort(), isACTP,
					layeredParametersList.get(0));
			break;
		case X36SpecificPortInformation.pdh2mbitPort:
			I36LayeredParameterManager.updatePdh2mbitTrailTrace(specificPortInfo.getPdh2mbitPort(), layeredParametersList
					.get(0));
			break;
		case X36SpecificPortInformation.pdh140mbitPort:
			I36LayeredParameterManager.updatePdh140mbitTrailTrace(specificPortInfo.getPdh140mbitPort(),
					layeredParametersList.get(0));
			break;
		case X36SpecificPortInformation.internalODUPort:
			final X36InternalODUPort internalODUPort=specificPortInfo.getInternalODUPort();
			if (aiPortType.isPt_internalODU()) {

				/*
				 * Iterating through the set of InternalODUInfo's present in InternalODU port and getting the
				 * corresponding InternalODUInfo object related to the tp.
				 */
				for (final X36InternalODUInfo internalODUInfo : internalODUPort.getIntPortInfo().getAll()) {
					if (internalODUInfo.isPresentOduInfo() && internalODUInfo.getOduInfo().isPresentId()) {
						final X36ODUId x36ODUId = internalODUInfo.getOduInfo().getId();
						if (getOduId(x36ODUId) == internalOduId) {
							/*
							 * Iterating through the set of LayeredParameters present on InternalODU port tp and if any
							 * layer rate matches with ODU layer,updating layered parameters with InternalODU port
							 * configuration
							 */
							for (final LayeredParameters layeredParameters : layeredParametersList) {
								if (validJRates.contains((short) layeredParameters.getLayer().getValue())) {
									I36LayeredParameterManager.updateInternalODUPortTrailTrace(internalODUInfo,
											layeredParameters);
									break;
								}
							}
						}

					}

				}
			}
			break;
		case X36SpecificPortInformation.otmPort:
			I36LayeredParameterManager.updateOTMTrailTrace(specificPortInfo.getOtmPort(),layeredParametersList);
			break;
		case X36SpecificPortInformation.cbrPort:
			I36LayeredParameterManager.updateCBRPortTrailTrace(specificPortInfo.getCbrPort(),layeredParametersList.get(0),isClientCtp);
			break;

		case X36SpecificPortInformation.stmnBackplanePort:
			final X36STMnBackplanePort stmBackPlanePort = specificPortInfo.getStmnBackplanePort();
			if (stmBackPlanePort.isPresentSetOfSlotInformation() && stmBackPlanePort.isPresentClientPDH()) {
				I36LayeredParameterManager.updateInternalSTMPortTrailTrace(stmBackPlanePort, layeredParametersList);
			}
			break;
		}

	}

	/**
	 * check dbPtp value with FTP then update isClientCtp_JO value with false otherwise true.
	 * @param dbTP
	 * @throws Exception
	 */
	private void checkmuxponderClientLM(final DBTp dbTP) throws Exception {
		// isACTP is set true if coming port is clientftp or ptp of MuxponderLM. this variable validated in getJ0()
		// and updateTrailTraceMuxponder
		DBPortTp dbPtp = null;
		if (!isACTPJO) {
			isACTPJO = true;
			if (dbPtp instanceof DBCtp) {
				dbPtp = ((DBPtp) dbTP);
			}
		} else {
			dbPtp = ((DBCtp) dbTP).getPtp().get();
		}

		if (dbPtp != null && (dbPtp.getType().equals(TMFObject.FTP))) {
			// isClientCtp is set true if coming port is clientftp of MuxponderLM. this variable validated in getJ0()
			// and updateTrailTraceMuxponder
			isClientCtpJO = false;
		} else {
			isClientCtpJO = true;
		}
	}

	/**
	 * @param portInfo
	 * @param dbTP
	 * @return
	 * @throws Exception
	 */
	private AIPortInfo checkmuxponderClientTM(final AIPortInfo portInfo, final DBTp dbTP) throws Exception {
		// case of client CTP
		AIPortInfo portInfo1 = portInfo;
		DBTp ftp = null;

		final Map<EndPoint, DBCrossConnectableTp[]> endPoints = new HashMap<EndPoint, DBCrossConnectableTp[]>();

		endPoints.putAll(CrossConnectionHelper.getEndPoints((DBCtp) dbTP));

		if (endPoints.get(CrossConnectionHelper.EndPoint.AEND).length > 0) {

			ftp = ((DBCtp) endPoints.get(CrossConnectionHelper.EndPoint.AEND)[0]).getPtp().get();// TR HM54385

		} else if (endPoints.get(CrossConnectionHelper.EndPoint.ZEND).length > 0) {
			ftp = ((DBCtp) endPoints.get(CrossConnectionHelper.EndPoint.ZEND)[0]).getPtp().get();// TR HM54385
		} else if (endPoints.get(CrossConnectionHelper.EndPoint.BDIR).length > 0) {
			ftp = ((DBCtp) endPoints.get(CrossConnectionHelper.EndPoint.BDIR)[0]).getPtp().get();// TR HM54385
		}
		// variable for holding client side port when port type is client tm
		// to get trail trace parameters for particular port
		muxAggrClientPort = portInfo1.getCoord().getPortId().getValue();
		portInfo1 = DBAdditionalInfoUtilities.getPortInfo(ftp);
		return portInfo1;
	}

	/**
	 * store the information of dbCtp in TP and pass this TP value and get the port value
	 * @param dbManager
	 * @param tp
	 * @throws Exception
	 */
	private void getJOMuxponderClientTMLM(final I36DatabaseManager dbManager, final TerminationPoint tp) throws Exception {
		TerminationPoint tp1 = tp;
		try {
			this.session = dbManager.beginSession(false);
			final DBTp dbTP = dbManager.getTP(tp1.getName());
			if (dbTP.getDn().isPresentCtp()) {
				final DBCtp dbCtp = (DBCtp) dbTP;
				tp1 = dbCtp.getPtp().get().getInformation();
			} else {
				final DBPtp dbPtp = (DBPtp) dbTP;
				tp1 = dbPtp.getInformation();
			}
			// get server port Id of client port
			port = AdditionalInfoUtils.findInteger(tp1.getAdditionalInfo(), ProprietaryAdditionalInfo.ServerPortId);

		} catch (final Exception ex) {
			LOG.error(new DumpInfo("Unexpected error:", ex));
			return;
		} finally {

			if (session != null) {
				session.terminate();
				session = null;
			}
		}
	}

	/**
	 * store the information of dbCtp in TP and pass this TP value and get the port value
	 * @param dbManager
	 * @param tp
	 */
	private void checklmTransponderIngress(final I36DatabaseManager dbManager, final TerminationPoint tp) {
		TerminationPoint tp1 = tp;
		try {
			this.session = dbManager.beginSession(false);
			final DBTp dbTP = dbManager.getTP(tp1.getName());
			final DBPortTp dbPtp = ((DBCtp) dbTP).getPtp().get();
			tp1 = dbPtp.getInformation();
			// get server port Id of client port
			port = AdditionalInfoUtils.findInteger(tp1.getAdditionalInfo(), ProprietaryAdditionalInfo.ServerPortId);
		} catch (final Exception ex) {
			LOG.error(new DumpInfo("Unexpected error:", ex));
			return;
		} finally {

			if (session != null) {
				session.terminate();
				session = null;
			}
		}
	}

}


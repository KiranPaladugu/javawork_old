package com.marconi.fusion.tmf.i36PlugIn.converter;

/**
 * X36NetworkElement 2 ManagedElement. <BR>
 * name,EMS,C,FIXED <BR>
 * ....name="EMS" <BR>
 * ....value=_EMSName_ <BR>
 * ....name="ManagedElement" <BR>
 * ....value=_MEName_ <BR>
 * ............SOFO-EMS <BR>
 * ................name="EMS" <BR>
 * ................value="SOO-EMS/_ems-name_" <BR>
 * ................name="ManagedElement" <BR>
 * ................value="_ems-hostname_/NodeUniqueID" <BR>
 * ...................._NodeUniqueID_ is a unique reference for the EMS: <BR>
 * ........................Name Example <BR>
 * ............................name="EMS" <BR>
 * ............................value="SOO-EMS/gehp33" <BR>
 * ............................name="ManagedElement" <BR>
 * ............................value="gehp33/21" <BR>
 * userLabel,EMS,C,FREE, <BR>
 * ....when the object is created the userLabel is set using the nativeEMSName
 * attribute <BR>
 * nativeEMSName,EMS,C,FREE, <BR>
 * ....SOFO-EMS <BR>
 * ........_ShortName_._Suffix_ <BR>
 * ........................_ShortName_ : is a alphanumeric short reference <BR>
 * ......................................for the EMS (Max 8 characters <BR>
 * ........................_Suffix_ : is a numeric reference for the EMS <BR>
 * ......................................(Max 3 characters) <BR>
 * ........................On SOO-EMS ShortName and Suffix pair is unique <BR>
 * ........................EMS Topological view displays <BR>
 * ............................_ShortName_._Suffix_ <BR>
 * location,EMS,C,FREE <BR>
 * ....SOFO-EMS <BR>
 * ........_Name_ <BR>
 * ........................_Name_ : is a alphanumeric reference for <BR>
 * ......................................the EMS (Max 40 characters) <BR>
 * ........................See the nativeEMSName and location tabl <BR>
 * version,EMS,C,FREE, <BR>
 * ....empty <BR>
 * productName,EMS,C,FREE, <BR>
 * ....TODO <BR>
 * communicationState,EMS,L,FIXED <BR>
 * ....available (up) <BR>
 * ........or <BR>
 * ....unavailable (down), <BR>
 * ........................Indicates whether the node is contactable <BR>
 * emsInSyncState,EMS,C,FIXED <BR>
 * ....True, <BR>
 * supportedRates,EMS,C,VALUE LIST <BR>
 * ....e.g., <BR>
 * ........LR_Low_Order_TU3_VC3, <BR>
 * ........LR_STS1_and_AU3_High_Order_VC3, <BR>
 * ........LR_STS3c_and_AU4_VC4, <BR>
 * additionalInfo,EMS,C,FREE, <BR>
 * ....TODO <BR>
 * owner,E,L,FREE <BR>
 * ....SOFO-EMS <BR>
 * ........empty string, <BR>
 *
 * @param X36
 *            X36NetworkElement
 * @return ManagedElement tmf
 */

// import java.util.Enumeration;
import java.net.Inet4Address;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.marconi.fusion.X36.X36CrossConnectionCommand;
import com.marconi.fusion.X36.X36CrossConnectionType;
import com.marconi.fusion.X36.X36GmplsInformation;
import com.marconi.fusion.X36.X36Label;
import com.marconi.fusion.X36.X36MSSPRINGNutTypeSupporting;
import com.marconi.fusion.X36.X36MatrixBehaviour;
import com.marconi.fusion.X36.X36MatrixInformation;
import com.marconi.fusion.X36.X36MplsNodeInfo;
import com.marconi.fusion.X36.X36NeId;
import com.marconi.fusion.X36.X36NeInfo;
import com.marconi.fusion.X36.X36NeUsageState;
import com.marconi.fusion.X36.X36NetworkElement;
import com.marconi.fusion.X36.X36OduOpticalLevel;
import com.marconi.fusion.X36.X36PortLabelSupporting;
import com.marconi.fusion.X36.X36SdhOpticalLevel;
import com.marconi.fusion.X36.X36SetOfCrossConnectionCommand;
import com.marconi.fusion.X36.X36SetOfSignalModes;
import com.marconi.fusion.X36.X36SignalMode;
import com.marconi.fusion.X36.X36StsLevel;
import com.marconi.fusion.X36.X36TrafficType;
import com.marconi.fusion.base.application.Profile;
import com.marconi.fusion.base.logging.DumpInfo;
import com.marconi.fusion.tmf.additionalInformation.AdditionalInfoUtils;
import com.marconi.fusion.tmf.additionalInformation.LAGProvisioningSupported;
import com.marconi.fusion.tmf.additionalInformation.NEIdInEM;
import com.marconi.fusion.tmf.additionalInformation.NeClassAdditionalInfo;
import com.marconi.fusion.tmf.additionalInformation.ProprietaryAdditionalInfo;
import com.marconi.fusion.tmf.additionalInformation.ProtOperModeSupported;
import com.marconi.fusion.tmf.additionalInformation.ProtOperModeSupported.ProtOperMode;
import com.marconi.fusion.tmf.agnosticInfo.AIMECoord;
import com.marconi.fusion.tmf.client2.system.NotificationManager;
import com.marconi.fusion.tmf.db.DBAdditionalInformation;
import com.marconi.fusion.tmf.db.DBComponent;
import com.marconi.fusion.tmf.db.DBEms;
import com.marconi.fusion.tmf.db.DBEquipmentHolder;
import com.marconi.fusion.tmf.db.DBIterator;
import com.marconi.fusion.tmf.db.DBManagedElement;
import com.marconi.fusion.tmf.db.DBObjectProperties;
import com.marconi.fusion.tmf.db.DBSubnetwork;
import com.marconi.fusion.tmf.i36PlugIn.I36PlugIn;
import com.marconi.fusion.tmf.i36PlugIn.LayerRateConverter;
import com.marconi.fusion.tmf.i36PlugIn.MECache;
import com.marconi.fusion.tmf.i36PlugIn.NeHelper;
import com.marconi.fusion.tmf.i36PlugIn.SBIClientI;
import com.marconi.fusion.tmf.plugIn.PlugInException;
import com.marconi.fusion.tmf.plugIn.PlugInExceptionHandler;
import com.marconi.fusion.tmf.plugIn.ProprietaryParameterName;
import com.marconi.fusion.tmf.plugIn.types.AdditionalInfo;
import com.marconi.fusion.tmf.plugIn.types.CommunicationState;
import com.marconi.fusion.tmf.plugIn.types.EMSDn;
import com.marconi.fusion.tmf.plugIn.types.LayerRateList;
import com.marconi.fusion.tmf.plugIn.types.MEDn;
import com.marconi.fusion.tmf.plugIn.types.ManagedElement;
import com.marconi.fusion.tmf.plugIn.types.MultiLayerSubnetwork;
import com.marconi.fusion.tmf.plugIn.types.SNDn;
import com.marconi.fusion.tmf.tmfFramework.EmsInformation;
import com.marconi.fusion.tmf.tmfFramework.TmfNameUtilities;
import com.marconi.fusion.tmf.tmfFramework.db.NotificatorsManager;
import com.marconi.fusion.tmf.tmfFramework.repository.AdditionalInfoManager;
import com.marconi.fusion.tmf.utilities.Stats;
import com.marconi.fusion.tmf.utils.CommonProperties;

/* ************************************************************************** */
public class MEConverter {
	/* ************************************************************************** */
	private static final Log LOG = LogFactory.getLog(MEConverter.class);

	static public final String PROCESS_ME = "Process ME";
	static public final String BEGIN_TR = "Begin TR";
	static public final String COMMIT_TR = "Commit TR";

	private NeHelper neHelper = null;

	private boolean firstRealignment = false;

	protected Stats stats = new Stats();

	// public I36Naming getNaming() {
	// return naming;
	// }
	public MEConverter() {
	}

	/**
	 * @return the notificationEnabled
	 */
	public boolean isFirstRealignment() {
		return firstRealignment;
	}

	/*
	 * ** SBIConverter **********************************************************
	 */
	public CommunicationState convertCommunicationState(final X36NeUsageState X36) {
		/* ************************************************************************** */
		if (X36.isIdle()) {
			return new CommunicationState(CommunicationState.cs_unavailable);
		}
		return new CommunicationState(CommunicationState.cs_available);
	}

	/*
	 *
	 */
	/**
	 * @param neHelper
	 * @param checkNeeded
	 * @return
	 * @throws PlugInException
	 */
	public Stats process(final NeHelper neHelper, final boolean checkNeeded) throws PlugInException {
		this.neHelper = neHelper;
		stats.start(PROCESS_ME);
		final X36NetworkElement x36Ne = neHelper.getNe();
		final X36NeId x36NeId = x36Ne.getNeId();

		final int neId = x36Ne.getNeId().getValue();
		final SBIClientI sbiClient = neHelper.getSBIClient();
		final MECache meCache = sbiClient.getPlugIn().getMECache();
		final String neLocator = sbiClient.getNeLocator(x36NeId);
		// Specifies if the ME creation in the database is needed or not
		boolean meCreationNeeded = true;
		// Checking if the NE info is already present in the MECache with NeId
		MEDn meDn = meCache.get(neId);
		// NE info is already present in the MECache with the neId
		if (meDn != null) {
			// MEDn retrieved by using the NeId
			final String strNeIdMeDn = TmfNameUtilities.toString(meDn);
			if (LOG.isDebugEnabled()) {
				LOG.debug(String.format("MECache is already having the ME [%s] with NeId %d", strNeIdMeDn, neId));
				LOG.debug("No change of NeId is detected during realignment");
			}
			// Get the MEDn by using Acronym,Location and Identifier
			final MEDn keyMeDn = meCache.get(x36Ne);
			if (keyMeDn != null) {
				if (LOG.isDebugEnabled()) {
					LOG.debug(String.format("MECache is already having the ME [%s] with Acronym,Location and Identifier [%s]",
									strNeIdMeDn, MECache.formKey(x36Ne)));
					LOG.debug("No change of Acronym,Location or Identifier is detected during realignment");
				}
				// MEDn retrieved by using Acronym,Location and Identifier
				final String strKeyMeDn = TmfNameUtilities.toString(keyMeDn);
				// If both of them match, no need to create the ME again
				if (strNeIdMeDn.equals(strKeyMeDn)) {
					meCreationNeeded = false;
				} else {
					LOG.error("During realignment of NE there is a mismatch of MEDns [" + strNeIdMeDn + "] and [" + keyMeDn + "]");
				}
			} else {
				LOG.debug("Change of Acronym,Location or Identifier is detected during realignment");
				// Updating the MECache with the new Acronym,Location and Identifier
				if (!meCache.update(x36Ne, meDn)) {
					LOG.error(String.format("Unable to update the MEDn in MECache. ", meDn));
				}
				// Updating meRemapper with neId and MEDn
				sbiClient.getNaming().insert(x36Ne.getNeId(), meDn);
				// No need to create the ME
				meCreationNeeded = false;
			}
		} else {
			if (LOG.isDebugEnabled()) {
				LOG.debug(String.format("MECache is not having the any ME with NeId %d", neId));
			}
			meDn = meCache.get(x36Ne);
			if (meDn != null) {
				final int oldNeId = meCache.getKey(meDn);
				if (LOG.isDebugEnabled()) {
					LOG.debug(String.format("NeId change from %d to %d is detected during realignment for ME [%s]", oldNeId,
									neId, TmfNameUtilities.toString(meDn)));
				}
				// Updating the MECache with the new Acronym,Location and Identifier
				meCache.update(x36Ne, meDn);
				// Removing the old neId from neIdOnEmList
				sbiClient.removeNeIdOnEmList(new X36NeId(oldNeId));
				// Adding the new neId to neIdOnEmList
				sbiClient.addNeIdOnEmList(x36Ne.getNeId());
				if (sbiClient.getNaming().get(new X36NeId(oldNeId)) == null) {
					LOG.error(String.format("No entry with old NeId %d is found in meRemapper", oldNeId));
					// There is nothing with the old neId in remapper. Add the new entry.
					sbiClient.getNaming().insert(x36Ne.getNeId(), meDn);
				} else {
					sbiClient.getNaming().replaceNeId(new X36NeId(oldNeId), x36Ne.getNeId());
				}
				meCreationNeeded = false;
			} else {
				// No ME found with neId (or) Acronym/Location and Identifier. A new ME is to be created in the DB
				if (LOG.isDebugEnabled()) {
					LOG.debug("Creating a new ME...");
				}
			}
		}

		if (LOG.isDebugEnabled()) {
			LOG.debug(String.format("Process ME for <%s>: start....", neLocator));
		}

		final ManagedElement me = createME(neHelper.getNe(), checkNeeded);

		if (meCreationNeeded) {
			// Update the new NE in the MECache.
			meCache.put(neHelper.getNe().getNeId().getValue(), neHelper.getMEDn());
			meCache.put(MECache.formKey(me), me.getName());
		} else {
			final MEDn oldMeDn = meCache.get(neId);
			me.setName(oldMeDn);
		}

		updateMe(sbiClient, me, x36Ne, checkNeeded);

		return stats;
	}

	/**
	 * @param sbiClient
	 * @param me
	 * @param x36Ne
	 * @param checkNeeded
	 */
	private void updateMe(final SBIClientI sbiClient, final ManagedElement me, final X36NetworkElement x36Ne,
					final boolean checkNeeded) {
		DBManagedElement element = null;
		final String neLocator = sbiClient.getNeLocator(x36Ne.getNeId());
		final int neId = x36Ne.getNeId().getValue();
		try {
			stats.start(PROCESS_ME);
			if (checkNeeded) {
				element = sbiClient.getDbManager().getManagedElement(me.getName());
			}
			final boolean standAlone = sbiClient.isStandAlone();
			/*
			 * GG se sono stand alone allora se l'ME non esiste e' il primo riall. senno' verifico che e' presente
			 * l'additionalInfo se presente NON e' il primo riall. -> notificahe abilitate
			 */
			if (standAlone) {
				/*
				 * If TMF is in standnalone mode check if the element is already created in DB. If not, then this is the first
				 * time to realign If yes, check if it has any holders under it, if not then also this is considered as first time
				 * realignment, since the realignment is failed in the previous realignment because of some timeout exception
				 * (say)
				 */
				if ((element == null)) {
					firstRealignment = true;
				} else {
					final DBIterator<DBEquipmentHolder> holders = element.getHolders().iterator();
					if (!holders.hasNext()) {
						firstRealignment = true;
					}
					holders.close();
				}
			} else if (!standAlone) {
				if (element != null) {
					final DBAdditionalInformation dbAI = element.getAdditionalInformation(NEIdInEM.NAME);
					firstRealignment = dbAI == null;
				} else {
					firstRealignment = true;
				}
			}
			NotificatorsManager.getNotificator().setNotificationEnabled(!firstRealignment);

			final NeClassAdditionalInfo neClassAdditionalInfo = new NeClassAdditionalInfo(x36Ne.getNeInfo().getNeClass()
							.getValue());

			final LAGProvisioningSupported lagProvisioningSupported = new LAGProvisioningSupported(
							x36Ne.isPresentLagProvisioningSupported());

			if (element == null) {
				// Fix for TR HP27788
				if (standAlone) {
					element = sbiClient.getDbManager().createManagedElement(me);
					final DBSubnetwork subnetwork = getSN(x36Ne, checkNeeded);
					final AIMECoord coord = new AIMECoord();
					coord.setNeId(neId);
					element.addAdditionalInformation(new NEIdInEM(coord));
					element.addAdditionalInformation(neClassAdditionalInfo);
					element.addAdditionalInformation(lagProvisioningSupported);
					// don't forget to attach ME to its SN!!!!
					subnetwork.getMEs().add(element);
				} else {
					final String errorReason = "Cant create an ME by EMPlugOSS when TMF is not in Stand Alone mode";
					throw PlugInExceptionHandler.internalError(errorReason);
				}
			} else {
				//Fix for the TR HP64151 -- Setting previous value for "AsynchsReporting" in ME additionalinfo if TMF is started without dbreset.
				if(element.getAdditionalInfo() != null)
				{
					final String asyncValue = AdditionalInfoUtils.find(element.getAdditionalInfo(), ProprietaryAdditionalInfo.AsynchsReporting);
					final AdditionalInfo meAddInfo = me.getAdditionalInfo();
					AdditionalInfoUtils.update(meAddInfo, element.getType(), ProprietaryAdditionalInfo.AsynchsReporting.toString(), asyncValue);
				}

				sbiClient.getDbManager().update(element, me, false);
				final NEIdInEM ai = (NEIdInEM) element.getAdditionalInformation(NEIdInEM.NAME);
				final int id = neId;
				if (ai != null) {
					ai.getSyntax().setNeId(id);
					element.setAdditionalInformation(ai);
				} else {
					final AIMECoord coord = new AIMECoord();
					coord.setNeId(id);
					element.addAdditionalInformation(new NEIdInEM(coord));
				}

				if (element.getAdditionalInformation(NeClassAdditionalInfo.NAME) != null) {
					element.setAdditionalInformation(neClassAdditionalInfo);
				} else {
					element.addAdditionalInformation(neClassAdditionalInfo);
				}

				if (element.getAdditionalInformation(LAGProvisioningSupported.NAME) != null) {
					element.setAdditionalInformation(lagProvisioningSupported);
				} else {
					element.addAdditionalInformation(lagProvisioningSupported);
				}
			}
			final X36MatrixBehaviour x36MatrixBehaviour = x36Ne.getNeInfo().getMatrixBehaviour();
			if (x36MatrixBehaviour != null && isProtOperModeSupported(x36MatrixBehaviour)) {
				setAdditionalInfo(element, true);
			} else {
				setAdditionalInfo(element, false);
			}
			if (x36Ne.getNeUsageState().isAssociate()) {
				element.setCommunicationState(CommunicationState.CS_AVAILABLE);
			} else {
				element.setCommunicationState(CommunicationState.CS_UNAVAILABLE);
			}

			stats.end(PROCESS_ME);
		} catch (final Exception e) {
			LOG.error(new DumpInfo("Exception processing ME <" + neLocator + ">", e));
			throw PlugInExceptionHandler.internalError("Unable to process ME <" + neLocator + ">.\nReason: " + e.getMessage());
		}
		if (LOG.isDebugEnabled()) {
			LOG.debug(String.format("Process ME for <%s>: done.", neLocator));
		}

		stats.end(PROCESS_ME);

	}

	/*
	 * ** SBIConverter **********************************************************
	 */
	/**
	 * @param X36
	 * @param checkNeeded
	 * @return
	 */
	public ManagedElement createME(final X36NetworkElement X36, final boolean checkNeeded) {
		/* ************************************************************************** */
		final ManagedElement me = new ManagedElement();
		final int neId = X36.getNeId().getValue();
		final Profile profile = AdditionalInfoManager.getManager().getProfile();
		AdditionalInfo ai = new AdditionalInfo();
		final Profile plugInProfile = neHelper.getSBIClient().getPlugIn().getProfile();

		final String vendor = neHelper.getSBIClient().getProfile()
						.getProperty(EmsInformation.PropertyName.EMS_VENDOR, "Ericsson");

		me.setName(neHelper.getSBIClient().getNaming().makeMEDn(X36));

		String fmt = plugInProfile.getProperty(I36PlugIn.PluginProperty.namingMENativeNameFormat, "%2$s.%3$s.%4$d");
		String value = String.format(fmt, neId, X36.getLocation().getValue(), X36.getAcronym().getValue(), X36.getIdentifier()
						.getValue(), X36.getNsap().getValue(), vendor, X36.getNeInfo().getNeModel().getValue(), X36.getNeInfo()
						.getNeClass().getValue());
		me.setNativeEMSName(value);
		final boolean setUserLabel = plugInProfile.getBoolProperty(
						CommonProperties.PluginProperties.objectCreationSetMeUserLabel, true);

		if (setUserLabel) {
			me.setUserLabel(value);
			LOG.info("ME user label is " + value);
		} else {
			me.setUserLabel("");
		}

		fmt = neHelper.getSBIClient().getProfile().getProperty(DBObjectProperties.MEFormats.LOCATION, "%s");
		value = String.format(fmt, X36.getLocation().getValue());
		me.setLocation(value);
		me.setVersion("");

		final X36NeInfo neInfo = X36.getNeInfo();

		fmt = neHelper.getSBIClient().getProfile().getProperty(DBObjectProperties.MEFormats.PRODUCT_NAME, "%s/%s");
		value = String.format(fmt, vendor, neInfo.getNeModel().getValue());
		me.setProductName(value);
		me.setCommunicationState(convertCommunicationState(X36.getNeUsageState()));

		// ///////////////////////////////////////////////////////////////RM
		// Utilizzo il model come chiave della mappa dei matrix behaviour.
		final String neModel = neInfo.getNeModel().getValue();
		if (neModel.length() == 0) {
			LOG.info("Cannot retrieve matrix behaviour information for ME (" + neId + ")");
		}

		neHelper.getSBIClient().getPlugIn().getNeModelMapper().setNeModelIntoMap(neId, neModel);

		LOG.debug("Searching matrixBehaviour for model <" + neModel + "> ...");
		X36MatrixBehaviour X36MB = null;
		X36MatrixBehaviour matrixBehaviour = null;

		if (neInfo.isPresentMatrixBehaviour()) {
			X36MB = neInfo.getMatrixBehaviour();
		} else {
			LOG.warn("MatrixBehaviour not present for ME <" + neId + ">");
		}

		matrixBehaviour = updateNeAdditionalMB(neInfo, X36MB, neId);

		// ///////////////////////////////////////////////////////////////RM
		// if ( X36.getneInfo().isPresentmatrixBehaviour()) {
		LayerRateList lrList = new LayerRateList();
		if (X36MB != null) {
			lrList = LayerRateConverter.convertToLayerRateList(X36MB.getSetOfTrafficType(), neInfo.getOpticalLevel()
							.getSdhOpticalLevel());
		} else {
			lrList = new LayerRateList();
		}

		me.setSupportedRates(lrList);
		me.setOwner("");
		me.setEmsInSyncState(false);

		profile.setProperty(ProprietaryAdditionalInfo.Nsap.toString(), String.valueOf(X36.getNsap().getValue()));
		profile.setProperty(ProprietaryAdditionalInfo.Snpa.toString(), String.valueOf(X36.getSnpa().getValue()));
		profile.setProperty(ProprietaryAdditionalInfo.Address.toString(), String.valueOf(X36.getAddress().getValue()));
		profile.setProperty(ProprietaryAdditionalInfo.Room.toString(), String.valueOf(X36.getRoom().getValue()));
		profile.setProperty(ProprietaryAdditionalInfo.Row.toString(), String.valueOf(X36.getRow().getValue()));
		profile.setProperty(ProprietaryAdditionalInfo.Rack.toString(), String.valueOf(X36.getRack().getValue()));
		profile.setProperty(ProprietaryAdditionalInfo.Subrack.toString(), String.valueOf(X36.getSubrack().getValue()));
		profile.setProperty(ProprietaryAdditionalInfo.MEIDOnEM.toString(), String.valueOf(neId));
		profile.setProperty(ProprietaryAdditionalInfo.MENameOnEM.toString(), String.valueOf(X36.getLocation().getValue()));
		profile.setProperty(ProprietaryAdditionalInfo.MEAcronymOnEM.toString(), String.valueOf(X36.getAcronym().getValue()));
		profile.setProperty(ProprietaryAdditionalInfo.MESuffixOnEM.toString(), String.valueOf(X36.getIdentifier().getValue()));

		// for setting the additional information AsynchsReporting to the ManagedElement, default is yes
		profile.setProperty(ProprietaryAdditionalInfo.AsynchsReporting.toString(), "Yes");
		profile.setProperty(ProprietaryAdditionalInfo.PMPRealignmentStatus.toString(), "NotRealigned");

		final StringBuilder lab = new StringBuilder();
		for (final X36Label label : X36.getCustomerData()) {
			if (lab.length() > 0) {
				lab.append(",");
			}
			lab.append(String.valueOf(label.getLabelId().getValue())).append(": ");
			lab.append(String.valueOf(label.getLabelVal().getValue()));
		}
		final String labS = lab.toString();
		profile.setProperty(ProprietaryAdditionalInfo.CustomerData.toString(), labS);

		// ///////////////////////////////////////////////////////////////RM
		updateNeOpticleLevel(neInfo, profile);

		if (neInfo.isPresentPuiSupporting()) {
			profile.setProperty(ProprietaryAdditionalInfo.SupportedByI36.toString(),
							String.valueOf(neInfo.getPuiSupporting().getSupportedByI36().getValue()));
			profile.setProperty(ProprietaryAdditionalInfo.SupportedByRexec.toString(),
							String.valueOf(neInfo.getPuiSupporting().getSupportedByRexec().getValue()));
		}

		if (neInfo.isPresentGmplsInformation()) {
			updateGmplsInfo(neInfo, profile, value);
		}

		// ///////////////////////////////////////////////////////////////RM

		updateNeMatrixBehaviour(matrixBehaviour, profile, X36MB, neModel);
		updatePortLableInfo(neInfo, profile);

		profile.setProperty(ProprietaryAdditionalInfo.AdditionalText.toString(),
						String.valueOf(neInfo.getAdditionalText().getValue()));

		if (neInfo.isPresentOwnTargetNe()) {
			profile.setProperty(ProprietaryAdditionalInfo.OwnTargetNe.toString(),
							String.valueOf(neInfo.getOwnTargetNe().getValue()));
		}

		//Update the ME additionalInfo if the node supports MPLS-TP
		if (neHelper.getNodeConfiguration() != null && neHelper.getNodeConfiguration().isPresentMplsInfo()) {
			upadteAdditionalInfoForMpls(profile);
		}

		try {
			ai = AdditionalInfoManager.getAdditionalInfo(DBComponent.TMFObject.ManagedElement, profile);
		} catch (final RuntimeException e) {
			LOG.error(new DumpInfo(me.getName(), "Unable to load additional info for ME..."));
		}

		me.setAdditionalInfo(ai);

		if (LOG.isDebugEnabled()) {
			LOG.debug(new DumpInfo(me, "Created ManagedElement syntax..."));
		}

		return me;
	}

	/**
	 * This method will update the ME AdditionalInfo if the node support
	 * MPLS-TP.The information shall be stored as name and value pair, where
	 * name = "layeredParameters" and value format will be
	 * "/layerRate,name1,value1,name2,value2 etc
	 *
	 * @param profile
	 */
	private void upadteAdditionalInfoForMpls(final Profile profile) {

		final X36MplsNodeInfo mplsNodeInfo = neHelper.getNodeConfiguration().getMplsInfo().getMplsNodeInfo();
		final X36SetOfSignalModes setOfSinalModes = mplsNodeInfo.getMplsCapabilities().getListOfSupportedSignalMode();
		final StringBuilder supportedSgnType = getSupportedSignalTypes(setOfSinalModes);
		final String LR_MPLS_TP = "/LR_MPLS_TP,";
		try {
			//Set MPLSLabelSpace only if the node is in meshed configuration
			if (!neHelper.getSBIClient().isStandAlone()) {
				String labelSpace = null;
				if (mplsNodeInfo.getPlatformLabelSpace().getValue()) {
					labelSpace = "perPlatform";
				} else {
					labelSpace = "perInterface";
				}
				final String lParams = LR_MPLS_TP + ProprietaryParameterName.MplsLsrIdentifier.name() + ","
								+ changeLsrIdToIPFormat(mplsNodeInfo.getLsrId().getValue()) + ","
								+ ProprietaryParameterName.MPLSLabelSpace.name() + "," + labelSpace + ","
								+ ProprietaryParameterName.MPLSSignalModes.name() + "," + supportedSgnType.toString() + ","
								+ ProprietaryParameterName.LSPCrossConnectionTypes + "," + getLspXConnTypes(mplsNodeInfo);
				profile.setProperty(ProprietaryAdditionalInfo.LayeredParameters.name(), lParams);
			} else {
				final String lParams = LR_MPLS_TP + ProprietaryParameterName.MplsLsrIdentifier.name() + ","
								+ changeLsrIdToIPFormat(mplsNodeInfo.getLsrId().getValue()) + ","
								+ ProprietaryParameterName.MPLSSignalModes.name() + "," + supportedSgnType.toString() + ","
								+ ProprietaryParameterName.LSPCrossConnectionTypes + "," + getLspXConnTypes(mplsNodeInfo);
				profile.setProperty(ProprietaryAdditionalInfo.LayeredParameters.name(), lParams);
			}
		} catch (final Exception e) {
			LOG.error(new DumpInfo("Problem occur while converting lsrid to  IPv4 format"));
		}
	}

	/**
	 *convert LsrId value to IPv4 format
	 * @param lsrId
	 * @return
	 */
	private String changeLsrIdToIPFormat(final long lsrId) {
		String ip = null;
		try {
			ip = Inet4Address.getByName((Long.toString(lsrId))).getHostAddress();
		} catch (final Exception e) {
			LOG.error(new DumpInfo(lsrId, "Problem occur while converting  lsrId value to IPV4 format"));
		}
		return ip;
	}

	/**
	 * Returns a string containing the list cross connection types supported by
	 * LSP which are semi-colon separated
	 *
	 * @param mplsNodeInfo
	 * @return
	 */
	private String getLspXConnTypes(final X36MplsNodeInfo mplsNodeInfo) {
		String lspXConnType = "";
		final Boolean UnidirectionalLspSupported = mplsNodeInfo.getMplsCapabilities().getUnidirectionalLspSupported().getValue();
		final Boolean BidirectionalLspSupported = mplsNodeInfo.getMplsCapabilities().getBidirectionalLspSupported().getValue();
		final Boolean P2mpLspSupported = mplsNodeInfo.getMplsCapabilities().getP2mpLspSupported().getValue();

		if (UnidirectionalLspSupported) {
			lspXConnType = "unidirectional";
		}
		if (BidirectionalLspSupported) {
			if (lspXConnType != "") {
				lspXConnType = lspXConnType + ";" + "bidirectional";
			} else {
				lspXConnType = "bidirectional";
			}
		}
		if (P2mpLspSupported) {
			if (lspXConnType != "") {
				lspXConnType = lspXConnType + ";" + "broadcast";
			} else {
				lspXConnType = "broadcast";
			}
		}

		return lspXConnType;
	}

	/**
	 * Returns a string containing the list Signal modes supported by the node
	 * which are semi-colon separated
	 *
	 * @param setOf
	 * @return
	 */
	private StringBuilder getSupportedSignalTypes(final X36SetOfSignalModes setOf) {
		final StringBuilder modeStr = new StringBuilder();
		int count = setOf.size();
		for (final X36SignalMode mode : setOf) {
			modeStr.append(mode.getEnum());
			if ((count - 1) >= 1) {
				modeStr.append(";");
			}
			count--;
		}
		return modeStr;
	}

	/**
	 * This method updates additional Matrix behaviour information if any
	 * 
	 * @param neInfo
	 * @param X36MB
	 * @param neId
	 * @return
	 */
	private X36MatrixBehaviour updateNeAdditionalMB(final X36NeInfo neInfo, final X36MatrixBehaviour X36MB, final int neId) {
		X36MatrixBehaviour matrixBehaviour = null;
		if (neInfo.isPresentAdditionalMatrixes()) {
			final int size = neInfo.getAdditionalMatrixes().size();
			final List<X36MatrixBehaviour> matrixBehavList = new ArrayList<X36MatrixBehaviour>();
			for (int i = 0; i < size; i++) {
				final X36MatrixInformation matrixInfo = neInfo.getAdditionalMatrixes().get(i);
				final X36MatrixBehaviour matrixBehav = matrixInfo.getMatrixBehaviour();
				matrixBehavList.add(matrixBehav);
			}
			if (matrixBehavList.contains(X36MB)) {
				matrixBehaviour = X36MB;
			}
		} else {
			LOG.warn("AdditionalMatrixes not present for ME <" + neId + ">");
		}
		return matrixBehaviour;
	}

	/**
	 * This method updates porlLable info on ME
	 * 
	 * @param neInfo
	 * @param profile
	 */
	private void updatePortLableInfo(final X36NeInfo neInfo, final Profile profile) {
		if (neInfo.isPresentPortLabelSupporting()) {
			final X36PortLabelSupporting portLabel = neInfo.getPortLabelSupporting();
			if (portLabel.isNotSupported() || portLabel.isSupportedVarLength()) {
				profile.setProperty(ProprietaryAdditionalInfo.PortLabelSupporting.toString(), portLabel.getMemberName());
			} else if (neInfo.getPortLabelSupporting().isSupportedFixedLength()) {
				profile.setProperty(ProprietaryAdditionalInfo.PortLabelSupporting.toString(), portLabel.getMemberName() + ": "
								+ portLabel.getSupportedFixedLength().getValue());
			}
		}

	}

	/**
	 * This method updates ME opticle level information.
	 * 
	 * @param neInfo
	 * @param profile
	 */
	private void updateNeOpticleLevel(final X36NeInfo neInfo, final Profile profile) {
		if (neInfo.getOpticalLevel().isSdhOpticalLevel()) {
			final X36SdhOpticalLevel X36OL = neInfo.getOpticalLevel().getSdhOpticalLevel();

			// SdhOpticalLevel sdhOL = new SdhOpticalLevel();

			profile.setProperty(ProprietaryAdditionalInfo.SdhOpticalLevel.toString(), String.valueOf(X36OL.getEnum()));
		} else if (neInfo.getOpticalLevel().isWdmOpticalLevel()) {

			// WdmOpticalParam wdmOP = new WdmOpticalParam();
			// wdmOP.setlevel(
			// X36.getNeInfo().getOpticalLevel().getWdmOpticalLevel().getValue());
			profile.setProperty(ProprietaryAdditionalInfo.WdmOpticalLevel.toString(),
							String.valueOf(neInfo.getOpticalLevel().getWdmOpticalLevel().getValue()));
			if (neInfo.isPresentWdmChannelSpacing()) {
				// wdmOP.setchannelSpacing(
				// X36.getNeInfo().getWdmChannelSpacing().getValue());
				profile.setProperty(ProprietaryAdditionalInfo.ChannelSpacing.toString(),
								String.valueOf(neInfo.getWdmChannelSpacing().getValue()));
			}

			// ci va una new?
			// sdhWdmAddInfo.setPresentopticalParam();
			// sdhWdmAddInfo.getopticalParam().setwdmOpticalParam(wdmOP);

		} else if (neInfo.getOpticalLevel().isSonetOpticalLevel()) { // sonetOpticalLevel
			final X36StsLevel X36STSL = neInfo.getOpticalLevel().getSonetOpticalLevel();
			profile.setProperty(ProprietaryAdditionalInfo.SonetOpticalLevel.toString(), String.valueOf(X36STSL.getValue()));
		} else {
			final X36OduOpticalLevel X36OduOptlvl = neInfo.getOpticalLevel().getOduOpticalLevel();
			profile.setProperty(ProprietaryAdditionalInfo.OduOpticalLevel.toString(), String.valueOf(X36OduOptlvl.getValue()));
		}
	}

	/**
	 * This method updates GMPLs info of ME.
	 * 
	 * @param neInfo
	 * @param profile
	 * @param value
	 */
	private void updateGmplsInfo(final X36NeInfo neInfo, final Profile profile, final String value) {
		String tempValue = value;
		final X36GmplsInformation gmpls = neInfo.getGmplsInformation();
		if (gmpls.isPresentGmplsOperationalState()) {
			profile.setProperty(ProprietaryAdditionalInfo.GMPLSOperationalState, gmpls.getGmplsOperationalState().getEnum());
		}
		if (gmpls.isPresentGmplsAdministrativeState()) {
			profile.setProperty(ProprietaryAdditionalInfo.GMPLSAdministrativeState, gmpls.getGmplsAdministrativeState().getEnum());
		}
		if (gmpls.isPresentGmplsSignallingMode()) {
			profile.setProperty(ProprietaryAdditionalInfo.GMPLSSignallingMode, gmpls.getGmplsSignallingMode().getEnum());
		}
		if (gmpls.isPresentGmplsIpAddress()) {
			profile.setProperty(ProprietaryAdditionalInfo.GMPLSIpAddress, gmpls.getGmplsIpAddress().getValue());
		}
		if (gmpls.isPresentOspfRoutingArea()) {
			tempValue = gmpls.getOspfRoutingArea().getAddress().getValue();
			if (gmpls.getOspfRoutingArea().isPresentAddressType()) {
				tempValue = gmpls.getOspfRoutingArea().getAddressType().getEnum() + ": " + tempValue;
				profile.setProperty(ProprietaryAdditionalInfo.OSPFRoutingArea, tempValue);
			}
		}

	}

	/**
	 * This method updates Matrix behaviour of ME
	 * 
	 * @param matrixBehaviour
	 * @param profile
	 * @param X36MB
	 * @param neModel
	 */
	private void updateNeMatrixBehaviour(final X36MatrixBehaviour matrixBehaviour, final Profile profile,
					final X36MatrixBehaviour X36MB, final String neModel) {
		if (matrixBehaviour != null) {

			profile.setProperty(ProprietaryAdditionalInfo.SetOfTrafficType.toString(), getSetOfTrafficType(matrixBehaviour));

			profile.setProperty(ProprietaryAdditionalInfo.SetOfCrossConnectionType.toString(),
							getSetOfcrossConnectionType(matrixBehaviour));
		}

		if (X36MB != null) {
			LOG.debug("**** MATRIX BEHAVIOUR PRESENT FOR MODEL <" + neModel + "> ****");

			if (matrixBehaviour == null) {
				profile.setProperty(ProprietaryAdditionalInfo.SetOfTrafficType.toString(), getSetOfTrafficType(X36MB));

				profile.setProperty(ProprietaryAdditionalInfo.SetOfCrossConnectionType.toString(),
								getSetOfcrossConnectionType(X36MB));
			}

			profile.setProperty(ProprietaryAdditionalInfo.SetOfCrossConnectionCommand.toString(),
							getSetOfCrossConnectionCommand(X36MB));

			profile.setProperty(ProprietaryAdditionalInfo.SdhFrameStructureSupporting.toString(),
							String.valueOf(X36MB.getSdhFrameStructureSupporting().getValue()));
			profile.setProperty(ProprietaryAdditionalInfo.MsTwoFiberSpringSupporting.toString(),
							String.valueOf(X36MB.getMsTwoFiberSpringSupporting().getValue()));

			profile.setProperty(ProprietaryAdditionalInfo.MsTwoFiberSpringSupporting.toString(),
							String.valueOf(X36MB.getMsFourFiberSpringSupporting().getValue()));
			profile.setProperty(ProprietaryAdditionalInfo.SdhFrameStrWithSPRINGSupporting.toString(),
							String.valueOf(X36MB.getSdhFrameStrWithSPRINGSupporting().getValue()));
			profile.setProperty(ProprietaryAdditionalInfo.MspExtraTrafficSupporting.toString(),
							String.valueOf(X36MB.getMspExtraTrafficSupporting().getValue()));

			profile.setProperty(ProprietaryAdditionalInfo.MsspringTwoFiberExtraTrafficSupporting.toString(),
							String.valueOf(X36MB.getMsspringTwoFiberExtraTrafficSupporting().getValue()));

			profile.setProperty(ProprietaryAdditionalInfo.MsspringFourFiberExtraTrafficSupporting.toString(),
							String.valueOf(X36MB.getMsspringFourFiberExtraTrafficSupporting().getValue()));

			profile.setProperty(ProprietaryAdditionalInfo.MsspringSpanSwitchingSupporting.toString(),
							String.valueOf(X36MB.getMsspringSpanSwitchingSupporting().getValue()));

			profile.setProperty(ProprietaryAdditionalInfo.MsspringRingSwitchingSupporting.toString(),
							String.valueOf(X36MB.getMsspringRingSwitchingSupporting().getValue()));

			profile.setProperty(ProprietaryAdditionalInfo.MsspringTwoFiberVC4_4cSupporting.toString(),
							String.valueOf(X36MB.getMsspringTwoFiberVC4_4cSupporting().getValue()));

			profile.setProperty(ProprietaryAdditionalInfo.MsspringFourFiberVC4_4cSupporting.toString(),
							String.valueOf(X36MB.getMsspringFourFiberVC4_4cSupporting().getValue()));

			//
			// sdhWdmAddInfo.getmatrixBehaviour().setbroadcastMonoLegSupporting(
			// X36MB.getbroadcastMonoLegSupporting().getValue());
			//
			profile.setProperty(ProprietaryAdditionalInfo.BroadcastMonoLegSupporting.toString(),
							String.valueOf(X36MB.getBroadcastMonoLegSupporting().getValue()));

			// sdhWdmAddInfo.getmatrixBehaviour()
			// .setbidXconnConcatenatedFlagSupporting(
			// X36MB.getbidXconnConcatenatedFlagSupporting()
			// .getValue());

			profile.setProperty(ProprietaryAdditionalInfo.BidXconnConcatenatedFlagSupporting.toString(),
							String.valueOf(X36MB.getBidXconnConcatenatedFlagSupporting().getValue()));

			// sdhWdmAddInfo.getmatrixBehaviour().setsinkEndToEndHoSncpSupporting(
			// X36MB.getsinkEndToEndHoSncpSupporting().getValue());

			profile.setProperty(ProprietaryAdditionalInfo.SinkEndToEndHoSncpSupporting.toString(),
							String.valueOf(X36MB.getSinkEndToEndHoSncpSupporting().getValue()));

			// sdhWdmAddInfo.getmatrixBehaviour()
			// .setsourceEndToEndHoSncpSupporting(
			// X36MB.getsourceEndToEndHoSncpSupporting()
			// .getValue());

			profile.setProperty(ProprietaryAdditionalInfo.SourceEndToEndHoSncpSupporting.toString(),
							String.valueOf(X36MB.getSourceEndToEndHoSncpSupporting().getValue()));

			// sdhWdmAddInfo.getmatrixBehaviour().setbidEndToEndHoSncpSupporting(
			// X36MB.getbidEndToEndHoSncpSupporting().getValue());

			profile.setProperty(ProprietaryAdditionalInfo.BidEndToEndHoSncpSupporting.toString(),
							String.valueOf(X36MB.getBidEndToEndHoSncpSupporting().getValue()));

			if (X36MB.isPresentMsspringNutTypeSupporting()) {
				final X36MSSPRINGNutTypeSupporting X36NutSupporting = X36MB.getMsspringNutTypeSupporting();

				// MSSPRINGNutTypeSupporting tmfNutSupporting = new
				// MSSPRINGNutTypeSupporting();

				profile.setProperty(ProprietaryAdditionalInfo.NutSupporting.toString(),
								String.valueOf(X36NutSupporting.isPresentNutSupporting()));

				profile.setProperty(ProprietaryAdditionalInfo.ENutSupporting.toString(),
								String.valueOf(X36NutSupporting.isPresentENutSupporting()));

				profile.setProperty(ProprietaryAdditionalInfo.AllSpansOnly.toString(),
								String.valueOf(X36NutSupporting.isPresentAllSpansOnly()));
			}

			if (X36MB.isPresentMsspringPathInfoSupporting()) {
				profile.setProperty(ProprietaryAdditionalInfo.MsspringPathInfoSupporting.toString(),
								String.valueOf(X36MB.getMsspringPathInfoSupporting().getValue()));

			}

			if (X36MB.isPresentLoopbackConfigurationSupported()) {
				profile.setProperty(ProprietaryAdditionalInfo.loopbackConfigurationSupported.toString(),
								String.valueOf(X36MB.getLoopbackConfigurationSupported().getValue()));
			} else {
				profile.setProperty(ProprietaryAdditionalInfo.loopbackConfigurationSupported.toString(), "false");
			}
		}
	}

	/**
	 * This method returns DBSubnetwork associated with the ne.
	 * 
	 * @param ne
	 * @return
	 * @throws PlugInException
	 */
	protected DBSubnetwork getSN(final X36NetworkElement ne, final boolean checkNeeded) throws PlugInException {

		final SNDn snDn = neHelper.getSBIClient().getPlugIn().getSNDnFor(ne.getNeId());

		DBSubnetwork subnetwork = null;
		if (checkNeeded) {
			subnetwork = neHelper.getSBIClient().getDbManager().getSubnetwork(snDn);
		}

		if (subnetwork == null) {
			subnetwork = createSN(snDn);
		}
		return subnetwork;
	}

	/**
	 * This method creates DBSubnetwork with given snDn
	 * 
	 * @param snDn
	 * @return
	 * @throws PlugInException
	 */
	protected DBSubnetwork createSN(final SNDn snDn) throws PlugInException {
		final MultiLayerSubnetwork mls = neHelper.getSBIClient().getPlugIn().allocateSN(snDn);

		final EMSDn emsDn = new EMSDn();
		final DBEms ems = neHelper.getSBIClient().getDbManager().getEMS(emsDn);

		if (ems == null) {
			final String message = String.format("Unable to locate EMS <%s>: cannot create SN <%s>",
							TmfNameUtilities.toString(emsDn), TmfNameUtilities.toString(snDn));
			LOG.error(message);

			throw PlugInExceptionHandler.internalError(message);
		}
		DBSubnetwork subnetwork = neHelper.getSBIClient().getDbManager().getSubnetwork(snDn);

		if (subnetwork != null) {
			return subnetwork;
		}

		subnetwork = neHelper.getSBIClient().getDbManager().createSubnetwork(mls);
		// ems.getSubnetworks().add(subnetwork);

		return subnetwork;
	}

	private String getSetOfcrossConnectionType(final X36MatrixBehaviour X36MB) {

		final StringBuilder strBuf = new StringBuilder();
		for (final X36CrossConnectionType item : X36MB.getSetOfcrossConnectionType()) {
			if (strBuf.length() > 0) {
				strBuf.append(",");
			}
			strBuf.append(String.valueOf(item.getEnum()));
		}
		return strBuf.toString();

	}

	private String getSetOfTrafficType(final X36MatrixBehaviour X36MB) {

		final StringBuilder strBuf = new StringBuilder();
		for (final X36TrafficType item : X36MB.getSetOfTrafficType()) {
			if (strBuf.length() > 0) {
				strBuf.append(",");
			}
			strBuf.append(String.valueOf(item.getEnum()));
		}
		return strBuf.toString();

	}

	private String getSetOfCrossConnectionCommand(final X36MatrixBehaviour X36MB) {

		final StringBuilder strBuf = new StringBuilder();
		for (final X36CrossConnectionCommand item : X36MB.getSetOfcrossConnectionCommand()) {
			if (strBuf.length() > 0) {
				strBuf.append(",");
				strBuf.append(String.valueOf(item.getEnum()));
			}
		}
		return strBuf.toString();

	}

	/**
	 * Returns true if the matrixBehaviour has ProtOperMode else returns false.
	 * 
	 * @param matrixBehaviour
	 *            X36MatrixBehaviour
	 * @return boolean
	 */
	private boolean isProtOperModeSupported(final X36MatrixBehaviour matrixBehaviour) {
		boolean isProtOperSupported = false;
		final X36SetOfCrossConnectionCommand setOfXCCmd = matrixBehaviour.getSetOfcrossConnectionCommand();
		final X36CrossConnectionCommand[] xcCmdLst = setOfXCCmd.getAll();
		for (final X36CrossConnectionCommand xcCmd : xcCmdLst) {
			if (xcCmd.getValue() == X36CrossConnectionCommand.protOperMode) {
				isProtOperSupported = true;
				break;
			}
		}
		return isProtOperSupported;
	}

	/**
	 * If the matrixBehaviour holds the protOperMode then sets
	 * ProtOperMode.SUPPORTED else sets ProtOperMode.UNSUPPORTED.
	 * 
	 * @param element
	 *            DBManagedElement
	 * @param isSupported
	 *            boolean
	 */
	private void setAdditionalInfo(final DBManagedElement element, final boolean isSupported) {
		ProtOperModeSupported protOperModeSupp = null;
		if (isSupported) {
			protOperModeSupp = new ProtOperModeSupported(ProtOperMode.supported);
		} else {
			protOperModeSupp = new ProtOperModeSupported(ProtOperMode.unSupported);
		}
		if (element.getAdditionalInformation(ProtOperModeSupported.NAME) != null) {
			element.setAdditionalInformation(protOperModeSupp);
		} else {
			element.addAdditionalInformation(protOperModeSupp);
		}
	}
}
